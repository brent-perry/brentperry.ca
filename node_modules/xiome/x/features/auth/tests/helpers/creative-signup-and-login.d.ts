export declare function creativeSignupAndLogin(email: string): Promise<{
    models: {
        appModel: {
            readonly state: {
                active: boolean;
                appRecords: import("../../../../framework/ops.js").Op<import("../../models/types/app/app-records.js").AppRecords>;
                addingNewApp: import("../../../../framework/ops.js").Op<null>;
            };
            getApp(appId: string): import("../../types/apps/app-display.js").AppDisplay;
            onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
            loadApps: () => Promise<import("../../types/apps/app-display.js").AppDisplay[]>;
            deleteApp: (appId: string) => Promise<void>;
            updateApp: (appId: string, appDraft: import("../../types/apps/app-draft.js").AppDraft) => Promise<void>;
            registerApp: (appDraft: import("../../types/apps/app-draft.js").AppDraft) => Promise<import("../../types/apps/app-display.js").AppDisplay>;
            manageAdminsService: import("renraku/x/types/primitives/business").Business<{
                listAdmins(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<import("../../types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            }>;
            accessChange(): Promise<void>;
        };
        authModel: {
            track: <X>(stakeout: import("../../../../toolbox/autowatcher/types/autowatcher-types.js").Stakeout<X>) => () => void;
            readonly access: import("../../../../framework/ops.js").Op<import("../../types/tokens/access-payload.js").AccessPayload>;
            onAccessChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../mediator/types/access-event-listener.js").AccessEventListener>;
            getValidAccess(): Promise<import("../../types/tokens/access-payload.js").AccessPayload>;
            useExistingLogin(): Promise<void>;
            sendLoginLink(email: string): Promise<void>;
            login(loginToken: string): Promise<void>;
            logout(): Promise<void>;
            reauthorize(): Promise<void>;
        };
        personalModel: {
            readonly submitDraftOp: import("../../../../framework/ops.js").Op<void>;
            saveProfile(profileDraft: import("../../topics/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
        };
        questionsModel: {
            onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
            makeBoardModel: (board: string) => {
                getPermissions(): {
                    "read questions": boolean;
                    "post questions": boolean;
                    "moderate questions": boolean;
                };
                getBoardName(): string;
                getAccess(): import("../../types/tokens/access-payload.js").AccessPayload;
                getBoardOp(): import("../../../../framework/ops.js").Op<void>;
                getPostingOp(): import("../../../../framework/ops.js").Op<void>;
                getQuestions(): import("../../../questions/api/types/question.js").Question[];
                getUser(userId: string): import("../../types/user.js").User;
                loadQuestions(): Promise<void>;
                postQuestion(questionDraft: import("../../../questions/api/types/question-draft.js").QuestionDraft): Promise<void>;
                likeQuestion(questionId: string, like: boolean): Promise<void>;
                reportQuestion(questionId: string, report: boolean): Promise<void>;
                archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                archiveBoard(): Promise<void>;
            };
            accessChange: (access: import("../../types/tokens/access-payload.js").AccessPayload) => void;
        };
        permissionsModel: {
            onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
            getState: () => {
                active: boolean;
                access: import("../../types/tokens/access-payload.js").AccessPayload;
                permissionsDisplay: import("../../../../framework/ops.js").Op<import("../../topics/permissions/types/permissions-display.js").PermissionsDisplay>;
            };
            initialize: () => Promise<void>;
            getUserCanCustomizePermissions: () => boolean;
            createRole: (args_0: {
                label: string;
            }) => Promise<void>;
            deleteRole: (args_0: {
                roleId: string;
            }) => Promise<void>;
            assignPrivilege: (args_0: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            unassignPrivilege: (args_0: {
                roleId: string;
                privilegeId: string;
            }) => Promise<void>;
            accessChange(access: import("../../types/tokens/access-payload.js").AccessPayload): Promise<void>;
        };
        administrativeModel: {
            getState: () => {
                access: import("../../types/tokens/access-payload.js").AccessPayload;
                permissionsOp: import("../../../../framework/ops.js").Op<import("../../topics/permissions/types/permissions-display.js").PermissionsDisplay>;
            };
            onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
            initialize: () => Promise<void>;
            readonly isAllowed: (privilege: "read questions" | "post questions" | "like questions" | "report questions" | "edit any profile" | "customize permissions" | "moderate questions" | "view stats" | "administrate user roles" | "banned" | "manage store" | "give away freebies") => boolean;
            accessChange: (access: import("../../types/tokens/access-payload.js").AccessPayload) => void;
            reauthorize: () => Promise<void>;
            searchUsers: (args_0: {
                term: string;
            }) => Promise<{
                user: {
                    userId: string;
                    profile: import("../../types/profile.js").Profile;
                    roles: import("../../types/public-user-role.js").PublicUserRole[];
                    stats: import("../../types/user-stats.js").UserStats;
                };
                roleIds: string[];
            }[]>;
            assignRoleToUser: (args_0: {
                roleId: string;
                userId: string;
                isPublic: boolean;
                timeframeEnd: number;
                timeframeStart: number;
            }) => Promise<void>;
            revokeRoleFromUser: (args_0: {
                roleId: string;
                userId: string;
            }) => Promise<void>;
        };
    };
    remote: import("renraku/x/types/remote/to-remote").ToRemote<{
        auth: {
            greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../policies/types/green-auth.js").GreenAuth, {
                authorize({ bakeTables }: import("../../policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                    scope: import("../../types/tokens/scope.js").Scope;
                    appId: string;
                    refreshToken?: string;
                }): Promise<string>;
            }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/anon-meta.js").AnonMeta, import("../../policies/types/anon-auth.js").AnonAuth, {
                sendLoginLink({ access, tables }: import("../../policies/types/anon-auth.js").AnonAuth, { email }: {
                    email: string;
                }): Promise<void>;
                authenticateViaLoginToken({ tables, access }: import("../../policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                    loginToken: string;
                }): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    accessToken: Promise<string>;
                    refreshToken: Promise<string>;
                }>>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/anon-meta.js").AnonMeta, import("../../policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/platform-user-meta.js").PlatformUserMeta, import("../../policies/types/platform-user-auth.js").PlatformUserAuth, {
                listApps({ tables, statsHub }: import("../../policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                    ownerUserId: string;
                }): Promise<import("../../types/apps/app-display.js").AppDisplay[]>;
                registerApp({ tables }: import("../../policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                    appDraft: import("../../types/apps/app-draft.js").AppDraft;
                    ownerUserId: string;
                }): Promise<import("../../types/apps/app-display.js").AppDisplay>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/platform-user-meta.js").PlatformUserMeta, import("../../policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/app-owner-meta.js").AppOwnerMeta, import("../../policies/types/app-owner-auth.js").AppOwnerAuth, {
                updateApp({ tables, access }: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                    appId: string;
                    appDraft: import("../../types/apps/app-draft.js").AppDraft;
                }): Promise<void>;
                deleteApp({ tables, access }: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/app-owner-meta.js").AppOwnerMeta, import("../../policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/app-owner-meta.js").AppOwnerMeta, import("../../policies/types/app-owner-auth.js").AppOwnerAuth, {
                listAdmins(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<import("../../types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin(auth: import("../../policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/app-owner-meta.js").AppOwnerMeta, import("../../policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth, {
                setProfile({ access, tables, checker }: import("../../policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                    userId: string;
                    profileDraft: import("../../topics/personal/types/profile-draft.js").ProfileDraft;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/anon-meta.js").AnonMeta, import("../../policies/types/anon-auth.js").AnonAuth, {
                getUser({ tables, access }: import("../../policies/types/anon-auth.js").AnonAuth, { userId }: {
                    userId: string;
                }): Promise<{
                    userId: string;
                    profile: import("../../types/profile.js").Profile;
                    roles: import("../../types/public-user-role.js").PublicUserRole[];
                    stats: import("../../types/user-stats.js").UserStats;
                }>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/anon-meta.js").AnonMeta, import("../../policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                createRole({ tables }: import("../../policies/types/user-auth.js").UserAuth, { label }: {
                    label: string;
                }): Promise<void>;
                deleteRole({ tables }: import("../../policies/types/user-auth.js").UserAuth, { roleId }: {
                    roleId: string;
                }): Promise<void>;
                assignPrivilege({ tables }: import("../../policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
                unassignPrivilege({ tables }: import("../../policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
        };
        administrative: {
            roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                searchUsers({ tables, access }: import("../../policies/types/user-auth.js").UserAuth, options: {
                    term: string;
                }): Promise<{
                    user: {
                        userId: string;
                        profile: import("../../types/profile.js").Profile;
                        roles: import("../../types/public-user-role.js").PublicUserRole[];
                        stats: import("../../types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser({ tables }: import("../../policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }): Promise<void>;
                revokeRoleFromUser({ tables }: import("../../policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../policies/types/user-auth.js").UserAuth>;
            }>;
        };
        questions: {
            questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/anon-meta.js").AnonMeta, import("../../policies/types/anon-auth.js").AnonAuth & {
                questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                fetchQuestions({ questionsTables, tables, access }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/anon-auth.js").AnonAuth, { board }: {
                    board: string;
                }): Promise<{
                    questions: any[];
                    users: any[];
                }>;
            }, {
                processAuth: (meta: import("../../policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../policies/types/anon-auth.js").AnonAuth & {
                    questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                postQuestion({ questionsTables, access, checker }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/user-auth.js").UserAuth, { questionDraft }: {
                    questionDraft: import("../../../questions/api/types/question-draft.js").QuestionDraft;
                }): Promise<import("../../../questions/api/types/question.js").Question>;
                archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                    archive: boolean;
                    questionId: string;
                }): Promise<void>;
                likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/user-auth.js").UserAuth, { questionId, like }: {
                    questionId: string;
                    like: boolean;
                }): Promise<void>;
                reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/user-auth.js").UserAuth, { questionId, report }: {
                    questionId: string;
                    report: boolean;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../policies/types/user-meta.js").UserMeta, import("../../policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                archiveBoard({ questionsTables }: import("../../../questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../policies/types/user-auth.js").UserAuth, { board }: {
                    board: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
        };
    }>;
    nextModalResults: {
        confirm: boolean;
        prompt: {
            value: any;
        };
    };
}>;
