var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import styles from "./xiome-manage-users.css.js";
import wrenchSvg from "../../../framework/icons/wrench.svg.js";
import { ops } from "../../../framework/ops.js";
import { debounce3 } from "../../../toolbox/debounce2.js";
import { makeUserStates } from "./parts/make-user-states.js";
import { renderEditWidget } from "./parts/render-edit-widget.js";
import { renderOp } from "../../../framework/op-rendering/render-op.js";
import { validateUserSearchTerm } from "../api/services/validation/validate-user-search-term.js";
import { Component3WithShare, html, mixinStyles, property } from "../../../framework/component2/component2.js";
let XiomeManageUsers = class XiomeManageUsers extends Component3WithShare {
    constructor() {
        super(...arguments);
        this.userResults = ops.ready([]);
        this.updateLocalUserResultsCache = {
            assignRole: (userId, roleId) => {
                if (!ops.ready(this.userResults))
                    throw new Error("error updating user cache");
                const userResults = ops.value(this.userResults);
                this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                    ? { user: result.user, roleIds: [...result.roleIds, roleId] }
                    : result));
            },
            revokeRole: (userId, roleId) => {
                if (!ops.ready(this.userResults))
                    throw new Error("error updating user cache");
                const userResults = ops.value(this.userResults);
                this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                    ? { user: result.user, roleIds: result.roleIds.filter(id => id !== roleId) }
                    : result));
            },
        };
        this.userStates = makeUserStates({
            getUserResultsOp: () => this.userResults,
            rerender: () => this.requestUpdate(),
        });
        this.searchText = "";
        this.debouncedSearchUsers = debounce3(1000, async (term) => term
            ? await this.share.administrativeModel.searchUsers({ term })
            : []);
        this.searchChange = async (event) => {
            this.searchText = event.detail.value ?? "";
            return this.search();
        };
    }
    init() {
        this.share.administrativeModel.initialize();
    }
    async search() {
        const { searchText } = this;
        this.userResults = ops.ready([]);
        if (searchText)
            await ops.operation({
                promise: this.debouncedSearchUsers(searchText),
                setOp: op => this.userResults = op,
            });
        else
            this.userResults = ops.ready([]);
        this.userStates.cleanupObsoleteStates();
    }
    render() {
        const { permissionsOp } = this.share.administrativeModel.getState();
        const allowed = this.share.administrativeModel
            .isAllowed("administrate user roles");
        const renderUser = (userResult) => {
            const { user } = userResult;
            const state = this.userStates.obtainStateForUser(user.userId);
            return html `
				<li>
					<div class=userinfo>
						<xio-profile-card
							.user=${user}
							show-details
						></xio-profile-card>
						<div class=controls>
							<xio-button
								class=edit
								?data-edit-mode=${state.editMode}
								@press=${state.toggleEditMode}>
									${wrenchSvg}
							</xio-button>
						</div>
					</div>
					${state.editMode
                ? renderOp(permissionsOp, permissions => renderEditWidget({
                    userResult,
                    permissions,
                    administrativeModel: this.share.administrativeModel,
                    updateLocalUserResultsCache: this.updateLocalUserResultsCache,
                    blur: () => {
                        const activeElement = document.activeElement;
                        if (activeElement)
                            activeElement.blur();
                    },
                    search: () => this.search(),
                }))
                : null}
				</li>
			`;
        };
        return html `
			<div class=container>

				${allowed ? html `
					<xio-text-input
						.text=${this.searchText}
						placeholder="search for users"
						.validator=${validateUserSearchTerm}
						@valuechange=${this.searchChange}
					></xio-text-input>

					<div class=results>
						${renderOp(this.userResults, results => results.length > 0
            ? html `
								<ol class=userlist>
									${results.map(renderUser)}
								</ol>
							`
            : html `
								<div class=noresults>
									no results
								</div>
							`)}
					</div>
				` : html `
					<p>you are not permitted to administrate user roles</p>
				`}

			</div>
		`;
    }
};
__decorate([
    property()
], XiomeManageUsers.prototype, "userResults", void 0);
__decorate([
    property({ type: String })
], XiomeManageUsers.prototype, "searchText", void 0);
XiomeManageUsers = __decorate([
    mixinStyles(styles)
], XiomeManageUsers);
export { XiomeManageUsers };
//# sourceMappingURL=xiome-manage-users.js.map