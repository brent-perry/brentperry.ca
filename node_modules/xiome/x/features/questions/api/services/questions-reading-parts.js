import { find } from "../../../../toolbox/dbby/dbby-helpers.js";
import { resolveQuestions } from "./helpers/resolve-questions.js";
import { anonQuestionsPolicy } from "./policies/anon-questions-policy.js";
import { fetchUsers } from "../../../auth/topics/login/user/fetch-users.js";
import { asServiceParts } from "../../../../framework/api/as-service-parts.js";
import { makePermissionsEngine } from "../../../../assembly/backend/permissions2/permissions-engine.js";
export const questionsReadingParts = (options) => asServiceParts()({
    policy: async (meta, request) => {
        const auth = await anonQuestionsPolicy(options)(meta, request);
        auth.checker.requirePrivilege("read questions");
        return auth;
    },
    expose: {
        async fetchQuestions({ questionsTables, tables, access }, { board }) {
            const posts = await questionsTables.questionPosts
                .read({
                ...find({ board, archive: false }),
                limit: 100,
                offset: 0,
                order: { timePosted: "descend" },
            });
            let questions = [];
            let users = [];
            if (posts.length) {
                const permissionsEngine = makePermissionsEngine({
                    isPlatform: access.appId === options.config.platform.appDetails.appId,
                    permissionsTables: tables.permissions,
                });
                users = await fetchUsers({
                    permissionsEngine,
                    authTables: tables,
                    userIds: posts.map(p => p.authorUserId),
                });
                questions = await resolveQuestions({
                    posts,
                    questionsTables,
                    userId: access?.user?.userId,
                });
            }
            return { questions, users };
        },
    },
});
//# sourceMappingURL=questions-reading-parts.js.map