import { merge } from "../../../toolbox/merge.js";
import { ops } from "../../../framework/ops.js";
import { happystate } from "../../../toolbox/happystate/happystate.js";
import { appPermissions } from "../../../assembly/backend/permissions2/standard-permissions.js";
export function makeQuestionsModel({ questionsReadingService, questionsPostingService, questionsModerationService, getAccess, }) {
    const { actions, getState, onStateChange } = happystate({
        state: {
            access: undefined,
            users: [],
            questions: [],
            boardOps: {},
            postingOp: ops.ready(undefined),
        },
        actions: state => ({
            setAccess(access) {
                state.access = access;
            },
            setBoardOp(board, op) {
                state.boardOps = { ...state.boardOps, [board]: op };
            },
            setPostingOp(op) {
                state.postingOp = op;
            },
            addUsers(newUsers) {
                state.users = [...merge(newUsers, state.users, (a, b) => a.userId === b.userId)];
            },
            addQuestions(newQuestions) {
                state.questions = [...merge(newQuestions, state.questions, (a, b) => a.questionId === b.questionId)];
            },
            setQuestionLike(questionId, like) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        liked: like,
                        likes: question.liked === like
                            ? question.likes
                            : like
                                ? question.likes + 1
                                : question.likes - 1
                    }
                    : { ...question });
            },
            setQuestionReport(questionId, report) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        reported: report,
                        reports: question.reported === report
                            ? question.reports
                            : report
                                ? question.reports + 1
                                : question.reports - 1
                    }
                    : { ...question });
            },
            setQuestionArchive(questionId, archive) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? { ...question, archive }
                    : { ...question });
            },
        }),
    });
    async function loadQuestionsForBoard(board) {
        await ops.operation({
            promise: (async () => {
                const { users, questions } = await questionsReadingService
                    .fetchQuestions({ board });
                actions.addUsers(users);
                actions.addQuestions(questions);
            })(),
            setOp: op => actions.setBoardOp(board, op),
        });
    }
    function makeBoardModel(board) {
        return {
            getPermissions() {
                const { access } = getState();
                return {
                    "read questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["read questions"])
                        : false,
                    "post questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["post questions"]) && !access.permit.privileges.includes(appPermissions.privileges["banned"])
                        : false,
                    "moderate questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["moderate questions"])
                        : false,
                };
            },
            getBoardName() {
                return board;
            },
            getAccess() {
                return getState().access;
            },
            getBoardOp() {
                return getState().boardOps[board];
            },
            getPostingOp() {
                return getState().postingOp;
            },
            getQuestions() {
                return getState().questions
                    .filter(question => question.board === board)
                    .filter(question => question.archive === false);
            },
            getUser(userId) {
                return getState().users.find(user => user.userId === userId);
            },
            async loadQuestions() {
                await loadQuestionsForBoard(board);
            },
            async postQuestion(questionDraft) {
                const question = await ops.operation({
                    promise: questionsPostingService.postQuestion({ questionDraft }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addQuestions([question]);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
            },
            async likeQuestion(questionId, like) {
                await questionsPostingService.likeQuestion({
                    like,
                    questionId,
                });
                actions.setQuestionLike(questionId, like);
            },
            async reportQuestion(questionId, report) {
                await questionsPostingService.reportQuestion({
                    report,
                    questionId,
                });
                actions.setQuestionReport(questionId, report);
            },
            async archiveQuestion(questionId, archive) {
                await questionsPostingService.archiveQuestion({
                    archive,
                    questionId,
                });
                actions.setQuestionArchive(questionId, archive);
            },
            async archiveBoard() {
                await questionsModerationService.archiveBoard({ board });
                for (const question of getState().questions)
                    actions.setQuestionArchive(question.questionId, true);
            },
        };
    }
    async function refreshAllBoards() {
        const state = getState();
        await Promise.all(Object.keys(state.boardOps).map(loadQuestionsForBoard));
    }
    return {
        onStateChange,
        makeBoardModel,
        accessChange: (access) => {
            actions.setAccess(access);
            if (access?.user)
                actions.addUsers([access.user]);
            refreshAllBoards();
        },
    };
}
//# sourceMappingURL=questions-model.js.map