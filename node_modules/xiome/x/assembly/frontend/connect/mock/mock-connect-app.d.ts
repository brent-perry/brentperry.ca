/// <reference types="stripe/types/shared" />
/// <reference types="stripe/types/Errors" />
/// <reference types="stripe/types/OAuth" />
/// <reference types="stripe/types/Webhooks" />
/// <reference types="stripe/types/2020-08-27/AccountLinks" />
/// <reference types="stripe/types/2020-08-27/Accounts" />
/// <reference types="stripe/types/2020-08-27/AlipayAccounts" />
/// <reference types="stripe/types/2020-08-27/ApplePayDomains" />
/// <reference types="stripe/types/2020-08-27/ApplicationFees" />
/// <reference types="stripe/types/2020-08-27/Applications" />
/// <reference types="stripe/types/2020-08-27/Balance" />
/// <reference types="stripe/types/2020-08-27/BalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/BankAccounts" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Configurations" />
/// <reference types="stripe/types/2020-08-27/BillingPortal/Sessions" />
/// <reference types="stripe/types/2020-08-27/BitcoinReceivers" />
/// <reference types="stripe/types/2020-08-27/BitcoinTransactions" />
/// <reference types="stripe/types/2020-08-27/Capabilities" />
/// <reference types="stripe/types/2020-08-27/Cards" />
/// <reference types="stripe/types/2020-08-27/Charges" />
/// <reference types="stripe/types/2020-08-27/Checkout/Sessions" />
/// <reference types="stripe/types/2020-08-27/ConnectCollectionTransfers" />
/// <reference types="stripe/types/2020-08-27/CountrySpecs" />
/// <reference types="stripe/types/2020-08-27/Coupons" />
/// <reference types="stripe/types/2020-08-27/CreditNoteLineItems" />
/// <reference types="stripe/types/2020-08-27/CreditNotes" />
/// <reference types="stripe/types/2020-08-27/CustomerBalanceTransactions" />
/// <reference types="stripe/types/2020-08-27/CustomerSources" />
/// <reference types="stripe/types/2020-08-27/Customers" />
/// <reference types="stripe/types/2020-08-27/Discounts" />
/// <reference types="stripe/types/2020-08-27/Disputes" />
/// <reference types="stripe/types/2020-08-27/EphemeralKeys" />
/// <reference types="stripe/types/2020-08-27/Events" />
/// <reference types="stripe/types/2020-08-27/ExchangeRates" />
/// <reference types="stripe/types/2020-08-27/ExternalAccounts" />
/// <reference types="stripe/types/2020-08-27/FeeRefunds" />
/// <reference types="stripe/types/2020-08-27/FileLinks" />
/// <reference types="stripe/types/2020-08-27/Files" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationReports" />
/// <reference types="stripe/types/2020-08-27/Identity/VerificationSessions" />
/// <reference types="stripe/types/2020-08-27/InvoiceItems" />
/// <reference types="stripe/types/2020-08-27/InvoiceLineItems" />
/// <reference types="stripe/types/2020-08-27/Invoices" />
/// <reference types="stripe/types/2020-08-27/IssuerFraudRecords" />
/// <reference types="stripe/types/2020-08-27/Issuing/Authorizations" />
/// <reference types="stripe/types/2020-08-27/Issuing/CardDetails" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cardholders" />
/// <reference types="stripe/types/2020-08-27/Issuing/Cards" />
/// <reference types="stripe/types/2020-08-27/Issuing/Disputes" />
/// <reference types="stripe/types/2020-08-27/Issuing/Transactions" />
/// <reference types="stripe/types/2020-08-27/LineItems" />
/// <reference types="stripe/types/2020-08-27/LoginLinks" />
/// <reference types="stripe/types/2020-08-27/Mandates" />
/// <reference types="stripe/types/2020-08-27/OrderItems" />
/// <reference types="stripe/types/2020-08-27/OrderReturns" />
/// <reference types="stripe/types/2020-08-27/Orders" />
/// <reference types="stripe/types/2020-08-27/PaymentIntents" />
/// <reference types="stripe/types/2020-08-27/PaymentMethods" />
/// <reference types="stripe/types/2020-08-27/Payouts" />
/// <reference types="stripe/types/2020-08-27/Persons" />
/// <reference types="stripe/types/2020-08-27/Plans" />
/// <reference types="stripe/types/2020-08-27/PlatformTaxFees" />
/// <reference types="stripe/types/2020-08-27/Prices" />
/// <reference types="stripe/types/2020-08-27/Products" />
/// <reference types="stripe/types/2020-08-27/PromotionCodes" />
/// <reference types="stripe/types/2020-08-27/Radar/EarlyFraudWarnings" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueListItems" />
/// <reference types="stripe/types/2020-08-27/Radar/ValueLists" />
/// <reference types="stripe/types/2020-08-27/Recipients" />
/// <reference types="stripe/types/2020-08-27/Refunds" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportRuns" />
/// <reference types="stripe/types/2020-08-27/Reporting/ReportTypes" />
/// <reference types="stripe/types/2020-08-27/ReserveTransactions" />
/// <reference types="stripe/types/2020-08-27/Reviews" />
/// <reference types="stripe/types/2020-08-27/SKUs" />
/// <reference types="stripe/types/2020-08-27/SetupAttempts" />
/// <reference types="stripe/types/2020-08-27/SetupIntents" />
/// <reference types="stripe/types/2020-08-27/Sigma/ScheduledQueryRuns" />
/// <reference types="stripe/types/2020-08-27/SourceMandateNotifications" />
/// <reference types="stripe/types/2020-08-27/SourceTransactions" />
/// <reference types="stripe/types/2020-08-27/Sources" />
/// <reference types="stripe/types/2020-08-27/SubscriptionItems" />
/// <reference types="stripe/types/2020-08-27/SubscriptionSchedules" />
/// <reference types="stripe/types/2020-08-27/Subscriptions" />
/// <reference types="stripe/types/2020-08-27/TaxCodes" />
/// <reference types="stripe/types/2020-08-27/TaxDeductedAtSources" />
/// <reference types="stripe/types/2020-08-27/TaxIds" />
/// <reference types="stripe/types/2020-08-27/TaxRates" />
/// <reference types="stripe/types/2020-08-27/Terminal/ConnectionTokens" />
/// <reference types="stripe/types/2020-08-27/Terminal/Locations" />
/// <reference types="stripe/types/2020-08-27/Terminal/Readers" />
/// <reference types="stripe/types/2020-08-27/Tokens" />
/// <reference types="stripe/types/2020-08-27/Topups" />
/// <reference types="stripe/types/2020-08-27/TransferReversals" />
/// <reference types="stripe/types/2020-08-27/Transfers" />
/// <reference types="stripe/types/2020-08-27/UsageRecordSummaries" />
/// <reference types="stripe/types/2020-08-27/UsageRecords" />
/// <reference types="stripe/types/2020-08-27/WebhookEndpoints" />
/// <reference types="stripe" />
/// <reference types="stripe/types/lib" />
import { MockLatency } from "../../../../framework/add-mock-latency.js";
import { FlexStorage } from "../../../../toolbox/flex-storage/types/flex-storage.js";
export declare function mockConnectApp({ origins, latency, storage, appWindowLink, }: {
    origins: string[];
    latency: MockLatency;
    storage: FlexStorage;
    appWindowLink: string;
}): Promise<{
    appId: string;
    remote: import("renraku/x/types/remote/to-remote").ToRemote<{
        auth: {
            greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, {
                authorize({ bakeTables }: import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                    scope: import("../../../../features/auth/types/tokens/scope.js").Scope;
                    appId: string;
                    refreshToken?: string;
                }): Promise<string>;
            }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                sendLoginLink({ access, tables }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { email }: {
                    email: string;
                }): Promise<void>;
                authenticateViaLoginToken({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                    loginToken: string;
                }): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    accessToken: Promise<string>;
                    refreshToken: Promise<string>;
                }>>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, {
                listApps({ tables, statsHub }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                    ownerUserId: string;
                }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                registerApp({ tables }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                    appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                    ownerUserId: string;
                }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                updateApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                    appId: string;
                    appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                }): Promise<void>;
                deleteApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                listAdmins(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<import("../../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                setProfile({ access, tables, checker }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                    userId: string;
                    profileDraft: import("../../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                getUser({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { userId }: {
                    userId: string;
                }): Promise<{
                    userId: string;
                    profile: import("../../../../features/auth/types/profile.js").Profile;
                    roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                    stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                }>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                createRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { label }: {
                    label: string;
                }): Promise<void>;
                deleteRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId }: {
                    roleId: string;
                }): Promise<void>;
                assignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
                unassignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
        };
        administrative: {
            roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                searchUsers({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    term: string;
                }): Promise<{
                    user: {
                        userId: string;
                        profile: import("../../../../features/auth/types/profile.js").Profile;
                        roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }): Promise<void>;
                revokeRoleFromUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth>;
            }>;
        };
        questions: {
            questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                fetchQuestions({ questionsTables, tables, access }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { board }: {
                    board: string;
                }): Promise<{
                    questions: any[];
                    users: any[];
                }>;
            }, {
                processAuth: (meta: import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                postQuestion({ questionsTables, access, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionDraft }: {
                    questionDraft: import("../../../../features/questions/api/types/question-draft.js").QuestionDraft;
                }): Promise<import("../../../../features/questions/api/types/question.js").Question>;
                archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                    archive: boolean;
                    questionId: string;
                }): Promise<void>;
                likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, like }: {
                    questionId: string;
                    like: boolean;
                }): Promise<void>;
                reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, report }: {
                    questionId: string;
                    report: boolean;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                archiveBoard({ questionsTables }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { board }: {
                    board: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
        };
    }>;
    authMediator: {
        subscribeToAccessChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../features/auth/mediator/types/access-event-listener.js").AccessEventListener>;
        subscribeToTokenChange: import("../../../../toolbox/pubsub.js").Subscribe<() => void>;
        initialize(): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        getAccess(): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        getAccessToken(): Promise<string>;
        login(tokens: import("../../../../features/auth/types/tokens/auth-token.js").AuthTokens): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        logout(): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        reauthorize(): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
    };
    backend: {
        api: {
            auth: {
                greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, {
                    authorize({ bakeTables }: import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                        scope: import("../../../../features/auth/types/tokens/scope.js").Scope;
                        appId: string;
                        refreshToken?: string;
                    }): Promise<string>;
                }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                    sendLoginLink({ access, tables }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { email }: {
                        email: string;
                    }): Promise<void>;
                    authenticateViaLoginToken({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                        loginToken: string;
                    }): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                        accessToken: Promise<string>;
                        refreshToken: Promise<string>;
                    }>>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, {
                    listApps({ tables, statsHub }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                        ownerUserId: string;
                    }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                    registerApp({ tables }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                        appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                        ownerUserId: string;
                    }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                    updateApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                        appId: string;
                        appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                    }): Promise<void>;
                    deleteApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                        appId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                    listAdmins(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                        appId: string;
                    }): Promise<import("../../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                    assignPlatformUserAsAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                        appId: string;
                        platformUserId: string;
                    }): Promise<void>;
                    assignAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                        appId: string;
                        email: string;
                    }): Promise<void>;
                    revokeAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                        appId: string;
                        userId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    setProfile({ access, tables, checker }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                        userId: string;
                        profileDraft: import("../../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                    getUser({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { userId }: {
                        userId: string;
                    }): Promise<{
                        userId: string;
                        profile: import("../../../../features/auth/types/profile.js").Profile;
                        roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                    }>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                        roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                        privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                        rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                    }>>;
                    createRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { label }: {
                        label: string;
                    }): Promise<void>;
                    deleteRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId }: {
                        roleId: string;
                    }): Promise<void>;
                    assignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    unassignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            };
            administrative: {
                roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                        roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                        privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                        rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                    }>>;
                    searchUsers({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        term: string;
                    }): Promise<{
                        user: {
                            userId: string;
                            profile: import("../../../../features/auth/types/profile.js").Profile;
                            roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                            stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                        };
                        roleIds: string[];
                    }[]>;
                    assignRoleToUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        roleId: string;
                        userId: string;
                        isPublic: boolean;
                        timeframeEnd: number;
                        timeframeStart: number;
                    }): Promise<void>;
                    revokeRoleFromUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        roleId: string;
                        userId: string;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth>;
                }>;
            };
            questions: {
                questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    fetchQuestions({ questionsTables, tables, access }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { board }: {
                        board: string;
                    }): Promise<{
                        questions: any[];
                        users: any[];
                    }>;
                }, {
                    processAuth: (meta: import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                        questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
                questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    postQuestion({ questionsTables, access, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionDraft }: {
                        questionDraft: import("../../../../features/questions/api/types/question-draft.js").QuestionDraft;
                    }): Promise<import("../../../../features/questions/api/types/question.js").Question>;
                    archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                        archive: boolean;
                        questionId: string;
                    }): Promise<void>;
                    likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, like }: {
                        questionId: string;
                        like: boolean;
                    }): Promise<void>;
                    reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, report }: {
                        questionId: string;
                        report: boolean;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                        questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
                questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    archiveBoard({ questionsTables }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { board }: {
                        board: string;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                        questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
            };
        };
        config: import("../../../backend/types/secret-config.js").SecretConfig;
        emails: {
            sendEmail: import("../../../../features/auth/types/emails/send-email.js").SendEmail;
            enableEmails: () => void;
            disableEmails: () => void;
            sendLoginEmail: (details: import("../../../../features/auth/types/emails/login-email-details.js").LoginEmailDetails) => Promise<void>;
            recallLatestLoginEmail: () => import("../../../../features/auth/types/emails/login-email-details.js").LoginEmailDetails;
        };
        database: import("../../../backend/types/database.js").Database;
        stripeComplex: {
            stripeLiaisonForPlatform: {
                accounts: {
                    create(params: import("stripe").Stripe.AccountCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Account>>;
                };
                accountLinks: {
                    create(params: import("stripe").Stripe.AccountLinkCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.AccountLink>>;
                };
            };
            connectStripeLiaisonForApp(stripeConnectAccountId: string): {
                customers: {
                    create(params: import("stripe").Stripe.CustomerCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer | import("stripe").Stripe.DeletedCustomer>>;
                    update(id: string, params: import("stripe").Stripe.CustomerUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Customer>>;
                };
                products: {
                    create(params: import("stripe").Stripe.ProductCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                    update(id: string, params: import("stripe").Stripe.ProductUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Product>>;
                };
                prices: {
                    create(params: import("stripe").Stripe.PriceCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                    update(id: string, params: import("stripe").Stripe.PriceUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Price>>;
                };
                paymentMethods: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.PaymentMethod>>;
                };
                setupIntents: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.SetupIntent>>;
                };
                subscriptions: {
                    retrieve(id: string): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
                    update(id: string, params: import("stripe").Stripe.SubscriptionUpdateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Subscription>>;
                };
                checkout: {
                    sessions: {
                        create(params: import("stripe").Stripe.Checkout.SessionCreateParams): Promise<import("stripe").Stripe.Response<import("stripe").Stripe.Checkout.Session>>;
                    };
                };
            };
        };
        mockStripeOperations: {
            linkBankWithExistingStripeAccount: (stripeAccountId: string) => Promise<void>;
        };
        platformAppId: string;
        mockBrowser: () => Promise<{
            mockAppWindow: ({ appId, apiLink, latency, windowLink, }: {
                appId: string;
                apiLink: string;
                windowLink: string;
                latency: MockLatency;
            }) => Promise<{
                models: {
                    appModel: {
                        readonly state: {
                            active: boolean;
                            appRecords: import("../../../../framework/ops.js").Op<import("../../../../features/auth/models/types/app/app-records.js").AppRecords>;
                            addingNewApp: import("../../../../framework/ops.js").Op<null>;
                        };
                        getApp(appId: string): import("../../../../features/auth/types/apps/app-display.js").AppDisplay;
                        onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
                        loadApps: () => Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                        deleteApp: (appId: string) => Promise<void>;
                        updateApp: (appId: string, appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft) => Promise<void>;
                        registerApp: (appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft) => Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay>;
                        manageAdminsService: import("renraku/x/types/primitives/business").Business<{
                            listAdmins(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                                appId: string;
                            }): Promise<import("../../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                            assignPlatformUserAsAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                                appId: string;
                                platformUserId: string;
                            }): Promise<void>;
                            assignAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                                appId: string;
                                email: string;
                            }): Promise<void>;
                            revokeAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                                appId: string;
                                userId: string;
                            }): Promise<void>;
                        }>;
                        accessChange(): Promise<void>;
                    };
                    authModel: {
                        track: <X>(stakeout: import("../../../../toolbox/autowatcher/types/autowatcher-types.js").Stakeout<X>) => () => void;
                        readonly access: import("../../../../framework/ops.js").Op<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
                        onAccessChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../features/auth/mediator/types/access-event-listener.js").AccessEventListener>;
                        getValidAccess(): Promise<import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
                        useExistingLogin(): Promise<void>;
                        sendLoginLink(email: string): Promise<void>;
                        login(loginToken: string): Promise<void>;
                        logout(): Promise<void>;
                        reauthorize(): Promise<void>;
                    };
                    personalModel: {
                        readonly submitDraftOp: import("../../../../framework/ops.js").Op<void>;
                        saveProfile(profileDraft: import("../../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
                    };
                    questionsModel: {
                        onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
                        makeBoardModel: (board: string) => {
                            getPermissions(): {
                                "read questions": boolean;
                                "post questions": boolean;
                                "moderate questions": boolean;
                            };
                            getBoardName(): string;
                            getAccess(): import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                            getBoardOp(): import("../../../../framework/ops.js").Op<void>;
                            getPostingOp(): import("../../../../framework/ops.js").Op<void>;
                            getQuestions(): import("../../../../features/questions/api/types/question.js").Question[];
                            getUser(userId: string): import("../../../../features/auth/types/user.js").User;
                            loadQuestions(): Promise<void>;
                            postQuestion(questionDraft: import("../../../../features/questions/api/types/question-draft.js").QuestionDraft): Promise<void>;
                            likeQuestion(questionId: string, like: boolean): Promise<void>;
                            reportQuestion(questionId: string, report: boolean): Promise<void>;
                            archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                            archiveBoard(): Promise<void>;
                        };
                        accessChange: (access: import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload) => void;
                    };
                    permissionsModel: {
                        onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
                        getState: () => {
                            active: boolean;
                            access: import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                            permissionsDisplay: import("../../../../framework/ops.js").Op<import("../../../../features/auth/topics/permissions/types/permissions-display.js").PermissionsDisplay>;
                        };
                        initialize: () => Promise<void>;
                        getUserCanCustomizePermissions: () => boolean;
                        createRole: (args_0: {
                            label: string;
                        }) => Promise<void>;
                        deleteRole: (args_0: {
                            roleId: string;
                        }) => Promise<void>;
                        assignPrivilege: (args_0: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        unassignPrivilege: (args_0: {
                            roleId: string;
                            privilegeId: string;
                        }) => Promise<void>;
                        accessChange(access: import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload): Promise<void>;
                    };
                    administrativeModel: {
                        getState: () => {
                            access: import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                            permissionsOp: import("../../../../framework/ops.js").Op<import("../../../../features/auth/topics/permissions/types/permissions-display.js").PermissionsDisplay>;
                        };
                        onStateChange: import("../../../../toolbox/pubsub.js").Subscribe<import("../../../../toolbox/pubsub.js").AnyListener>;
                        initialize: () => Promise<void>;
                        readonly isAllowed: (privilege: "read questions" | "post questions" | "like questions" | "report questions" | "edit any profile" | "customize permissions" | "moderate questions" | "view stats" | "administrate user roles" | "banned" | "manage store" | "give away freebies") => boolean;
                        accessChange: (access: import("../../../../features/auth/types/tokens/access-payload.js").AccessPayload) => void;
                        reauthorize: () => Promise<void>;
                        searchUsers: (args_0: {
                            term: string;
                        }) => Promise<{
                            user: {
                                userId: string;
                                profile: import("../../../../features/auth/types/profile.js").Profile;
                                roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                                stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                            };
                            roleIds: string[];
                        }[]>;
                        assignRoleToUser: (args_0: {
                            roleId: string;
                            userId: string;
                            isPublic: boolean;
                            timeframeEnd: number;
                            timeframeStart: number;
                        }) => Promise<void>;
                        revokeRoleFromUser: (args_0: {
                            roleId: string;
                            userId: string;
                        }) => Promise<void>;
                    };
                };
                remote: import("renraku/x/types/remote/to-remote").ToRemote<{
                    auth: {
                        greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, {
                            authorize({ bakeTables }: import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                                scope: import("../../../../features/auth/types/tokens/scope.js").Scope;
                                appId: string;
                                refreshToken?: string;
                            }): Promise<string>;
                        }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../../../features/auth/policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                            sendLoginLink({ access, tables }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { email }: {
                                email: string;
                            }): Promise<void>;
                            authenticateViaLoginToken({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                                loginToken: string;
                            }): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                                accessToken: Promise<string>;
                                refreshToken: Promise<string>;
                            }>>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, {
                            listApps({ tables, statsHub }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                                ownerUserId: string;
                            }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                            registerApp({ tables }: import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                                appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                                ownerUserId: string;
                            }): Promise<import("../../../../features/auth/types/apps/app-display.js").AppDisplay>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                            updateApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                                appId: string;
                                appDraft: import("../../../../features/auth/types/apps/app-draft.js").AppDraft;
                            }): Promise<void>;
                            deleteApp({ tables, access }: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                                appId: string;
                            }): Promise<void>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                            listAdmins(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                                appId: string;
                            }): Promise<import("../../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                            assignPlatformUserAsAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                                appId: string;
                                platformUserId: string;
                            }): Promise<void>;
                            assignAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                                appId: string;
                                email: string;
                            }): Promise<void>;
                            revokeAdmin(auth: import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                                appId: string;
                                userId: string;
                            }): Promise<void>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                            setProfile({ access, tables, checker }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                                userId: string;
                                profileDraft: import("../../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft;
                            }): Promise<void>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                            getUser({ tables, access }: import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { userId }: {
                                userId: string;
                            }): Promise<{
                                userId: string;
                                profile: import("../../../../features/auth/types/profile.js").Profile;
                                roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                                stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                            }>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                        permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                            fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                                roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                                privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                                rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                            }>>;
                            createRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { label }: {
                                label: string;
                            }): Promise<void>;
                            deleteRole({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId }: {
                                roleId: string;
                            }): Promise<void>;
                            assignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                                roleId: string;
                                privilegeId: string;
                            }): Promise<void>;
                            unassignPrivilege({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                                roleId: string;
                                privilegeId: string;
                            }): Promise<void>;
                        }, import("renraku/x/types/primitives/policy").Policy<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                    };
                    administrative: {
                        roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth, {
                            fetchPermissions({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../../toolbox/concurrent.js").AwaitProps<{
                                roles: Promise<import("../../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                                privileges: Promise<import("../../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                                rolesHavePrivileges: Promise<import("../../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                            }>>;
                            searchUsers({ tables, access }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                                term: string;
                            }): Promise<{
                                user: {
                                    userId: string;
                                    profile: import("../../../../features/auth/types/profile.js").Profile;
                                    roles: import("../../../../features/auth/types/public-user-role.js").PublicUserRole[];
                                    stats: import("../../../../features/auth/types/user-stats.js").UserStats;
                                };
                                roleIds: string[];
                            }[]>;
                            assignRoleToUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                                roleId: string;
                                userId: string;
                                isPublic: boolean;
                                timeframeEnd: number;
                                timeframeStart: number;
                            }): Promise<void>;
                            revokeRoleFromUser({ tables }: import("../../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                                roleId: string;
                                userId: string;
                            }): Promise<void>;
                        }, {
                            processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth>;
                        }>;
                    };
                    questions: {
                        questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                            questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                        }, {
                            fetchQuestions({ questionsTables, tables, access }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth, { board }: {
                                board: string;
                            }): Promise<{
                                questions: any[];
                                users: any[];
                            }>;
                        }, {
                            processAuth: (meta: import("../../../../features/auth/policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                            }>;
                        }>;
                        questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                            questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                        }, {
                            postQuestion({ questionsTables, access, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionDraft }: {
                                questionDraft: import("../../../../features/questions/api/types/question-draft.js").QuestionDraft;
                            }): Promise<import("../../../../features/questions/api/types/question.js").Question>;
                            archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                                archive: boolean;
                                questionId: string;
                            }): Promise<void>;
                            likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, like }: {
                                questionId: string;
                                like: boolean;
                            }): Promise<void>;
                            reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, report }: {
                                questionId: string;
                                report: boolean;
                            }): Promise<void>;
                        }, {
                            processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                            }>;
                        }>;
                        questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                            questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                        }, {
                            archiveBoard({ questionsTables }: import("../../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../../features/auth/policies/types/user-auth.js").UserAuth, { board }: {
                                board: string;
                            }): Promise<void>;
                        }, {
                            processAuth: (meta: import("../../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../../features/auth/policies/types/user-auth.js").UserAuth & {
                                questionsTables: import("../../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                            }>;
                        }>;
                    };
                }>;
                nextModalResults: {
                    confirm: boolean;
                    prompt: {
                        value: any;
                    };
                };
            }>;
        }>;
    };
    popups: {
        triggerBankPopup: import("../../../../features/store/model/shares/types/trigger-bank-popup.js").TriggerBankPopup;
    };
}>;
