import { XiomeConfigConnected } from "../types/xiome-config-connected.js";
export declare function connect({ appId, apiOrigin, platformOrigin }: XiomeConfigConnected): Promise<{
    appId: string;
    remote: import("renraku/x/types/remote/to-remote").ToRemote<{
        auth: {
            greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../../features/auth/policies/types/green-auth.js").GreenAuth, {
                authorize({ bakeTables }: import("../../../features/auth/policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                    scope: import("../../../features/auth/types/tokens/scope.js").Scope;
                    appId: string;
                    refreshToken?: string;
                }): Promise<string>;
            }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../../features/auth/policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                sendLoginLink({ access, tables }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { email }: {
                    email: string;
                }): Promise<void>;
                authenticateViaLoginToken({ tables, access }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                    loginToken: string;
                }): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                    accessToken: Promise<string>;
                    refreshToken: Promise<string>;
                }>>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, {
                listApps({ tables, statsHub }: import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                    ownerUserId: string;
                }): Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                registerApp({ tables }: import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                    appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft;
                    ownerUserId: string;
                }): Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                updateApp({ tables, access }: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                    appId: string;
                    appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft;
                }): Promise<void>;
                deleteApp({ tables, access }: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                listAdmins(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                    appId: string;
                }): Promise<import("../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                assignPlatformUserAsAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                    appId: string;
                    platformUserId: string;
                }): Promise<void>;
                assignAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                    appId: string;
                    email: string;
                }): Promise<void>;
                revokeAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                    appId: string;
                    userId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                setProfile({ access, tables, checker }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                    userId: string;
                    profileDraft: import("../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                getUser({ tables, access }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { userId }: {
                    userId: string;
                }): Promise<{
                    userId: string;
                    profile: import("../../../features/auth/types/profile.js").Profile;
                    roles: import("../../../features/auth/types/public-user-role.js").PublicUserRole[];
                    stats: import("../../../features/auth/types/user-stats.js").UserStats;
                }>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                createRole({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { label }: {
                    label: string;
                }): Promise<void>;
                deleteRole({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId }: {
                    roleId: string;
                }): Promise<void>;
                assignPrivilege({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
                unassignPrivilege({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                    roleId: string;
                    privilegeId: string;
                }): Promise<void>;
            }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
        };
        administrative: {
            roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                fetchPermissions({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                    roles: Promise<import("../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                    privileges: Promise<import("../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                    rolesHavePrivileges: Promise<import("../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                }>>;
                searchUsers({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    term: string;
                }): Promise<{
                    user: {
                        userId: string;
                        profile: import("../../../features/auth/types/profile.js").Profile;
                        roles: import("../../../features/auth/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../../features/auth/types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }): Promise<void>;
                revokeRoleFromUser({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                    roleId: string;
                    userId: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth>;
            }>;
        };
        questions: {
            questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                fetchQuestions({ questionsTables, tables, access }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { board }: {
                    board: string;
                }): Promise<{
                    questions: any[];
                    users: any[];
                }>;
            }, {
                processAuth: (meta: import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                postQuestion({ questionsTables, access, checker }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionDraft }: {
                    questionDraft: import("../../../features/questions/api/types/question-draft.js").QuestionDraft;
                }): Promise<import("../../../features/questions/api/types/question.js").Question>;
                archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                    archive: boolean;
                    questionId: string;
                }): Promise<void>;
                likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, like }: {
                    questionId: string;
                    like: boolean;
                }): Promise<void>;
                reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, report }: {
                    questionId: string;
                    report: boolean;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
            questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
            }, {
                archiveBoard({ questionsTables }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { board }: {
                    board: string;
                }): Promise<void>;
            }, {
                processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }>;
            }>;
        };
    }>;
    authMediator: {
        subscribeToAccessChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../features/auth/mediator/types/access-event-listener.js").AccessEventListener>;
        subscribeToTokenChange: import("../../../toolbox/pubsub.js").Subscribe<() => void>;
        initialize(): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        getAccess(): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        getAccessToken(): Promise<string>;
        login(tokens: import("../../../features/auth/types/tokens/auth-token.js").AuthTokens): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        logout(): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
        reauthorize(): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
    };
    popups: {
        triggerBankPopup: import("../../../features/store/model/shares/types/trigger-bank-popup.js").TriggerBankPopup;
    };
}>;
