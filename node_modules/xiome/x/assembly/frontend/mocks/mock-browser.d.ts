import { SystemApi } from "../../backend/types/system-api.js";
import { MockLatency } from "../../../framework/add-mock-latency.js";
import { MockStripeOperations } from "../../../features/store/stripe2/types/mock-stripe-operations.js";
export declare function mockBrowser({ api, mockStripeOperations }: {
    api: SystemApi;
    mockStripeOperations: MockStripeOperations;
}): Promise<{
    mockAppWindow: ({ appId, apiLink, latency, windowLink, }: {
        appId: string;
        apiLink: string;
        windowLink: string;
        latency: MockLatency;
    }) => Promise<{
        models: {
            appModel: {
                readonly state: {
                    active: boolean;
                    appRecords: import("../../../framework/ops.js").Op<import("../../../features/auth/models/types/app/app-records.js").AppRecords>;
                    addingNewApp: import("../../../framework/ops.js").Op<null>;
                };
                getApp(appId: string): import("../../../features/auth/types/apps/app-display.js").AppDisplay;
                onStateChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../toolbox/pubsub.js").AnyListener>;
                loadApps: () => Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                deleteApp: (appId: string) => Promise<void>;
                updateApp: (appId: string, appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft) => Promise<void>;
                registerApp: (appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft) => Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay>;
                manageAdminsService: import("renraku/x/types/primitives/business").Business<{
                    listAdmins(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                        appId: string;
                    }): Promise<import("../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                    assignPlatformUserAsAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                        appId: string;
                        platformUserId: string;
                    }): Promise<void>;
                    assignAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                        appId: string;
                        email: string;
                    }): Promise<void>;
                    revokeAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                        appId: string;
                        userId: string;
                    }): Promise<void>;
                }>;
                accessChange(): Promise<void>;
            };
            authModel: {
                track: <X>(stakeout: import("../../../toolbox/autowatcher/types/autowatcher-types.js").Stakeout<X>) => () => void;
                readonly access: import("../../../framework/ops.js").Op<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
                onAccessChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../features/auth/mediator/types/access-event-listener.js").AccessEventListener>;
                getValidAccess(): Promise<import("../../../features/auth/types/tokens/access-payload.js").AccessPayload>;
                useExistingLogin(): Promise<void>;
                sendLoginLink(email: string): Promise<void>;
                login(loginToken: string): Promise<void>;
                logout(): Promise<void>;
                reauthorize(): Promise<void>;
            };
            personalModel: {
                readonly submitDraftOp: import("../../../framework/ops.js").Op<void>;
                saveProfile(profileDraft: import("../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft): Promise<void>;
            };
            questionsModel: {
                onStateChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../toolbox/pubsub.js").AnyListener>;
                makeBoardModel: (board: string) => {
                    getPermissions(): {
                        "read questions": boolean;
                        "post questions": boolean;
                        "moderate questions": boolean;
                    };
                    getBoardName(): string;
                    getAccess(): import("../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                    getBoardOp(): import("../../../framework/ops.js").Op<void>;
                    getPostingOp(): import("../../../framework/ops.js").Op<void>;
                    getQuestions(): import("../../../features/questions/api/types/question.js").Question[];
                    getUser(userId: string): import("../../../features/auth/types/user.js").User;
                    loadQuestions(): Promise<void>;
                    postQuestion(questionDraft: import("../../../features/questions/api/types/question-draft.js").QuestionDraft): Promise<void>;
                    likeQuestion(questionId: string, like: boolean): Promise<void>;
                    reportQuestion(questionId: string, report: boolean): Promise<void>;
                    archiveQuestion(questionId: string, archive: boolean): Promise<void>;
                    archiveBoard(): Promise<void>;
                };
                accessChange: (access: import("../../../features/auth/types/tokens/access-payload.js").AccessPayload) => void;
            };
            permissionsModel: {
                onStateChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../toolbox/pubsub.js").AnyListener>;
                getState: () => {
                    active: boolean;
                    access: import("../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                    permissionsDisplay: import("../../../framework/ops.js").Op<import("../../../features/auth/topics/permissions/types/permissions-display.js").PermissionsDisplay>;
                };
                initialize: () => Promise<void>;
                getUserCanCustomizePermissions: () => boolean;
                createRole: (args_0: {
                    label: string;
                }) => Promise<void>;
                deleteRole: (args_0: {
                    roleId: string;
                }) => Promise<void>;
                assignPrivilege: (args_0: {
                    roleId: string;
                    privilegeId: string;
                }) => Promise<void>;
                unassignPrivilege: (args_0: {
                    roleId: string;
                    privilegeId: string;
                }) => Promise<void>;
                accessChange(access: import("../../../features/auth/types/tokens/access-payload.js").AccessPayload): Promise<void>;
            };
            administrativeModel: {
                getState: () => {
                    access: import("../../../features/auth/types/tokens/access-payload.js").AccessPayload;
                    permissionsOp: import("../../../framework/ops.js").Op<import("../../../features/auth/topics/permissions/types/permissions-display.js").PermissionsDisplay>;
                };
                onStateChange: import("../../../toolbox/pubsub.js").Subscribe<import("../../../toolbox/pubsub.js").AnyListener>;
                initialize: () => Promise<void>;
                readonly isAllowed: (privilege: "read questions" | "post questions" | "like questions" | "report questions" | "edit any profile" | "customize permissions" | "moderate questions" | "view stats" | "administrate user roles" | "banned" | "manage store" | "give away freebies") => boolean;
                accessChange: (access: import("../../../features/auth/types/tokens/access-payload.js").AccessPayload) => void;
                reauthorize: () => Promise<void>;
                searchUsers: (args_0: {
                    term: string;
                }) => Promise<{
                    user: {
                        userId: string;
                        profile: import("../../../features/auth/types/profile.js").Profile;
                        roles: import("../../../features/auth/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../../features/auth/types/user-stats.js").UserStats;
                    };
                    roleIds: string[];
                }[]>;
                assignRoleToUser: (args_0: {
                    roleId: string;
                    userId: string;
                    isPublic: boolean;
                    timeframeEnd: number;
                    timeframeStart: number;
                }) => Promise<void>;
                revokeRoleFromUser: (args_0: {
                    roleId: string;
                    userId: string;
                }) => Promise<void>;
            };
        };
        remote: import("renraku/x/types/remote/to-remote").ToRemote<{
            auth: {
                greenService: import("renraku/x/types/api/to-api-context").ToApiContext<undefined, import("../../../features/auth/policies/types/green-auth.js").GreenAuth, {
                    authorize({ bakeTables }: import("../../../features/auth/policies/types/green-auth.js").GreenAuth, { appId, scope, refreshToken }: {
                        scope: import("../../../features/auth/types/tokens/scope.js").Scope;
                        appId: string;
                        refreshToken?: string;
                    }): Promise<string>;
                }, import("renraku/x/types/primitives/policy").Policy<undefined, import("../../../features/auth/policies/types/green-auth.js").GreenAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                loginService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                    sendLoginLink({ access, tables }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { email }: {
                        email: string;
                    }): Promise<void>;
                    authenticateViaLoginToken({ tables, access }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { loginToken }: {
                        loginToken: string;
                    }): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                        accessToken: Promise<string>;
                        refreshToken: Promise<string>;
                    }>>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                appService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, {
                    listApps({ tables, statsHub }: import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { ownerUserId }: {
                        ownerUserId: string;
                    }): Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay[]>;
                    registerApp({ tables }: import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, { appDraft, ownerUserId }: {
                        appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft;
                        ownerUserId: string;
                    }): Promise<import("../../../features/auth/types/apps/app-display.js").AppDisplay>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/platform-user-meta.js").PlatformUserMeta, import("../../../features/auth/policies/types/platform-user-auth.js").PlatformUserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                appEditService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                    updateApp({ tables, access }: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, appDraft }: {
                        appId: string;
                        appDraft: import("../../../features/auth/types/apps/app-draft.js").AppDraft;
                    }): Promise<void>;
                    deleteApp({ tables, access }: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                        appId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                manageAdminsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, {
                    listAdmins(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId }: {
                        appId: string;
                    }): Promise<import("../../../features/auth/types/manage-admins/admin-email-display.js").AdminEmailDisplay[]>;
                    assignPlatformUserAsAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, platformUserId }: {
                        appId: string;
                        platformUserId: string;
                    }): Promise<void>;
                    assignAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, email }: {
                        appId: string;
                        email: string;
                    }): Promise<void>;
                    revokeAdmin(auth: import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, { appId, userId }: {
                        appId: string;
                        userId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/app-owner-meta.js").AppOwnerMeta, import("../../../features/auth/policies/types/app-owner-auth.js").AppOwnerAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                personalService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    setProfile({ access, tables, checker }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { userId, profileDraft }: {
                        userId: string;
                        profileDraft: import("../../../features/auth/topics/personal/types/profile-draft.js").ProfileDraft;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                userService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, {
                    getUser({ tables, access }: import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { userId }: {
                        userId: string;
                    }): Promise<{
                        userId: string;
                        profile: import("../../../features/auth/types/profile.js").Profile;
                        roles: import("../../../features/auth/types/public-user-role.js").PublicUserRole[];
                        stats: import("../../../features/auth/types/user-stats.js").UserStats;
                    }>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
                permissionsService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    fetchPermissions({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                        roles: Promise<import("../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                        privileges: Promise<import("../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                        rolesHavePrivileges: Promise<import("../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                    }>>;
                    createRole({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { label }: {
                        label: string;
                    }): Promise<void>;
                    deleteRole({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId }: {
                        roleId: string;
                    }): Promise<void>;
                    assignPrivilege({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                    unassignPrivilege({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, { roleId, privilegeId }: {
                        roleId: string;
                        privilegeId: string;
                    }): Promise<void>;
                }, import("renraku/x/types/primitives/policy").Policy<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, import("renraku/x/types/http/http-request").HttpRequest>>;
            };
            administrative: {
                roleAssignmentService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth, {
                    fetchPermissions({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth): Promise<import("../../../toolbox/concurrent.js").AwaitProps<{
                        roles: Promise<import("../../../features/auth/tables/types/rows/role-row.js").RoleRow[]>;
                        privileges: Promise<import("../../../features/auth/tables/types/rows/privilege-row.js").PrivilegeRow[]>;
                        rolesHavePrivileges: Promise<import("../../../features/auth/tables/types/rows/role-has-privilege-row.js").RoleHasPrivilegeRow[]>;
                    }>>;
                    searchUsers({ tables, access }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        term: string;
                    }): Promise<{
                        user: {
                            userId: string;
                            profile: import("../../../features/auth/types/profile.js").Profile;
                            roles: import("../../../features/auth/types/public-user-role.js").PublicUserRole[];
                            stats: import("../../../features/auth/types/user-stats.js").UserStats;
                        };
                        roleIds: string[];
                    }[]>;
                    assignRoleToUser({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        roleId: string;
                        userId: string;
                        isPublic: boolean;
                        timeframeEnd: number;
                        timeframeStart: number;
                    }): Promise<void>;
                    revokeRoleFromUser({ tables }: import("../../../features/auth/policies/types/user-auth.js").UserAuth, options: {
                        roleId: string;
                        userId: string;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth>;
                }>;
            };
            questions: {
                questionsReadingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, import("../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    fetchQuestions({ questionsTables, tables, access }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/anon-auth.js").AnonAuth, { board }: {
                        board: string;
                    }): Promise<{
                        questions: any[];
                        users: any[];
                    }>;
                }, {
                    processAuth: (meta: import("../../../features/auth/policies/types/anon-meta.js").AnonMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/anon-auth.js").AnonAuth & {
                        questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
                questionsPostingService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    postQuestion({ questionsTables, access, checker }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionDraft }: {
                        questionDraft: import("../../../features/questions/api/types/question-draft.js").QuestionDraft;
                    }): Promise<import("../../../features/questions/api/types/question.js").Question>;
                    archiveQuestion({ access: { user: { userId } }, questionsTables, checker }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, archive }: {
                        archive: boolean;
                        questionId: string;
                    }): Promise<void>;
                    likeQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, like }: {
                        questionId: string;
                        like: boolean;
                    }): Promise<void>;
                    reportQuestion({ questionsTables, checker, access: { user: { userId } } }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { questionId, report }: {
                        questionId: string;
                        report: boolean;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                        questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
                questionsModerationService: import("renraku/x/types/api/to-api-context").ToApiContext<import("../../../features/auth/policies/types/user-meta.js").UserMeta, import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                    questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                }, {
                    archiveBoard({ questionsTables }: import("../../../features/questions/api/types/questions-auth-parts.js").QuestionsAuthParts & import("../../../features/auth/policies/types/user-auth.js").UserAuth, { board }: {
                        board: string;
                    }): Promise<void>;
                }, {
                    processAuth: (meta: import("../../../features/auth/policies/types/user-meta.js").UserMeta, request: import("renraku/x/types/http/http-request").HttpRequest) => Promise<import("../../../features/auth/policies/types/user-auth.js").UserAuth & {
                        questionsTables: import("../../../features/questions/api/tables/types/questions-tables.js").QuestionsTables;
                    }>;
                }>;
            };
        }>;
        nextModalResults: {
            confirm: boolean;
            prompt: {
                value: any;
            };
        };
    }>;
}>;
