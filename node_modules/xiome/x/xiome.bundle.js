(function () {
    'use strict';

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * True if the custom elements polyfill is in use.
     */
    const isCEPolyfill = typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !==
            undefined;
    /**
     * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
     * into another container (could be the same container), before `before`. If
     * `before` is null, it appends the nodes to the container.
     */
    const reparentNodes = (container, start, end = null, before = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.insertBefore(start, before);
            start = n;
        }
    };
    /**
     * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
     * `container`.
     */
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, multi-binding attributes, and
     * attributes with markup-like text values.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * Suffix appended to all bound attribute names.
     */
    const boundAttributeSuffix = '$lit$';
    /**
     * An updatable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            // Keeps track of the last index associated with a part. We try to delete
            // unnecessary nodes, but we never want to associate two different parts
            // to the same index. They must have a constant node between.
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const { strings, values: { length } } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length } = attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondence between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < length; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // All bound attributes have had a suffix added in
                            // TemplateResult#getHTML to opt out of special attribute
                            // handling. To look up the attribute value we also need to add
                            // the suffix.
                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings = data.split(markerRegex);
                        const lastIndex = strings.length - 1;
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings[i];
                            if (s === '') {
                                insert = createMarker();
                            }
                            else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s = s.slice(0, match.index) + match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        // If there's no text, we must insert a comment to mark our place.
                        // Else, we can trust it will stick around after cloning.
                        if (strings[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        }
                        else {
                            node.data = strings[lastIndex];
                        }
                        // We have a part for each match found
                        partIndex += lastIndex;
                    }
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * The previousSibling is already the start of a previous part
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        // If we don't have a nextSibling, keep this node so we have an end.
                        // Else, we can remove it to save future costs.
                        if (node.nextSibling === null) {
                            node.data = '';
                        }
                        else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    // Allows `document.createComment('')` to be renamed for a
    // small manual size-savings.
    const createMarker = () => document.createComment('');
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#elements-attributes
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-characters
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
     * space character except " ".
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex = 
    // eslint-disable-next-line no-control-regex
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
    /**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */
    function removeNodesFromTemplate(template, nodesToRemove) {
        const { element: { content }, parts } = template;
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let part = parts[partIndex];
        let nodeIndex = -1;
        let removeCount = 0;
        const nodesToRemoveInTemplate = [];
        let currentRemovingNode = null;
        while (walker.nextNode()) {
            nodeIndex++;
            const node = walker.currentNode;
            // End removal if stepped past the removing node
            if (node.previousSibling === currentRemovingNode) {
                currentRemovingNode = null;
            }
            // A node to remove was found in the template
            if (nodesToRemove.has(node)) {
                nodesToRemoveInTemplate.push(node);
                // Track node we're removing
                if (currentRemovingNode === null) {
                    currentRemovingNode = node;
                }
            }
            // When removing, increment count by which to adjust subsequent part indices
            if (currentRemovingNode !== null) {
                removeCount++;
            }
            while (part !== undefined && part.index === nodeIndex) {
                // If part is in a removed node deactivate it by setting index to -1 or
                // adjust the index as needed.
                part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
                // go to the next active part.
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                part = parts[partIndex];
            }
        }
        nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
    }
    const countNodes = (node) => {
        let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
        const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
        while (walker.nextNode()) {
            count++;
        }
        return count;
    };
    const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
        for (let i = startIndex + 1; i < parts.length; i++) {
            const part = parts[i];
            if (isTemplatePartActive(part)) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */
    function insertNodeIntoTemplate(template, node, refNode = null) {
        const { element: { content }, parts } = template;
        // If there's no refNode, then put node at end of template.
        // No part indices need to be shifted in this case.
        if (refNode === null || refNode === undefined) {
            content.appendChild(node);
            return;
        }
        const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
        let partIndex = nextActiveIndexInTemplateParts(parts);
        let insertCount = 0;
        let walkerIndex = -1;
        while (walker.nextNode()) {
            walkerIndex++;
            const walkerNode = walker.currentNode;
            if (walkerNode === refNode) {
                insertCount = countNodes(node);
                refNode.parentNode.insertBefore(node, refNode);
            }
            while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
                // If we've inserted the node, simply adjust all subsequent parts
                if (insertCount > 0) {
                    while (partIndex !== -1) {
                        parts[partIndex].index += insertCount;
                        partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                    }
                    return;
                }
                partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            }
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    /**
     * A sentinel value that signals a NodePart to fully clear its content.
     */
    const nothing = {};

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.commit();
                }
            }
        }
        _clone() {
            // There are a number of steps in the lifecycle of a template instance's
            // DOM fragment:
            //  1. Clone - create the instance fragment
            //  2. Adopt - adopt into the main document
            //  3. Process - find part markers and create parts
            //  4. Upgrade - upgrade custom elements
            //  5. Update - set node, attribute, property, etc., values
            //  6. Connect - connect to the document. Optional and outside of this
            //     method.
            //
            // We have a few constraints on the ordering of these steps:
            //  * We need to upgrade before updating, so that property values will pass
            //    through any property setters.
            //  * We would like to process before upgrading so that we're sure that the
            //    cloned fragment is inert and not disturbed by self-modifying DOM.
            //  * We want custom elements to upgrade even in disconnected fragments.
            //
            // Given these constraints, with full custom elements support we would
            // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
            //
            // But Safari does not implement CustomElementRegistry#upgrade, so we
            // can not implement that order and still have upgrade-before-update and
            // upgrade disconnected fragments. So we instead sacrifice the
            // process-before-upgrade constraint, since in Custom Elements v1 elements
            // must not modify their light DOM in the constructor. We still have issues
            // when co-existing with CEv0 elements like Polymer 1, and with polyfills
            // that don't strictly adhere to the no-modification rule because shadow
            // DOM, which may be created in the constructor, is emulated by being placed
            // in the light DOM.
            //
            // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
            // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
            // in one step.
            //
            // The Custom Elements v1 polyfill supports upgrade(), so the order when
            // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
            // Connect.
            const fragment = isCEPolyfill ?
                this.template.element.content.cloneNode(true) :
                document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(undefined);
                    partIndex++;
                    continue;
                }
                // Progress the tree walker until we find our next part's node.
                // Note that multiple parts may share the same node (attribute parts
                // on a single element), so this loop may not run at all.
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        // We've exhausted the content inside a nested template element.
                        // Because we still have parts (the outer for-loop), we know:
                        // - There is a template in the stack
                        // - The walker will find a nextNode outside the template
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                // We've arrived at our part's node.
                if (part.type === 'node') {
                    const part = this.processor.handleTextExpression(this.options);
                    part.insertAfterNode(node.previousSibling);
                    this.__parts.push(part);
                }
                else {
                    this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Our TrustedTypePolicy for HTML which is declared using the html template
     * tag function.
     *
     * That HTML is a developer-authored constant, and is parsed with innerHTML
     * before any untrusted expressions have been mixed in. Therefor it is
     * considered safe by construction.
     */
    const policy = window.trustedTypes &&
        trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        /**
         * Returns a string of HTML used to create a `<template>` element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                // For each binding we want to determine the kind of marker to insert
                // into the template source before it's parsed by the browser's HTML
                // parser. The marker type is based on whether the expression is in an
                // attribute, text, or comment position.
                //   * For node-position bindings we insert a comment with the marker
                //     sentinel as its text content, like <!--{{lit-guid}}-->.
                //   * For attribute bindings we insert just the marker sentinel for the
                //     first binding, so that we support unquoted attribute bindings.
                //     Subsequent bindings can use a comment marker because multi-binding
                //     attributes must be quoted.
                //   * For comment bindings we insert just the marker sentinel so we don't
                //     close the comment.
                //
                // The following code scans the template source, but is *not* an HTML
                // parser. We don't need to track the tree structure of the HTML, only
                // whether a binding is inside a comment, and if not, if it appears to be
                // the first binding in an attribute.
                const commentOpen = s.lastIndexOf('<!--');
                // We're in comment position if we have a comment open with no following
                // comment close. Because <-- can appear in an attribute value there can
                // be false positives.
                isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                    s.indexOf('-->', commentOpen + 1) === -1;
                // Check to see if we have an attribute-like sequence preceding the
                // expression. This can match "name=value" like structures in text,
                // comments, and attribute values, so there can be false-positives.
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    // We're only in this branch if we don't have a attribute-like
                    // preceding sequence. For comments, this guards against unusual
                    // attribute values like <div foo="<!--${'bar'}">. Cases like
                    // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                    // below.
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                }
                else {
                    // For attributes we use just a marker sentinel, and also append a
                    // $lit$ suffix to the name to opt-out of attribute-specific parsing
                    // that IE and Edge do for style and certain SVG attributes.
                    html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                        attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== undefined) {
                // this is secure because `this.strings` is a TemplateStringsArray.
                // TODO: validate this when
                // https://github.com/tc39/proposal-array-is-template-object is
                // implemented.
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }
    /**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */
    class SVGTemplateResult extends TemplateResult {
        getHTML() {
            return `<svg>${super.getHTML()}</svg>`;
        }
        getTemplateElement() {
            const template = super.getTemplateElement();
            const content = template.content;
            const svgElement = content.firstChild;
            content.removeChild(svgElement);
            reparentNodes(content, svgElement.firstChild);
            return template;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return (value === null ||
            !(typeof value === 'object' || typeof value === 'function'));
    };
    const isIterable = (value) => {
        return Array.isArray(value) ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            !!(value && value[Symbol.iterator]);
    };
    /**
     * Writes attribute values to the DOM for a group of AttributeParts bound to a
     * single attribute. The value is only set once even if there are multiple parts
     * for an attribute.
     */
    class AttributeCommitter {
        constructor(element, name, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        /**
         * Creates a single part. Override this to create a differnt type of part.
         */
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            // If we're assigning an attribute via syntax like:
            //    attr="${foo}"  or  attr=${foo}
            // but not
            //    attr="${foo} ${bar}" or attr="${foo} baz"
            // then we don't want to coerce the attribute value into one long
            // string. Instead we want to just return the value itself directly,
            // so that sanitizeDOMValue can get the actual value rather than
            // String(value)
            // The exception is if v is an array, in which case we do want to smash
            // it together into a string without calling String() on the array.
            //
            // This also allows trusted values (when using TrustedTypes) being
            // assigned to DOM sinks without being stringified in the process.
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== undefined) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    }
                    else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    /**
     * A Part that controls all or part of an attribute value.
     */
    class AttributePart {
        constructor(committer) {
            this.value = undefined;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                // If the value is a not a directive, dirty the committer so that it'll
                // call setAttribute. If the value is a directive, it'll dirty the
                // committer if it calls setValue().
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    /**
     * A Part that controls a location within a Node tree. Like a Range, NodePart
     * has start and end locations and can set and update the Nodes between those
     * locations.
     *
     * NodeParts support several value types: primitives, Nodes, TemplateResults,
     * as well as arrays and iterables of those types.
     */
    class NodePart {
        constructor(options) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.options = options;
        }
        /**
         * Appends this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        /**
         * Inserts this part after the `ref` node (between `ref` and `ref`'s next
         * sibling). Both `ref` and its next sibling must be static, unchanging nodes
         * such as those that appear in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        /**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendIntoPart(part) {
            part.__insert(this.startNode = createMarker());
            part.__insert(this.endNode = createMarker());
        }
        /**
         * Inserts this part after the `ref` part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterPart(ref) {
            ref.__insert(this.startNode = createMarker());
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            }
            else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            }
            else if (value instanceof Node) {
                this.__commitNode(value);
            }
            else if (isIterable(value)) {
                this.__commitIterable(value);
            }
            else if (value === nothing) {
                this.value = nothing;
                this.clear();
            }
            else {
                // Fallback, will render the string representation
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            // If `value` isn't already a string, we explicitly convert it here in case
            // it can't be implicitly converted - i.e. it's a symbol.
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling &&
                node.nodeType === 3 /* Node.TEXT_NODE */) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if this.value is primitive?
                node.data = valueAsString;
            }
            else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance &&
                this.value.template === template) {
                this.value.update(value.values);
            }
            else {
                // Make sure we propagate the template processor from the TemplateResult
                // so that we use its syntax extension, etc. The template factory comes
                // from the render function options so that it can control template
                // caching and preprocessing.
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _value is an array, then the previous render was of an
            // iterable and _value will contain the NodeParts from the previous
            // render. If _value is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                // Try to reuse an existing part
                itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    }
                    else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                // Truncate the parts array so _value reflects the current state
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart {
        constructor(element, name, strings) {
            this.value = undefined;
            this.__pendingValue = undefined;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    /**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name, strings) {
            super(element, name, strings);
            this.single =
                (strings.length === 2 && strings[0] === '' && strings[1] === '');
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {
    }
    // Detect event listener options support. If the `capture` property is read
    // from the options object, then options are supported. If not, then the third
    // argument to add/removeEventListener is interpreted as the boolean capture
    // value so we should only pass the `capture` property.
    let eventOptionsSupported = false;
    // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
    // blocks right into the body of a module
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.addEventListener('test', options, options);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.removeEventListener('test', options, options);
        }
        catch (_e) {
            // event options not supported
        }
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener = newListener == null ||
                oldListener != null &&
                    (newListener.capture !== oldListener.capture ||
                        newListener.once !== oldListener.once ||
                        newListener.passive !== oldListener.passive);
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event);
            }
            else {
                this.value.handleEvent(event);
            }
        }
    }
    // We copy options because of the inconsistent behavior of browsers when reading
    // the third argument of add/removeEventListener. IE11 doesn't support options
    // at all. Chrome 41 only reads `capture` if the argument is an object.
    const getOptions = (o) => o &&
        (eventOptionsSupported ?
            { capture: o.capture, passive: o.passive, once: o.once } :
            o.capture);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function templateFactory(result) {
        let templateCache = templateCaches.get(result.type);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        // If the TemplateStringsArray is new, generate a key from the strings
        // This key is shared between all templates with identical content
        const key = result.strings.join(marker);
        // Check if we already have a Template for this key
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            // If we have not seen this key before, create a new Template
            template = new Template(result, result.getTemplateElement());
            // Cache the Template for this key
            templateCache.keyString.set(key, template);
        }
        // Cache all future queries for this TemplateStringsArray
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches = new Map();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    /**
     * Renders a template result or other value to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result Any value renderable by NodePart - typically a TemplateResult
     *     created by evaluating a template tag like `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param options RenderOptions for the entire render tree rendered to this
     *     container. Render options must *not* change between renders to the same
     *     container, as those changes will not effect previously rendered DOM.
     */
    const render$1 = (result, container, options) => {
        let part = parts.get(container);
        if (part === undefined) {
            removeNodes(container, container.firstChild);
            parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Creates Parts when a template is instantiated.
     */
    class DefaultTemplateProcessor {
        /**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */
        handleAttributeExpressions(element, name, strings, options) {
            const prefix = name[0];
            if (prefix === '.') {
                const committer = new PropertyCommitter(element, name.slice(1), strings);
                return committer.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name, strings);
            return committer.parts;
        }
        /**
         * Create parts for a text-position binding.
         * @param templateFactory
         */
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for lit-html usage.
    // TODO(justinfagnani): inject version number at build time
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
    }
    /**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
    /**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */
    const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // Get a key to lookup in `templateCaches`.
    const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
    let compatibleShadyCSSVersion = true;
    if (typeof window.ShadyCSS === 'undefined') {
        compatibleShadyCSSVersion = false;
    }
    else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
        console.warn(`Incompatible ShadyCSS version detected. ` +
            `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
            `@webcomponents/shadycss@1.3.1.`);
        compatibleShadyCSSVersion = false;
    }
    /**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */
    const shadyTemplateFactory = (scopeName) => (result) => {
        const cacheKey = getTemplateCacheKey(result.type, scopeName);
        let templateCache = templateCaches.get(cacheKey);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches.set(cacheKey, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        const key = result.strings.join(marker);
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            const element = result.getTemplateElement();
            if (compatibleShadyCSSVersion) {
                window.ShadyCSS.prepareTemplateDom(element, scopeName);
            }
            template = new Template(result, element);
            templateCache.keyString.set(key, template);
        }
        templateCache.stringsArray.set(result.strings, template);
        return template;
    };
    const TEMPLATE_TYPES = ['html', 'svg'];
    /**
     * Removes all style elements from Templates for the given scopeName.
     */
    const removeStylesFromLitTemplates = (scopeName) => {
        TEMPLATE_TYPES.forEach((type) => {
            const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));
            if (templates !== undefined) {
                templates.keyString.forEach((template) => {
                    const { element: { content } } = template;
                    // IE 11 doesn't support the iterable param Set constructor
                    const styles = new Set();
                    Array.from(content.querySelectorAll('style')).forEach((s) => {
                        styles.add(s);
                    });
                    removeNodesFromTemplate(template, styles);
                });
            }
        });
    };
    const shadyRenderSet = new Set();
    /**
     * For the given scope name, ensures that ShadyCSS style scoping is performed.
     * This is done just once per scope name so the fragment and template cannot
     * be modified.
     * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
     * to be scoped and appended to the document
     * (2) removes style elements from all lit-html Templates for this scope name.
     *
     * Note, <style> elements can only be placed into templates for the
     * initial rendering of the scope. If <style> elements are included in templates
     * dynamically rendered to the scope (after the first scope render), they will
     * not be scoped and the <style> will be left in the template and rendered
     * output.
     */
    const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
        shadyRenderSet.add(scopeName);
        // If `renderedDOM` is stamped from a Template, then we need to edit that
        // Template's underlying template element. Otherwise, we create one here
        // to give to ShadyCSS, which still requires one while scoping.
        const templateElement = !!template ? template.element : document.createElement('template');
        // Move styles out of rendered DOM and store.
        const styles = renderedDOM.querySelectorAll('style');
        const { length } = styles;
        // If there are no styles, skip unnecessary work
        if (length === 0) {
            // Ensure prepareTemplateStyles is called to support adding
            // styles via `prepareAdoptedCssText` since that requires that
            // `prepareTemplateStyles` is called.
            //
            // ShadyCSS will only update styles containing @apply in the template
            // given to `prepareTemplateStyles`. If no lit Template was given,
            // ShadyCSS will not be able to update uses of @apply in any relevant
            // template. However, this is not a problem because we only create the
            // template for the purpose of supporting `prepareAdoptedCssText`,
            // which doesn't support @apply at all.
            window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
            return;
        }
        const condensedStyle = document.createElement('style');
        // Collect styles into a single style. This helps us make sure ShadyCSS
        // manipulations will not prevent us from being able to fix up template
        // part indices.
        // NOTE: collecting styles is inefficient for browsers but ShadyCSS
        // currently does this anyway. When it does not, this should be changed.
        for (let i = 0; i < length; i++) {
            const style = styles[i];
            style.parentNode.removeChild(style);
            condensedStyle.textContent += style.textContent;
        }
        // Remove styles from nested templates in this scope.
        removeStylesFromLitTemplates(scopeName);
        // And then put the condensed style into the "root" template passed in as
        // `template`.
        const content = templateElement.content;
        if (!!template) {
            insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
        }
        else {
            content.insertBefore(condensedStyle, content.firstChild);
        }
        // Note, it's important that ShadyCSS gets the template that `lit-html`
        // will actually render so that it can update the style inside when
        // needed (e.g. @apply native Shadow DOM case).
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        const style = content.querySelector('style');
        if (window.ShadyCSS.nativeShadow && style !== null) {
            // When in native Shadow DOM, ensure the style created by ShadyCSS is
            // included in initially rendered output (`renderedDOM`).
            renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
        }
        else if (!!template) {
            // When no style is left in the template, parts will be broken as a
            // result. To fix this, we put back the style node ShadyCSS removed
            // and then tell lit to remove that node from the template.
            // There can be no style in the template in 2 cases (1) when Shady DOM
            // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
            // is in use ShadyCSS removes the style if it contains no content.
            // NOTE, ShadyCSS creates its own style so we can safely add/remove
            // `condensedStyle` here.
            content.insertBefore(condensedStyle, content.firstChild);
            const removes = new Set();
            removes.add(condensedStyle);
            removeNodesFromTemplate(template, removes);
        }
    };
    /**
     * Extension to the standard `render` method which supports rendering
     * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
     * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
     * or when the webcomponentsjs
     * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
     *
     * Adds a `scopeName` option which is used to scope element DOM and stylesheets
     * when native ShadowDOM is unavailable. The `scopeName` will be added to
     * the class attribute of all rendered DOM. In addition, any style elements will
     * be automatically re-written with this `scopeName` selector and moved out
     * of the rendered DOM and into the document `<head>`.
     *
     * It is common to use this render method in conjunction with a custom element
     * which renders a shadowRoot. When this is done, typically the element's
     * `localName` should be used as the `scopeName`.
     *
     * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
     * custom properties (needed only on older browsers like IE11) and a shim for
     * a deprecated feature called `@apply` that supports applying a set of css
     * custom properties to a given location.
     *
     * Usage considerations:
     *
     * * Part values in `<style>` elements are only applied the first time a given
     * `scopeName` renders. Subsequent changes to parts in style elements will have
     * no effect. Because of this, parts in style elements should only be used for
     * values that will never change, for example parts that set scope-wide theme
     * values or parts which render shared style elements.
     *
     * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
     * custom element's `constructor` is not supported. Instead rendering should
     * either done asynchronously, for example at microtask timing (for example
     * `Promise.resolve()`), or be deferred until the first time the element's
     * `connectedCallback` runs.
     *
     * Usage considerations when using shimmed custom properties or `@apply`:
     *
     * * Whenever any dynamic changes are made which affect
     * css custom properties, `ShadyCSS.styleElement(element)` must be called
     * to update the element. There are two cases when this is needed:
     * (1) the element is connected to a new parent, (2) a class is added to the
     * element that causes it to match different custom properties.
     * To address the first case when rendering a custom element, `styleElement`
     * should be called in the element's `connectedCallback`.
     *
     * * Shimmed custom properties may only be defined either for an entire
     * shadowRoot (for example, in a `:host` rule) or via a rule that directly
     * matches an element with a shadowRoot. In other words, instead of flowing from
     * parent to child as do native css custom properties, shimmed custom properties
     * flow only from shadowRoots to nested shadowRoots.
     *
     * * When using `@apply` mixing css shorthand property names with
     * non-shorthand names (for example `border` and `border-width`) is not
     * supported.
     */
    const render = (result, container, options) => {
        if (!options || typeof options !== 'object' || !options.scopeName) {
            throw new Error('The `scopeName` option is required.');
        }
        const scopeName = options.scopeName;
        const hasRendered = parts.has(container);
        const needsScoping = compatibleShadyCSSVersion &&
            container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
            !!container.host;
        // Handle first render to a scope specially...
        const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
        // On first scope render, render into a fragment; this cannot be a single
        // fragment that is reused since nested renders can occur synchronously.
        const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
        render$1(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
        // When performing first scope render,
        // (1) We've rendered into a fragment so that there's a chance to
        // `prepareTemplateStyles` before sub-elements hit the DOM
        // (which might cause them to render based on a common pattern of
        // rendering in a custom element's `connectedCallback`);
        // (2) Scope the template with ShadyCSS one time only for this scope.
        // (3) Render the fragment into the container and make sure the
        // container knows its `part` is the one we just rendered. This ensures
        // DOM will be re-used on subsequent renders.
        if (firstScopeRender) {
            const part = parts.get(renderContainer);
            parts.delete(renderContainer);
            // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
            // that should apply to `renderContainer` even if the rendered value is
            // not a TemplateInstance. However, it will only insert scoped styles
            // into the document if `prepareTemplateStyles` has already been called
            // for the given scope name.
            const template = part.value instanceof TemplateInstance ?
                part.value.template :
                undefined;
            prepareTemplateStyles(scopeName, renderContainer, template);
            removeNodes(container, container.firstChild);
            container.appendChild(renderContainer);
            parts.set(container, part);
        }
        // After elements have hit the DOM, update styling if this is the
        // initial render to this container.
        // This is needed whenever dynamic changes are made so it would be
        // safest to do every render; however, this would regress performance
        // so we leave it up to the user to call `ShadyCSS.styleElement`
        // for dynamic changes.
        if (!hasRendered && needsScoping) {
            window.ShadyCSS.styleElement(container.host);
        }
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    var _a;
    /**
     * Use this module if you want to create your own base class extending
     * [[UpdatingElement]].
     * @packageDocumentation
     */
    /*
     * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
     * replaced at compile time by the munged name for object[property]. We cannot
     * alias this function, so we have to use a small shim that has the same
     * behavior when not compiling.
     */
    window.JSCompiler_renameProperty =
        (prop, _obj) => prop;
    const defaultConverter = {
        toAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value ? '' : null;
                case Object:
                case Array:
                    // if the value is `null` or `undefined` pass this through
                    // to allow removing/no change behavior.
                    return value == null ? value : JSON.stringify(value);
            }
            return value;
        },
        fromAttribute(value, type) {
            switch (type) {
                case Boolean:
                    return value !== null;
                case Number:
                    return value === null ? null : Number(value);
                case Object:
                case Array:
                    // Type assert to adhere to Bazel's "must type assert JSON parse" rule.
                    return JSON.parse(value);
            }
            return value;
        }
    };
    /**
     * Change function that returns true if `value` is different from `oldValue`.
     * This method is used as the default for a property's `hasChanged` function.
     */
    const notEqual = (value, old) => {
        // This ensures (old==NaN, value==NaN) always returns false
        return old !== value && (old === old || value === value);
    };
    const defaultPropertyDeclaration = {
        attribute: true,
        type: String,
        converter: defaultConverter,
        reflect: false,
        hasChanged: notEqual
    };
    const STATE_HAS_UPDATED = 1;
    const STATE_UPDATE_REQUESTED = 1 << 2;
    const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
    const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
    /**
     * The Closure JS Compiler doesn't currently have good support for static
     * property semantics where "this" is dynamic (e.g.
     * https://github.com/google/closure-compiler/issues/3177 and others) so we use
     * this hack to bypass any rewriting by the compiler.
     */
    const finalized = 'finalized';
    /**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     * @noInheritDoc
     */
    class UpdatingElement extends HTMLElement {
        constructor() {
            super();
            this.initialize();
        }
        /**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */
        static get observedAttributes() {
            // note: piggy backing on this to ensure we're finalized.
            this.finalize();
            const attributes = [];
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this._classProperties.forEach((v, p) => {
                const attr = this._attributeNameForProperty(p, v);
                if (attr !== undefined) {
                    this._attributeToPropertyMap.set(attr, p);
                    attributes.push(attr);
                }
            });
            return attributes;
        }
        /**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */
        /** @nocollapse */
        static _ensureClassProperties() {
            // ensure private storage for property declarations.
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
                this._classProperties = new Map();
                // NOTE: Workaround IE11 not supporting Map constructor argument.
                const superProperties = Object.getPrototypeOf(this)._classProperties;
                if (superProperties !== undefined) {
                    superProperties.forEach((v, k) => this._classProperties.set(k, v));
                }
            }
        }
        /**
         * Creates a property accessor on the element prototype if one does not exist
         * and stores a PropertyDeclaration for the property with the given options.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         *
         * This method may be overridden to customize properties; however,
         * when doing so, it's important to call `super.createProperty` to ensure
         * the property is setup correctly. This method calls
         * `getPropertyDescriptor` internally to get a descriptor to install.
         * To customize what properties do when they are get or set, override
         * `getPropertyDescriptor`. To customize the options for a property,
         * implement `createProperty` like this:
         *
         * static createProperty(name, options) {
         *   options = Object.assign(options, {myOption: true});
         *   super.createProperty(name, options);
         * }
         *
         * @nocollapse
         */
        static createProperty(name, options = defaultPropertyDeclaration) {
            // Note, since this can be called by the `@property` decorator which
            // is called before `finalize`, we ensure storage exists for property
            // metadata.
            this._ensureClassProperties();
            this._classProperties.set(name, options);
            // Do not generate an accessor if the prototype already has one, since
            // it would be lost otherwise and that would never be the user's intention;
            // Instead, we expect users to call `requestUpdate` themselves from
            // user-defined accessors. Note that if the super has an accessor we will
            // still overwrite it
            if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
                return;
            }
            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
            const descriptor = this.getPropertyDescriptor(name, key, options);
            if (descriptor !== undefined) {
                Object.defineProperty(this.prototype, name, descriptor);
            }
        }
        /**
         * Returns a property descriptor to be defined on the given named property.
         * If no descriptor is returned, the property will not become an accessor.
         * For example,
         *
         *   class MyElement extends LitElement {
         *     static getPropertyDescriptor(name, key, options) {
         *       const defaultDescriptor =
         *           super.getPropertyDescriptor(name, key, options);
         *       const setter = defaultDescriptor.set;
         *       return {
         *         get: defaultDescriptor.get,
         *         set(value) {
         *           setter.call(this, value);
         *           // custom action.
         *         },
         *         configurable: true,
         *         enumerable: true
         *       }
         *     }
         *   }
         *
         * @nocollapse
         */
        static getPropertyDescriptor(name, key, options) {
            return {
                // tslint:disable-next-line:no-any no symbol in index
                get() {
                    return this[key];
                },
                set(value) {
                    const oldValue = this[name];
                    this[key] = value;
                    this
                        .requestUpdateInternal(name, oldValue, options);
                },
                configurable: true,
                enumerable: true
            };
        }
        /**
         * Returns the property options associated with the given property.
         * These options are defined with a PropertyDeclaration via the `properties`
         * object or the `@property` decorator and are registered in
         * `createProperty(...)`.
         *
         * Note, this method should be considered "final" and not overridden. To
         * customize the options for a given property, override `createProperty`.
         *
         * @nocollapse
         * @final
         */
        static getPropertyOptions(name) {
            return this._classProperties && this._classProperties.get(name) ||
                defaultPropertyDeclaration;
        }
        /**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */
        static finalize() {
            // finalize any superclasses
            const superCtor = Object.getPrototypeOf(this);
            if (!superCtor.hasOwnProperty(finalized)) {
                superCtor.finalize();
            }
            this[finalized] = true;
            this._ensureClassProperties();
            // initialize Map populated in observedAttributes
            this._attributeToPropertyMap = new Map();
            // make any properties
            // Note, only process "own" properties since this element will inherit
            // any properties defined on the superClass, and finalization ensures
            // the entire prototype chain is finalized.
            if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
                const props = this.properties;
                // support symbols in properties (IE11 does not support this)
                const propKeys = [
                    ...Object.getOwnPropertyNames(props),
                    ...(typeof Object.getOwnPropertySymbols === 'function') ?
                        Object.getOwnPropertySymbols(props) :
                        []
                ];
                // This for/of is ok because propKeys is an array
                for (const p of propKeys) {
                    // note, use of `any` is due to TypeSript lack of support for symbol in
                    // index types
                    // tslint:disable-next-line:no-any no symbol in index
                    this.createProperty(p, props[p]);
                }
            }
        }
        /**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */
        static _attributeNameForProperty(name, options) {
            const attribute = options.attribute;
            return attribute === false ?
                undefined :
                (typeof attribute === 'string' ?
                    attribute :
                    (typeof name === 'string' ? name.toLowerCase() : undefined));
        }
        /**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */
        static _valueHasChanged(value, old, hasChanged = notEqual) {
            return hasChanged(value, old);
        }
        /**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */
        static _propertyValueFromAttribute(value, options) {
            const type = options.type;
            const converter = options.converter || defaultConverter;
            const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
            return fromAttribute ? fromAttribute(value, type) : value;
        }
        /**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */
        static _propertyValueToAttribute(value, options) {
            if (options.reflect === undefined) {
                return;
            }
            const type = options.type;
            const converter = options.converter;
            const toAttribute = converter && converter.toAttribute ||
                defaultConverter.toAttribute;
            return toAttribute(value, type);
        }
        /**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */
        initialize() {
            this._updateState = 0;
            this._updatePromise =
                new Promise((res) => this._enableUpdatingResolver = res);
            this._changedProperties = new Map();
            this._saveInstanceProperties();
            // ensures first update will be caught by an early access of
            // `updateComplete`
            this.requestUpdateInternal();
        }
        /**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */
        _saveInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            this.constructor
                ._classProperties.forEach((_v, p) => {
                if (this.hasOwnProperty(p)) {
                    const value = this[p];
                    delete this[p];
                    if (!this._instanceProperties) {
                        this._instanceProperties = new Map();
                    }
                    this._instanceProperties.set(p, value);
                }
            });
        }
        /**
         * Applies previously saved instance properties.
         */
        _applyInstanceProperties() {
            // Use forEach so this works even if for/of loops are compiled to for loops
            // expecting arrays
            // tslint:disable-next-line:no-any
            this._instanceProperties.forEach((v, p) => this[p] = v);
            this._instanceProperties = undefined;
        }
        connectedCallback() {
            // Ensure first connection completes an update. Updates cannot complete
            // before connection.
            this.enableUpdating();
        }
        enableUpdating() {
            if (this._enableUpdatingResolver !== undefined) {
                this._enableUpdatingResolver();
                this._enableUpdatingResolver = undefined;
            }
        }
        /**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */
        disconnectedCallback() {
        }
        /**
         * Synchronizes property values when attributes change.
         */
        attributeChangedCallback(name, old, value) {
            if (old !== value) {
                this._attributeToProperty(name, value);
            }
        }
        _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
            const ctor = this.constructor;
            const attr = ctor._attributeNameForProperty(name, options);
            if (attr !== undefined) {
                const attrValue = ctor._propertyValueToAttribute(value, options);
                // an undefined value does not change the attribute.
                if (attrValue === undefined) {
                    return;
                }
                // Track if the property is being reflected to avoid
                // setting the property again via `attributeChangedCallback`. Note:
                // 1. this takes advantage of the fact that the callback is synchronous.
                // 2. will behave incorrectly if multiple attributes are in the reaction
                // stack at time of calling. However, since we process attributes
                // in `update` this should not be possible (or an extreme corner case
                // that we'd like to discover).
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
                if (attrValue == null) {
                    this.removeAttribute(attr);
                }
                else {
                    this.setAttribute(attr, attrValue);
                }
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
            }
        }
        _attributeToProperty(name, value) {
            // Use tracking info to avoid deserializing attribute value if it was
            // just set from a property setter.
            if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
                return;
            }
            const ctor = this.constructor;
            // Note, hint this as an `AttributeMap` so closure clearly understands
            // the type; it has issues with tracking types through statics
            // tslint:disable-next-line:no-unnecessary-type-assertion
            const propName = ctor._attributeToPropertyMap.get(name);
            if (propName !== undefined) {
                const options = ctor.getPropertyOptions(propName);
                // mark state reflecting
                this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
                this[propName] =
                    // tslint:disable-next-line:no-any
                    ctor._propertyValueFromAttribute(value, options);
                // mark state not reflecting
                this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
            }
        }
        /**
         * This protected version of `requestUpdate` does not access or return the
         * `updateComplete` promise. This promise can be overridden and is therefore
         * not free to access.
         */
        requestUpdateInternal(name, oldValue, options) {
            let shouldRequestUpdate = true;
            // If we have a property key, perform property update steps.
            if (name !== undefined) {
                const ctor = this.constructor;
                options = options || ctor.getPropertyOptions(name);
                if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                    if (!this._changedProperties.has(name)) {
                        this._changedProperties.set(name, oldValue);
                    }
                    // Add to reflecting properties set.
                    // Note, it's important that every change has a chance to add the
                    // property to `_reflectingProperties`. This ensures setting
                    // attribute + property reflects correctly.
                    if (options.reflect === true &&
                        !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                        if (this._reflectingProperties === undefined) {
                            this._reflectingProperties = new Map();
                        }
                        this._reflectingProperties.set(name, options);
                    }
                }
                else {
                    // Abort the request if the property should not be considered changed.
                    shouldRequestUpdate = false;
                }
            }
            if (!this._hasRequestedUpdate && shouldRequestUpdate) {
                this._updatePromise = this._enqueueUpdate();
            }
        }
        /**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */
        requestUpdate(name, oldValue) {
            this.requestUpdateInternal(name, oldValue);
            return this.updateComplete;
        }
        /**
         * Sets up the element to asynchronously update.
         */
        async _enqueueUpdate() {
            this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
            try {
                // Ensure any previous update has resolved before updating.
                // This `await` also ensures that property changes are batched.
                await this._updatePromise;
            }
            catch (e) {
                // Ignore any previous errors. We only care that the previous cycle is
                // done. Any error should have been handled in the previous update.
            }
            const result = this.performUpdate();
            // If `performUpdate` returns a Promise, we await it. This is done to
            // enable coordinating updates with a scheduler. Note, the result is
            // checked to avoid delaying an additional microtask unless we need to.
            if (result != null) {
                await result;
            }
            return !this._hasRequestedUpdate;
        }
        get _hasRequestedUpdate() {
            return (this._updateState & STATE_UPDATE_REQUESTED);
        }
        get hasUpdated() {
            return (this._updateState & STATE_HAS_UPDATED);
        }
        /**
         * Performs an element update. Note, if an exception is thrown during the
         * update, `firstUpdated` and `updated` will not be called.
         *
         * You can override this method to change the timing of updates. If this
         * method is overridden, `super.performUpdate()` must be called.
         *
         * For instance, to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */
        performUpdate() {
            // Abort any update if one is not pending when this is called.
            // This can happen if `performUpdate` is called early to "flush"
            // the update.
            if (!this._hasRequestedUpdate) {
                return;
            }
            // Mixin instance properties once, if they exist.
            if (this._instanceProperties) {
                this._applyInstanceProperties();
            }
            let shouldUpdate = false;
            const changedProperties = this._changedProperties;
            try {
                shouldUpdate = this.shouldUpdate(changedProperties);
                if (shouldUpdate) {
                    this.update(changedProperties);
                }
                else {
                    this._markUpdated();
                }
            }
            catch (e) {
                // Prevent `firstUpdated` and `updated` from running when there's an
                // update exception.
                shouldUpdate = false;
                // Ensure element can accept additional updates after an exception.
                this._markUpdated();
                throw e;
            }
            if (shouldUpdate) {
                if (!(this._updateState & STATE_HAS_UPDATED)) {
                    this._updateState = this._updateState | STATE_HAS_UPDATED;
                    this.firstUpdated(changedProperties);
                }
                this.updated(changedProperties);
            }
        }
        _markUpdated() {
            this._changedProperties = new Map();
            this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
        }
        /**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. If the Promise is rejected, an
         * exception was thrown during the update.
         *
         * To await additional asynchronous work, override the `_getUpdateComplete`
         * method. For example, it is sometimes useful to await a rendered element
         * before fulfilling this Promise. To do this, first await
         * `super._getUpdateComplete()`, then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */
        get updateComplete() {
            return this._getUpdateComplete();
        }
        /**
         * Override point for the `updateComplete` promise.
         *
         * It is not safe to override the `updateComplete` getter directly due to a
         * limitation in TypeScript which means it is not possible to call a
         * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
         * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
         * This method should be overridden instead. For example:
         *
         *   class MyElement extends LitElement {
         *     async _getUpdateComplete() {
         *       await super._getUpdateComplete();
         *       await this._myChild.updateComplete;
         *     }
         *   }
         * @deprecated Override `getUpdateComplete()` instead for forward
         *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
         */
        _getUpdateComplete() {
            return this.getUpdateComplete();
        }
        /**
         * Override point for the `updateComplete` promise.
         *
         * It is not safe to override the `updateComplete` getter directly due to a
         * limitation in TypeScript which means it is not possible to call a
         * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
         * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
         * This method should be overridden instead. For example:
         *
         *   class MyElement extends LitElement {
         *     async getUpdateComplete() {
         *       await super.getUpdateComplete();
         *       await this._myChild.updateComplete;
         *     }
         *   }
         */
        getUpdateComplete() {
            return this._updatePromise;
        }
        /**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        shouldUpdate(_changedProperties) {
            return true;
        }
        /**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        update(_changedProperties) {
            if (this._reflectingProperties !== undefined &&
                this._reflectingProperties.size > 0) {
                // Use forEach so this works even if for/of loops are compiled to for
                // loops expecting arrays
                this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
                this._reflectingProperties = undefined;
            }
            this._markUpdated();
        }
        /**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        updated(_changedProperties) {
        }
        /**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * @param _changedProperties Map of changed properties with old values
         */
        firstUpdated(_changedProperties) {
        }
    }
    _a = finalized;
    /**
     * Marks class as having finished creating properties.
     */
    UpdatingElement[_a] = true;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const standardProperty = (options, element) => {
        // When decorating an accessor, pass it through and add property metadata.
        // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
        // stomp over the user's accessor.
        if (element.kind === 'method' && element.descriptor &&
            !('value' in element.descriptor)) {
            return Object.assign(Object.assign({}, element), { finisher(clazz) {
                    clazz.createProperty(element.key, options);
                } });
        }
        else {
            // createProperty() takes care of defining the property, but we still
            // must return some kind of descriptor, so return a descriptor for an
            // unused prototype field. The finisher calls createProperty().
            return {
                kind: 'field',
                key: Symbol(),
                placement: 'own',
                descriptor: {},
                // When @babel/plugin-proposal-decorators implements initializers,
                // do this instead of the initializer below. See:
                // https://github.com/babel/babel/issues/9260 extras: [
                //   {
                //     kind: 'initializer',
                //     placement: 'own',
                //     initializer: descriptor.initializer,
                //   }
                // ],
                initializer() {
                    if (typeof element.initializer === 'function') {
                        this[element.key] = element.initializer.call(this);
                    }
                },
                finisher(clazz) {
                    clazz.createProperty(element.key, options);
                }
            };
        }
    };
    const legacyProperty = (options, proto, name) => {
        proto.constructor
            .createProperty(name, options);
    };
    /**
     * A property decorator which creates a LitElement property which reflects a
     * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be
     * supplied to configure property features.
     *
     * This decorator should only be used for public fields. Private or protected
     * fields should use the [[`internalProperty`]] decorator.
     *
     * @example
     * ```ts
     * class MyElement {
     *   @property({ type: Boolean })
     *   clicked = false;
     * }
     * ```
     * @category Decorator
     * @ExportDecoratedItems
     */
    function property(options) {
        // tslint:disable-next-line:no-any decorator
        return (protoOrDescriptor, name) => (name !== undefined) ?
            legacyProperty(options, protoOrDescriptor, name) :
            standardProperty(options, protoOrDescriptor);
    }
    /**
     * A property decorator that converts a class property into a getter that
     * executes a querySelector on the element's renderRoot.
     *
     * @param selector A DOMString containing one or more selectors to match.
     * @param cache An optional boolean which when true performs the DOM query only
     * once and caches the result.
     *
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
     *
     * @example
     *
     * ```ts
     * class MyElement {
     *   @query('#first')
     *   first;
     *
     *   render() {
     *     return html`
     *       <div id="first"></div>
     *       <div id="second"></div>
     *     `;
     *   }
     * }
     * ```
     * @category Decorator
     */
    function query(selector, cache) {
        return (protoOrDescriptor, 
        // tslint:disable-next-line:no-any decorator
        name) => {
            const descriptor = {
                get() {
                    return this.renderRoot.querySelector(selector);
                },
                enumerable: true,
                configurable: true,
            };
            if (cache) {
                const prop = name !== undefined ? name : protoOrDescriptor.key;
                const key = typeof prop === 'symbol' ? Symbol() : `__${prop}`;
                descriptor.get = function () {
                    if (this[key] === undefined) {
                        (this[key] =
                            this.renderRoot.querySelector(selector));
                    }
                    return this[key];
                };
            }
            return (name !== undefined) ?
                legacyQuery(descriptor, protoOrDescriptor, name) :
                standardQuery(descriptor, protoOrDescriptor);
        };
    }
    const legacyQuery = (descriptor, proto, name) => {
        Object.defineProperty(proto, name, descriptor);
    };
    const standardQuery = (descriptor, element) => ({
        kind: 'method',
        placement: 'prototype',
        key: element.key,
        descriptor,
    });

    /**
    @license
    Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at
    http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
    http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
    found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
    part of the polymer project is also subject to an additional IP rights grant
    found at http://polymer.github.io/PATENTS.txt
    */
    /**
     * Whether the current browser supports `adoptedStyleSheets`.
     */
    const supportsAdoptingStyleSheets = (window.ShadowRoot) &&
        (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&
        ('adoptedStyleSheets' in Document.prototype) &&
        ('replace' in CSSStyleSheet.prototype);
    const constructionToken = Symbol();
    class CSSResult {
        constructor(cssText, safeToken) {
            if (safeToken !== constructionToken) {
                throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
            }
            this.cssText = cssText;
        }
        // Note, this is a getter so that it's lazy. In practice, this means
        // stylesheets are not created until the first element instance is made.
        get styleSheet() {
            if (this._styleSheet === undefined) {
                // Note, if `supportsAdoptingStyleSheets` is true then we assume
                // CSSStyleSheet is constructable.
                if (supportsAdoptingStyleSheets) {
                    this._styleSheet = new CSSStyleSheet();
                    this._styleSheet.replaceSync(this.cssText);
                }
                else {
                    this._styleSheet = null;
                }
            }
            return this._styleSheet;
        }
        toString() {
            return this.cssText;
        }
    }
    /**
     * Wrap a value for interpolation in a [[`css`]] tagged template literal.
     *
     * This is unsafe because untrusted CSS text can be used to phone home
     * or exfiltrate data to an attacker controlled site. Take care to only use
     * this with trusted input.
     */
    const unsafeCSS = (value) => {
        return new CSSResult(String(value), constructionToken);
    };
    const textFromCSSResult = (value) => {
        if (value instanceof CSSResult) {
            return value.cssText;
        }
        else if (typeof value === 'number') {
            return value;
        }
        else {
            throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
        }
    };
    /**
     * Template tag which which can be used with LitElement's [[LitElement.styles |
     * `styles`]] property to set element styles. For security reasons, only literal
     * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]
     * may be used inside a template string part.
     */
    const css = (strings, ...values) => {
        const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
        return new CSSResult(cssText, constructionToken);
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for LitElement usage.
    // TODO(justinfagnani): inject version number at build time
    (window['litElementVersions'] || (window['litElementVersions'] = []))
        .push('2.5.1');
    /**
     * Sentinal value used to avoid calling lit-html's render function when
     * subclasses do not implement `render`
     */
    const renderNotImplemented = {};
    /**
     * Base element class that manages element properties and attributes, and
     * renders a lit-html template.
     *
     * To define a component, subclass `LitElement` and implement a
     * `render` method to provide the component's template. Define properties
     * using the [[`properties`]] property or the [[`property`]] decorator.
     */
    class LitElement extends UpdatingElement {
        /**
         * Return the array of styles to apply to the element.
         * Override this method to integrate into a style management system.
         *
         * @nocollapse
         */
        static getStyles() {
            return this.styles;
        }
        /** @nocollapse */
        static _getUniqueStyles() {
            // Only gather styles once per class
            if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
                return;
            }
            // Take care not to call `this.getStyles()` multiple times since this
            // generates new CSSResults each time.
            // TODO(sorvell): Since we do not cache CSSResults by input, any
            // shared styles will generate new stylesheet objects, which is wasteful.
            // This should be addressed when a browser ships constructable
            // stylesheets.
            const userStyles = this.getStyles();
            if (Array.isArray(userStyles)) {
                // De-duplicate styles preserving the _last_ instance in the set.
                // This is a performance optimization to avoid duplicated styles that can
                // occur especially when composing via subclassing.
                // The last item is kept to try to preserve the cascade order with the
                // assumption that it's most important that last added styles override
                // previous styles.
                const addStyles = (styles, set) => styles.reduceRight((set, s) => 
                // Note: On IE set.add() does not return the set
                Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);
                // Array.from does not work on Set in IE, otherwise return
                // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()
                const set = addStyles(userStyles, new Set());
                const styles = [];
                set.forEach((v) => styles.unshift(v));
                this._styles = styles;
            }
            else {
                this._styles = userStyles === undefined ? [] : [userStyles];
            }
            // Ensure that there are no invalid CSSStyleSheet instances here. They are
            // invalid in two conditions.
            // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but
            //     this is impossible to check except via .replaceSync or use
            // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is
            //     false)
            this._styles = this._styles.map((s) => {
                if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
                    // Flatten the cssText from the passed constructible stylesheet (or
                    // undetectable non-constructible stylesheet). The user might have
                    // expected to update their stylesheets over time, but the alternative
                    // is a crash.
                    const cssText = Array.prototype.slice.call(s.cssRules)
                        .reduce((css, rule) => css + rule.cssText, '');
                    return unsafeCSS(cssText);
                }
                return s;
            });
        }
        /**
         * Performs element initialization. By default this calls
         * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
         * captures any pre-set values for registered properties.
         */
        initialize() {
            super.initialize();
            this.constructor._getUniqueStyles();
            this.renderRoot = this.createRenderRoot();
            // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
            // element's getRootNode(). While this could be done, we're choosing not to
            // support this now since it would require different logic around de-duping.
            if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
                this.adoptStyles();
            }
        }
        /**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */
        createRenderRoot() {
            return this.attachShadow(this.constructor.shadowRootOptions);
        }
        /**
         * Applies styling to the element shadowRoot using the [[`styles`]]
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */
        adoptStyles() {
            const styles = this.constructor._styles;
            if (styles.length === 0) {
                return;
            }
            // There are three separate cases here based on Shadow DOM support.
            // (1) shadowRoot polyfilled: use ShadyCSS
            // (2) shadowRoot.adoptedStyleSheets available: use it
            // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
            // rendering
            if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
                window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
            }
            else if (supportsAdoptingStyleSheets) {
                this.renderRoot.adoptedStyleSheets =
                    styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
            }
            else {
                // This must be done after rendering so the actual style insertion is done
                // in `update`.
                this._needsShimAdoptedStyleSheets = true;
            }
        }
        connectedCallback() {
            super.connectedCallback();
            // Note, first update/render handles styleElement so we only call this if
            // connected after first update.
            if (this.hasUpdated && window.ShadyCSS !== undefined) {
                window.ShadyCSS.styleElement(this);
            }
        }
        /**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * @param _changedProperties Map of changed properties with old values
         */
        update(changedProperties) {
            // Setting properties in `render` should not trigger an update. Since
            // updates are allowed after super.update, it's important to call `render`
            // before that.
            const templateResult = this.render();
            super.update(changedProperties);
            // If render is not implemented by the component, don't call lit-html render
            if (templateResult !== renderNotImplemented) {
                this.constructor
                    .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
            }
            // When native Shadow DOM is used but adoptedStyles are not supported,
            // insert styling after rendering to ensure adoptedStyles have highest
            // priority.
            if (this._needsShimAdoptedStyleSheets) {
                this._needsShimAdoptedStyleSheets = false;
                this.constructor._styles.forEach((s) => {
                    const style = document.createElement('style');
                    style.textContent = s.cssText;
                    this.renderRoot.appendChild(style);
                });
            }
        }
        /**
         * Invoked on each update to perform rendering tasks. This method may return
         * any value renderable by lit-html's `NodePart` - typically a
         * `TemplateResult`. Setting properties inside this method will *not* trigger
         * the element to update.
         */
        render() {
            return renderNotImplemented;
        }
    }
    /**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     *
     * Note this property name is a string to prevent breaking Closure JS Compiler
     * optimizations. See updating-element.ts for more information.
     */
    LitElement['finalized'] = true;
    /**
     * Reference to the underlying library method used to render the element's
     * DOM. By default, points to the `render` method from lit-html's shady-render
     * module.
     *
     * **Most users will never need to touch this property.**
     *
     * This  property should not be confused with the `render` instance method,
     * which should be overridden to define a template for the element.
     *
     * Advanced users creating a new base class based on LitElement can override
     * this property to point to a custom render method with a signature that
     * matches [shady-render's `render`
     * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).
     *
     * @nocollapse
     */
    LitElement.render = render;
    /** @nocollapse */
    LitElement.shadowRootOptions = { mode: 'open' };

    class Component extends LitElement {}

    const _shadowRoot$1 = Symbol("shadowRoot");
    const _handleButtonClick = Symbol("_handleButtonClick");

    class MenuDisplay extends Component {
    	static get styles() {
    		return css`
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			*:focus {
				outline: var(--focus-outline, 2px solid #0af);
			}

			:host([theme="concrete"]) button {
				position: relative;
				display: block;
				margin: var(--menu-gapsize, 0.15rem);
				padding: 0;
				border: none;
				background: transparent;
			}

			.panel {
				display: none;
			}

			:host([open]) .panel {
				display: block;
			}

			:host([theme="concrete"]) .panel {
				position: absolute;
				left: var(--menu-lanesize, 1rem);
				right: var(--menu-lanesize, 1rem);
				width: var(--menu-panel-width, 640px);
				max-width: calc(100% - calc(var(--menu-lanesize, 1rem) * 2));
				margin-top: var(--menu-gapsize, 0.15rem);
				margin-left: auto;
				padding: var(--menu-panel-padding, 1rem);
				background: var(--menu-panel-background, white);
				border-radius: var(--menu-panel-border-radius, 0);
				box-shadow: var(--menu-panel-box-shadow, none);
				backdrop-filter: var(--menu-panel-backdrop-filter, none);
				--webkit-backdrop-filter: var(--menu-panel-backdrop-filter, none);
			}

			:host([theme="concrete"][sticky]) .panel {
				top: 100%;
			}

			:host([theme="concrete"][lefty]) .panel {
				margin-left: unset;
				margin-right: auto;
			}
		`
    	}

    	static get properties() {
    		return {
    			toggle: {type: Function},
    			open: {type: Boolean, reflect: true},
    			theme: {type: String, reflect: true},
    			lefty: {type: Boolean, reflect: true},
    			sticky: {type: Boolean, reflect: true}
    		}
    	}

    	constructor() {
    		super();
    		this.theme = "";
    		this.open = false;
    		this.toggle = () => {};
    		this[_handleButtonClick] = () => this.toggle();
    	}

    	createRenderRoot() {
    		this[_shadowRoot$1] = this.attachShadow({mode: "closed"});
    		return this[_shadowRoot$1]
    	}

    	updated(changedProperties) {
    		if (changedProperties.has("open") && this.open)
    			this[_shadowRoot$1].querySelector("button").focus();
    	}

    	render() {
    		return html`
			<div class="display">
				<button @click="${this[_handleButtonClick]}">
					<slot name="button"></slot>
				</button>
				<div class="panel">
					<slot></slot>
				</div>
			</div>
		`
    	}
    }

    function getEdgeVersion(userAgent = navigator.userAgent) {
    	const result = /(?:^|\s)Edge\/([\d\.]+)(?:\s|$)/i.exec(userAgent);
    	return result
    		? result[1]
    		: false
    }

    const scrollUpdateEvents = ["scroll", "resize"];

    function makeScrollMarmot({onScrollUpdate}) {
    	function handleScrollUpdate() {
    		const scrollTop = window.pageYOffset
    			|| document.documentElement.scrollTop
    			|| document.body.scrollTop
    			|| 0;
    		onScrollUpdate(scrollTop);
    	}

    	for (const event of scrollUpdateEvents)
    		window.addEventListener(event, handleScrollUpdate);

    	handleScrollUpdate();

    	return {
    		dispose() {
    			for (const event of scrollUpdateEvents)
    				window.removeEventListener(event, handleScrollUpdate, {passive: true});
    		}
    	}
    }

    function getAssignedElements(slot) {
    	return Array.from(slot.assignedNodes())
    		.filter(node => node instanceof HTMLElement)
    }

    const _scrollTop = Symbol("scrollTop");
    const _shadowRoot = Symbol("shadowRoot");
    const _activeIndex = Symbol("activeIndex");
    const _toggleIndex = Symbol("toggleIndex");
    const _scrollMarmot = Symbol("scrollMarmot");
    const _getMenuDisplays = Symbol("getMenuDisplays");
    const _updateScrollPoint = Symbol("updateScrollPoint");
    const _handleBlanketClick = Symbol("handleBlanketClick");

    const isEdge17 = (getEdgeVersion() || "").startsWith("17.");

    class MenuSystem extends Component {
    	static get properties() {
    		return {
    			["initially-hidden"]: {type: Boolean, reflect: true},
    			theme: {type: String, reflect: true},
    			lefty: {type: Boolean, reflect: true},
    			active: {type: Boolean, reflect: true},
    			sticky: {type: Boolean, reflect: true},
    			[_scrollTop]: {type: Number},
    			[_activeIndex]: {type: String}
    		}
    	}

    	constructor() {
    		super();

    		this.theme = "concrete";
    		this.active = false;
    		this.sticky = false;
    		this.lefty = false;
    		if (isEdge17) this.setAttribute("data-edge-17", "data-edge-17");

    		this[_activeIndex] = undefined;
    		this[_scrollTop] = 0;
    		this[_scrollMarmot] = undefined;

    		this[_updateScrollPoint] = scrollPoint => {
    			if (!this.active) this[_scrollTop] = scrollPoint;
    		};

    		this[_handleBlanketClick] = () => {
    			this[_toggleIndex](this[_activeIndex]);
    		};

    		this[_toggleIndex] = index => {
    			this[_activeIndex] = index === this[_activeIndex]
    				? undefined
    				: index;
    			this.active = this[_activeIndex] !== undefined;
    		};

    		this[_getMenuDisplays] = () => {
    			const slot = this[_shadowRoot].querySelector("slot");
    			return getAssignedElements(slot).filter(
    				element => element instanceof MenuDisplay
    			)
    		};
    	}

    	createRenderRoot() {
    		this[_shadowRoot] = this.attachShadow({mode: "closed"});
    		this[_shadowRoot].addEventListener("slotchange", () => this.requestUpdate());
    		return this[_shadowRoot]
    	}

    	_initScrollMarmot() {
    		if (this.sticky && !this[_scrollMarmot])
    			this[_scrollMarmot] = makeScrollMarmot({
    				onScrollUpdate: this[_updateScrollPoint]
    			});
    	}

    	_disposeScrollMarmot() {
    		if (this[_scrollMarmot]) {
    			this[_scrollMarmot].dispose();
    			this[_scrollMarmot] = null;
    		}
    	}

    	connectedCallback() {
    		super.connectedCallback();
    		if (this.isConnected) this._initScrollMarmot();
    	}

    	disconnectedCallback() {
    		super.disconnectedCallback();
    		this._disposeScrollMarmot();
    	}

    	updated() {
    		this._initScrollMarmot();
    		if (!this.sticky) this._disposeScrollMarmot();

    		this[_getMenuDisplays]().forEach((display, index) => {
    			display.theme = this.theme;
    			display.lefty = this.lefty;
    			display.toggle = () => this[_toggleIndex](index);
    			display.open = index === this[_activeIndex];
    		});
    	}

    	firstUpdated() {
    		this["initially-hidden"] = false;
    	}

    	static get styles() {
    		return css`
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			*:focus {
				outline: var(--focus-outline, 2px solid cyan);
			}

			.system {
				position: static;
				margin: var(--menu-margin, auto);
			}

			:host([theme="concrete"]) .system {
				display: flex;
				align-items: flex-end;
				justify-content: flex-end;
			}

			:host([theme="concrete"][sticky]) .system {
				pointer-events: none;
				position: absolute;
				width: 100%;
				right: 0;
			}

			:host([theme="concrete"][sticky]) .system > * {
				pointer-events: all;
			}

			:host([theme="concrete"][lefty]) .system {
				right: auto;
				left: 0;
				align-items: flex-start;
				justify-content: flex-start;
			}

			:host([theme="concrete"]) .blanket {
				z-index: 99;
				display: none;
				position: fixed;
				background: var(--menu-blanket-background, rgba(0,0,0, 0.5));
				backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
				--webkit-backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}

			:host([theme="concrete"][active]) .blanket {
				display: block;
			}

			:host([theme="concrete"]) .list {
				z-index: 100;
				display: flex;
				align-items: flex-end;
				justify-content: flex-end;
				padding: var(--menu-gapsize, 0.15rem);
				background: var(--menu-background, rgba(240, 240, 240, 0.5));
			}

			:host([theme="concrete"][sticky]) .list {
				margin-right: var(--menu-lanesize, 1rem);
			}

			:host([theme="concrete"][sticky][lefty]) .list {
				margin-right: unset;
				margin-left: var(--menu-lanesize, 1rem);
			}

			:host([theme="concrete"]) .list slot::slotted(menu-display) {
				display: block;
				flex: 0 0 auto;
			}

			/* gross edge 17 stuff we all want to forget about */

			:host([data-edge-17][theme="concrete"]) .system {
				z-index: 100;
				position: absolute;
				width: 100%;
				right: 0;
			}

			:host([data-edge-17][theme="concrete"]) .blanket {
				z-index: 0;
			}
		`
    	}

    	render() {
    		const top = this.sticky
    			? this[_scrollTop]
    			: 0;
    		return html`
			<div class="system" style="${`top: ${top}px`}">
				<div class="blanket" @click="${this[_handleBlanketClick]}"></div>
				<div class="list">
					<slot></slot>
				</div>
			</div>
		`
    	}
    }

    function dashify$1(camel) {
    	return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()
    }

    function registerComponents$1(components) {
    	for (const componentName of Object.keys(components))
    		customElements.define(
    			dashify$1(componentName),
    			components[componentName]
    		);
    }

    registerComponents$1({MenuSystem, MenuDisplay});

    window.process = { env: { NODE_ENV: "development" } };

    const nap = (milliseconds) => new Promise(resolve => setTimeout(resolve, milliseconds));

    function hitchie(func, process) {
        return ((...args) => process(func, ...args));
    }

    async function applyMockHacks({ connection, frontend }) {
        const { loginService } = connection.remote.auth;
        loginService.sendLoginLink = hitchie(loginService.sendLoginLink, async (func, ...args) => {
            await func(...args);
            const details = connection.backend.emails.recallLatestLoginEmail();
            console.log("mock: logging in...");
            await nap(1000);
            await frontend.models.authModel.login(details.loginToken);
            console.log(`mock: logged in as ${details.to}`);
        });
        connection.popups.triggerBankPopup = hitchie(connection.popups.triggerBankPopup, async (...args) => {
            console.log("mock: bank popup", args);
        });
    }

    const apiOrigin = "https://api.xiome.io";

    function mockPopups({ mockStripeOperations }) {
        return {
            triggerBankPopup: (async ({ stripeAccountId }) => {
                await mockStripeOperations.linkBankWithExistingStripeAccount(stripeAccountId);
            }),
        };
    }

    const second = 1000;
    const minute = 60 * second;
    const hour = 60 * minute;
    const day = 24 * hour;
    const year = 365 * day;
    const month = year / 12;

    const mockConfig = ({ platformHome, platformOrigins }) => ({
        server: {
            port: 4999,
            detailedLogs: true,
        },
        platform: {
            legalLink: "https://xiome.io/legal",
            technician: {
                email: "chasemoskal@gmail.com",
            },
            appDetails: {
                appId: "6Ns7WcB8xCqgSSMtqxZNCYXDK8N8qNM2cFRrwGggrTSD8TDx",
                label: "Xiome Cloud",
                home: platformHome,
                origins: platformOrigins,
            },
        },
        email: "mock-console",
        database: "mock-localstorage",
        stripe: "mock-mode",
        crypto: {
            keys: "mock-mode",
            tokenLifespans: {
                login: 5 * minute,
                refresh: 30 * day,
                access: 5 * minute,
                external: 5 * minute,
            },
        },
    });

    async function mockRegisterApp({ apiLink, ownerEmail, appOrigins, backend }) {
        const mockBrowserForPlatform = await backend.mockBrowser();
        const mockWindowForPlatform = await mockBrowserForPlatform.mockAppWindow({
            apiLink,
            latency: false,
            appId: backend.platformAppId,
            windowLink: window.location.href,
        });
        const { authModel, appModel } = mockWindowForPlatform.models;
        await authModel.sendLoginLink(ownerEmail);
        await authModel.login(backend.emails.recallLatestLoginEmail().loginToken);
        const { appId } = await appModel.registerApp({
            label: "Mock App",
            home: window.location.href,
            origins: appOrigins,
        });
        console.log("mock: register app", appId);
        // TODO reactivate store
        // // link bank account with stripe
        // await mockWindowForPlatform.models.storeModel.shares.bank.setupStripeAccount(appId)
        // const stripeDetails = await mockWindowForPlatform.models.bankModel.getStripeAccountDetails(appId)
        // console.log("mock: app stripe details", stripeDetails)
        return appId;
    }

    function objectMap$1(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    function isObject(value) {
        return value !== undefined
            && value !== null
            && typeof value === "object";
    }

    const _augment = Symbol();

    function isShapeContext(shapeContext) {
        return isObject(shapeContext) && !!shapeContext[_augment];
    }

    function generateRemote({ link, shape, specpath = [], requester, }) {
        return objectMap$1(shape, (value, key) => {
            if (isShapeContext(value)) {
                const { getMeta } = value[_augment];
                function recurseOverContext(shapeContext, subpath = []) {
                    return objectMap$1(shapeContext, (value2, key2) => {
                        if (value2 === true) {
                            return async (...args) => {
                                const specifier = [...specpath, ...subpath, key, key2].join(".");
                                const meta = await getMeta();
                                const result = await requester({
                                    link,
                                    args,
                                    meta,
                                    specifier,
                                });
                                return result;
                            };
                        }
                        else if (isObject(value2)) {
                            return recurseOverContext(value2, [...subpath, key2]);
                        }
                    });
                }
                return recurseOverContext(value);
            }
            else if (isObject(value)) {
                return generateRemote({
                    link,
                    shape: value,
                    specpath: [...specpath, key],
                    requester,
                });
            }
        });
    }

    const contentTypeText = "text/plain; charset=utf-8";

    function jsonHttpRequest({ link, meta, args, specifier, requestOrigin, headers: moreHeaders, }) {
        return {
            method: "post",
            path: new URL(link).pathname,
            headers: {
                // json requests are sent as plain text
                // in order to avoid any cors 'options' preflight requests
                // by qualifying as a cors "simple request"
                "content-type": contentTypeText,
                ...requestOrigin
                    ? { "origin": requestOrigin }
                    : {},
                ...moreHeaders,
            },
            body: JSON.stringify({
                jsonrpc: "2.0",
                method: specifier,
                params: [meta, ...args],
            }),
        };
    }

    function parseJsonResponse(response) {
        const json = JSON.parse(response.body);
        if (response.status !== 200 || json.error) {
            const message = json.error?.message;
            throw new Error(message
                ? `${response.status}: ${message}`
                : `unknown error`);
        }
        else {
            return json.result;
        }
    }

    function loopbackJsonRemote({ link, shape, headers, servelet }) {
        return generateRemote({
            link,
            shape,
            requester: async ({ args, link, meta, specifier }) => {
                const request = jsonHttpRequest({
                    link,
                    args,
                    meta,
                    headers,
                    specifier,
                });
                const response = await servelet(request);
                return parseJsonResponse(response);
            },
        });
    }

    function noServeletLogger() {
        return {
            logRequest() { },
            logApiError() { },
            logUnexpectedError() { },
        };
    }

    function obtain(specifier, object) {
        return specifier.split(".").reduce((x, y) => x && x[y] || undefined, object);
    }

    class ApiError extends Error {
        code;
        constructor(code, message) {
            super(message);
            this.code = code;
        }
    }

    function isApiError(error) {
        return !!error && error instanceof ApiError;
    }

    function stopwatch() {
        const start = Date.now();
        return function stop() {
            const elapsed = Date.now() - start;
            return elapsed;
        };
    }

    function serveletLoggerCore(logger, detailed) {
        return {
            logRequest({ specifier, meta, args, times, result }) {
                if (detailed)
                    logger.log(`🛎️ ${specifier}()`, `\n 👥`, meta, `\n 📜`, args, `\n ⏱️ ${times.total}ms (${times.auth}ms + ${times.procedure}ms)` +
                        `\n 🎁`, result);
                else
                    logger.log(`🛎️ ${specifier}() ${times.total}ms (${times.auth}ms + ${times.procedure}ms)`);
            },
            logApiError(error) {
                logger.warn(`⚠️ ${error.code} ApiError: ${error.message}`);
            },
            logUnexpectedError(error) {
                logger.error(`🚨 unexpected error!\n`, error);
            },
        };
    }

    function timestampedLogger(logger) {
        function timestamp(time) {
            const date = new Date(time);
            const year = date.getUTCFullYear().toString().padStart(4, "0");
            const month = (date.getUTCMonth() + 1).toString().padStart(2, "0");
            const day = date.getUTCDate().toString().padStart(2, "0");
            const calendar = `${year}-${month}-${day}`;
            const hour = date.getUTCHours().toString().padStart(2, "0");
            const minute = date.getUTCMinutes().toString().padStart(2, "0");
            const second = date.getUTCSeconds().toString().padStart(2, "0");
            const milliseconds = date.getUTCMilliseconds().toString().padStart(3, "0");
            const clock = `${hour}:${minute}:${second}.${milliseconds}`;
            return `[${calendar}::${clock}]`;
        }
        function stamp(log) {
            return (...data) => log(timestamp(Date.now()), ...data);
        }
        return {
            log: stamp(logger.log),
            warn: stamp(logger.warn),
            error: stamp(logger.error),
        };
    }

    function doubleSpaceLogger(logger) {
        function double(log) {
            return (...data) => {
                if (data.length > 0 && typeof data[0] === "string") {
                    const [first, ...rest] = data;
                    log("\n" + first, ...rest);
                }
                else {
                    log("\n", ...data);
                }
            };
        }
        return {
            log: double(logger.log),
            warn: double(logger.warn),
            error: double(logger.error),
        };
    }

    function serveletLoggerPlain(logger, detailed = false) {
        const maybeDoubleSpaced = detailed
            ? doubleSpaceLogger(logger)
            : logger;
        return serveletLoggerCore(timestampedLogger(maybeDoubleSpaced), detailed);
    }

    function makeServelet({ expose, responder, serveletLogger = serveletLoggerPlain(console), parseRequest, }) {
        return async function execute(request) {
            let errorRequestId;
            try {
                const totalClock = stopwatch();
                const { requestId, specifier, meta, args } = await parseRequest(request);
                errorRequestId = requestId;
                const { func, policy } = obtain(specifier, expose);
                const times = {
                    auth: -1,
                    procedure: -1,
                    total: -1,
                };
                const authClock = stopwatch();
                const auth = await policy.processAuth(meta, request);
                times.auth = authClock();
                const procedureClock = stopwatch();
                const result = await func(auth, ...args);
                times.procedure = procedureClock();
                const response = responder.resultResponse(requestId, result);
                times.total = totalClock();
                serveletLogger.logRequest({ specifier, meta, args, times, result });
                return response;
            }
            catch (error) {
                if (isApiError(error)) {
                    serveletLogger.logApiError(error);
                    return responder.errorResponse(errorRequestId, error);
                }
                else {
                    serveletLogger.logUnexpectedError(error);
                    return responder.errorResponse(errorRequestId, new ApiError(500, "error"));
                }
            }
        };
    }

    async function parseJsonRequest(request) {
        const { id, method, params } = JSON.parse(request.body);
        const specifier = method;
        const [meta, ...args] = params;
        return {
            requestId: id,
            specifier,
            meta,
            args,
        };
    }

    const contentTypeJson = "application/json; charset=utf-8";

    const jsonrpc = "2.0";
    const errorCode = -32000;
    const makeJsonHttpResponder = ({ headers }) => ({
        resultResponse: (requestId, result) => ({
            status: 200,
            headers: {
                "Content-Type": contentTypeJson,
                ...headers,
            },
            body: JSON.stringify({
                jsonrpc,
                id: requestId,
                result,
            }),
        }),
        errorResponse: (requestId, error) => ({
            status: error.code,
            headers: {
                "Content-Type": contentTypeJson,
                ...headers,
            },
            body: JSON.stringify({
                jsonrpc,
                id: requestId,
                error: {
                    code: errorCode,
                    message: error.message,
                },
            }),
        }),
    });

    function makeJsonHttpServelet(expose, serveletLogger) {
        return makeServelet({
            expose,
            serveletLogger,
            responder: makeJsonHttpResponder({ headers: {} }),
            parseRequest: parseJsonRequest,
        });
    }

    function asShape(shape) {
        return shape;
    }

    /**
     * create a pub/sub context
     */
    function pubsub() {
        let listeners = [];
        return {
            publish: (async (...args) => {
                const operations = listeners.map(listener => listener(...args));
                await Promise.all(operations);
            }),
            subscribe(func) {
                listeners.push(func);
                return () => {
                    listeners = listeners.filter(listener => listener !== func);
                };
            },
            dispose: () => {
                listeners = [];
            },
        };
    }
    /**
     * create a separated group of publish and subscribe functions
     */
    function pubsubs(obj) {
        const publishers = {};
        const subscribers = {};
        for (const [key, original] of Object.entries(obj)) {
            publishers[key] = original.publish;
            subscribers[key] = original.subscribe;
        }
        return { publishers, subscribers };
    }

    const browser = typeof atob === "function";
    function encode(text) {
        return browser
            ? btoa(text)
            : Buffer.from(text).toString("base64");
    }
    function decode(base64) {
        return browser
            ? atob(base64)
            : Buffer.from(base64, "base64").toString("binary");
    }
    const url$1 = Object.freeze({
        encode: (text) => {
            const base64 = encode(text);
            const base64url = addEqualsPadding(base64
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_"));
            return base64url;
        },
        decode: (base64url) => {
            const base64 = base64url
                .replace(/-/g, "+")
                .replace(/_/g, "/");
            return decode(base64);
        },
    });
    function addEqualsPadding(base64) {
        return base64 + Array((4 - base64.length % 4) % 4 + 1).join("=");
    }

    const tokenDecode = function decode(token) {
        const [, data] = token.split(".");
        const json = decodeURIComponent(url$1.decode(data)
            .split("")
            .map(c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
            .join(""));
        return JSON.parse(json);
    };

    const expiryRenewalCushion = 60 * 1000;
    function isTokenTimingExpired(exp) {
        const expiry = exp * 1000;
        return Date.now() > (expiry - expiryRenewalCushion);
    }

    function isTokenValid(token) {
        return !!token
            && !isTokenTimingExpired(tokenDecode(token).exp);
    }

    const decodeAccessToken = (accessToken) => {
        return tokenDecode(accessToken).payload;
    };

    function makeAuthMediator({ appId, storage, greenService, }) {
        const tokenChangeEvent = pubsub();
        const accessEvent = pubsub();
        const key = `auth-tokens-${appId}`;
        const emptyTokens = () => ({ accessToken: undefined, refreshToken: undefined });
        const getTokens = async () => await storage.read(key) ?? emptyTokens();
        const setTokens = async (tokens) => storage.write(key, tokens);
        async function commitTokens(tokens) {
            const access = decodeAccessToken(tokens.accessToken);
            await setTokens(tokens);
            tokenChangeEvent.publish();
            await accessEvent.publish(access);
            return access;
        }
        async function authorize(refreshToken) {
            const accessToken = await greenService.authorize({
                appId,
                refreshToken,
                scope: { core: true },
            });
            const access = await commitTokens({ accessToken, refreshToken });
            return { access, accessToken };
        }
        const obtainAccessAndReauthorizeIfNecessary = (async () => {
            const { accessToken, refreshToken } = await getTokens();
            return isTokenValid(accessToken)
                ? { accessToken, access: decodeAccessToken(accessToken) }
                : isTokenValid(refreshToken)
                    ? authorize(refreshToken)
                    : authorize(undefined);
        });
        return {
            subscribeToAccessChange: accessEvent.subscribe,
            subscribeToTokenChange: tokenChangeEvent.subscribe,
            async initialize() {
                const { access } = await obtainAccessAndReauthorizeIfNecessary();
                await accessEvent.publish(access);
                return access;
            },
            async getAccess() {
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async getAccessToken() {
                return (await obtainAccessAndReauthorizeIfNecessary()).accessToken;
            },
            async login(tokens) {
                return commitTokens(tokens);
            },
            async logout() {
                await setTokens(emptyTokens());
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async reauthorize() {
                const tokens = await getTokens();
                await setTokens({ ...tokens, accessToken: undefined });
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
        };
    }

    function prepareApiShape({ appId, storage }) {
        let authMediator;
        const standardAugment = {
            getMeta: async () => ({
                accessToken: await authMediator.getAccessToken(),
            }),
        };
        const shape = asShape({
            auth: {
                greenService: {
                    [_augment]: { getMeta: async () => undefined },
                    authorize: true,
                },
                loginService: {
                    [_augment]: standardAugment,
                    authenticateViaLoginToken: true,
                    sendLoginLink: true,
                },
                appService: {
                    [_augment]: standardAugment,
                    listApps: true,
                    registerApp: true,
                },
                appEditService: {
                    [_augment]: standardAugment,
                    deleteApp: true,
                    updateApp: true,
                },
                manageAdminsService: {
                    [_augment]: standardAugment,
                    listAdmins: true,
                    assignAdmin: true,
                    revokeAdmin: true,
                    assignPlatformUserAsAdmin: true,
                },
                personalService: {
                    [_augment]: standardAugment,
                    setProfile: true,
                },
                userService: {
                    [_augment]: standardAugment,
                    getUser: true,
                },
                permissionsService: {
                    [_augment]: standardAugment,
                    assignPrivilege: true,
                    createRole: true,
                    deleteRole: true,
                    fetchPermissions: true,
                    unassignPrivilege: true,
                },
            },
            administrative: {
                roleAssignmentService: {
                    [_augment]: standardAugment,
                    fetchPermissions: true,
                    searchUsers: true,
                    assignRoleToUser: true,
                    revokeRoleFromUser: true,
                },
            },
            // // TODO reactivate store
            // store: {
            // 	stripeConnectService: {
            // 		[_augment]: standardAugment,
            // 		getConnectDetails: true,
            // 		generateConnectSetupLink: true,
            // 	},
            // 	shoppingService: {
            // 		[_augment]: standardAugment,
            // 		buySubscription: true,
            // 		updateSubscription: true,
            // 		endSubscription: true,
            // 	},
            // 	shopkeepingService: {
            // 		[_augment]: standardAugment,
            // 		listSubscriptionPlans: true,
            // 		createSubscriptionPlan: true,
            // 		updateSubscriptionPlan: true,
            // 		deleteSubscriptionPlan: true,
            // 		deactivateSubscriptionPlan: true,
            // 	},
            // 	ecommerce: {
            // 		statusCheckerService: {
            // 			[_augment]: standardAugment,
            // 			getStoreStatus: true,
            // 		},
            // 		statusTogglerService: {
            // 			[_augment]: standardAugment,
            // 			disableEcommerce: true,
            // 			enableEcommerce: true,
            // 		},
            // 	},
            // },
            questions: {
                questionsReadingService: {
                    [_augment]: standardAugment,
                    fetchQuestions: true,
                },
                questionsPostingService: {
                    [_augment]: standardAugment,
                    postQuestion: true,
                    archiveQuestion: true,
                    likeQuestion: true,
                    reportQuestion: true,
                },
                questionsModerationService: {
                    [_augment]: standardAugment,
                    archiveBoard: true,
                },
            },
        });
        function installAuthMediator({ greenService }) {
            authMediator = makeAuthMediator({
                appId,
                storage,
                greenService,
            });
            return authMediator;
        }
        return { shape, installAuthMediator };
    }

    function objectMap(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }
    function objectMap2(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    function logAllCalls({ logger, fullyDebug, remote }) {
        let count = 1;
        function recurse(remote, path = []) {
            return objectMap(remote, (value, key) => {
                const currentPath = [...path, key];
                if (typeof value === "function") {
                    return async (...args) => {
                        const callNumber = count++;
                        const label = `#${callNumber} ${currentPath.join(".")}`;
                        if (fullyDebug)
                            logger.log(label, ...args);
                        else
                            logger.log(label);
                        const result = await value(...args);
                        if (fullyDebug)
                            logger.log(`    #${callNumber} return:`, result);
                        return result;
                    };
                }
                else if (typeof (value ?? undefined) === "object")
                    return recurse(value, currentPath);
                else
                    throw new Error("unknown remote type");
            });
        }
        return recurse(remote);
    }

    function addMockLatency({ latency, remote }) {
        function getRandomizedDelay() {
            if (latency === false)
                return 0;
            const range = latency.max - latency.min;
            const randomRange = Math.random() * range;
            return latency.min + randomRange;
        }
        function recurse(remote) {
            return objectMap(remote, (value, key) => {
                if (typeof value === "function") {
                    return async (...args) => {
                        const delay = getRandomizedDelay();
                        await nap(delay);
                        return value(...args);
                    };
                }
                else if (typeof (value ?? undefined) === "object")
                    return recurse(value);
                else
                    throw new Error("unknown remote type");
            });
        }
        return recurse(remote);
    }

    function mockRemote({ api, appId, origin, apiLink, latency, storage, }) {
        const { shape, installAuthMediator } = prepareApiShape({
            appId,
            storage,
        });
        const remote = logAllCalls({
            // logger: new DisabledLogger(),
            logger: console,
            fullyDebug: false,
            remote: addMockLatency({
                latency,
                remote: loopbackJsonRemote({
                    shape,
                    link: apiLink,
                    headers: { origin },
                    servelet: makeJsonHttpServelet(api, noServeletLogger()),
                }),
            }),
        });
        const authMediator = installAuthMediator({
            greenService: remote.auth.greenService,
        });
        return { remote, authMediator };
    }

    function wireMediatorBroadcastChannel(authMediator) {
        const channel = new BroadcastChannel("tokenChangeEvent");
        authMediator.subscribeToTokenChange(() => channel.postMessage(undefined));
        channel.onmessage = () => authMediator.initialize();
    }

    async function mockWiredRemote({ apiLink, appId, storage, latency, appWindowLink, backend, }) {
        const { remote, authMediator } = mockRemote({
            appId,
            apiLink,
            storage,
            latency,
            api: backend.api,
            origin: new URL(appWindowLink).origin,
        });
        wireMediatorBroadcastChannel(authMediator);
        return { remote, authMediator };
    }

    function asApi(api) {
        return api;
    }

    const tokenize = (object) => (url$1.encode(JSON.stringify(object)));
    function mockSignToken() {
        return async ({ payload, lifespan, }) => {
            const data = {
                payload,
                iat: Date.now() / 1000,
                exp: (Date.now() + lifespan) / 1000,
            };
            const header = {
                alg: null,
                typ: "JWT",
            };
            const signature = "fake-mock-token-signature";
            return [
                tokenize(header),
                tokenize(data),
                tokenize(signature),
            ].join(".");
        };
    }

    const mockVerifyToken = () => async (token) => {
        const decoded = tokenDecode(token);
        const expiry = decoded.exp * 1000;
        if (Date.now() > expiry)
            throw new Error("token expired");
        return decoded.payload;
    };

    function and(...conditions) {
        return ["and", ...conditions];
    }
    function or(...conditions) {
        return ["or", ...conditions];
    }
    function find(...rows) {
        return rows.length
            ? { conditions: or(...rows.map(row => ({ equal: row }))) }
            : { conditions: false };
    }

    async function dbbyX(flexStorage, tableName) {
        const storageKey = `dbby-${tableName}`;
        let table = [];
        async function load() {
            table = await flexStorage.read(storageKey) || [];
        }
        await load();
        async function save() {
            if (flexStorage)
                await flexStorage.write(storageKey, table);
        }
        function select(conditional) {
            return table.filter(row => rowVersusConditional(row, conditional));
        }
        function selectOne(conditional) {
            return table.find(row => rowVersusConditional(row, conditional));
        }
        function updateRow(rows, update) {
            for (const row of rows) {
                for (const [key, value] of Object.entries(update)) {
                    row[key] = value;
                }
            }
        }
        function insertCopy(row) {
            table.push(copy(row));
        }
        function eliminateRow(conditional) {
            const flippedFilterRow = (row) => !rowVersusConditional(row, conditional);
            table = table.filter(flippedFilterRow);
        }
        return {
            async create(...rows) {
                await load();
                for (const row of rows)
                    insertCopy(row);
                await save();
            },
            async read({ order, offset = 0, limit = 1000, ...conditional }) {
                await load();
                const rows = copy(select(conditional));
                if (order) {
                    for (const [key, value] of Object.entries(order)) {
                        rows.sort((a, b) => value === "ascend"
                            ? a[key] > b[key] ? 1 : -1
                            : a[key] > b[key] ? -1 : 1);
                    }
                }
                return rows.slice(offset, offset + limit);
            },
            async one(conditional) {
                await load();
                return copy(selectOne(conditional));
            },
            async assert({ make, ...conditional }) {
                await load();
                let row = copy(selectOne(conditional));
                if (!row) {
                    const made = await make();
                    insertCopy(made);
                    row = copy(made);
                    await save();
                }
                return row;
            },
            async update({ write, whole, upsert, ...conditional }) {
                await load();
                const rows = select(conditional);
                if (write && rows.length) {
                    updateRow(rows, write);
                }
                else if (upsert) {
                    if (rows.length)
                        updateRow(rows, upsert);
                    else
                        insertCopy(upsert);
                }
                else if (whole) {
                    eliminateRow(conditional);
                    insertCopy(whole);
                }
                else
                    throw new Error("invalid update");
                await save();
            },
            async delete(conditional) {
                await load();
                eliminateRow(conditional);
                await save();
            },
            async count(conditional) {
                await load();
                return select(conditional).length;
            },
        };
    }
    function copy(x) {
        if (x === undefined)
            return undefined;
        return JSON.parse(JSON.stringify(x));
    }
    function compare(row, conditional, evaluator) {
        let failures = 0;
        for (const [key, value] of Object.entries(conditional)) {
            if (!evaluator(row[key], value))
                failures += 1;
        }
        return !failures;
    }
    function rowVersusConditional(row, conditional) {
        function crawl(conditions) {
            if (conditions === false)
                return true;
            const [operation, ...rawconds] = conditions;
            const conds = rawconds.filter(c => !!c);
            if (conds.length === 0)
                throw new Error("empty and/or conditions are not allowed");
            const and = operation === "and";
            let valid = and;
            const applyResult = (result) => valid = and
                ? valid && result
                : valid || result;
            for (const condition of conds) {
                if (condition === false || Array.isArray(condition)) {
                    applyResult(crawl(condition));
                }
                else {
                    const result = rowVersusCondition(row, condition);
                    applyResult(result);
                }
            }
            return valid;
        }
        return crawl(conditional.conditions);
    }
    function rowVersusCondition(row, condition) {
        if (!Object.keys(condition).length)
            return true;
        let failures = 0;
        const check = (conditions, evaluator) => {
            if (conditions && !compare(row, conditions, evaluator))
                failures += 1;
        };
        const checks = {
            set: a => a !== undefined && a !== null,
            equal: (a, b) => a === b,
            greater: (a, b) => a > b,
            greatery: (a, b) => a >= b,
            less: (a, b) => a < b,
            lessy: (a, b) => a <= b,
            listed: (a, b) => a.includes(b),
            search: (a, b) => typeof b === "string" ? a.includes(b) : b.test(a),
        };
        function not(evaluator) {
            return (a, b) => !evaluator(a, b);
        }
        check(condition.set, checks.set);
        check(condition.equal, checks.equal);
        check(condition.greater, checks.greater);
        check(condition.greatery, checks.greatery);
        check(condition.less, checks.less);
        check(condition.lessy, checks.lessy);
        check(condition.listed, checks.listed);
        check(condition.search, checks.search);
        check(condition.notSet, not(checks.set));
        check(condition.notEqual, not(checks.equal));
        check(condition.notGreater, not(checks.greater));
        check(condition.notGreatery, not(checks.greatery));
        check(condition.notLess, not(checks.less));
        check(condition.notLessy, not(checks.lessy));
        check(condition.notListed, not(checks.listed));
        check(condition.notSearch, not(checks.search));
        return !failures;
    }

    function isPlainObject(x) {
        return (typeof x === "object"
            && x !== null
            && !Array.isArray(x)
            && !(x instanceof Promise));
    }
    function unzipRecursive(object, path = []) {
        let spec = [];
        for (const [key, value] of Object.entries(object)) {
            if (isPlainObject(value))
                spec = [
                    ...spec,
                    ...unzipRecursive(value, [...path, key])
                ];
            else
                spec.push([[...path, key], value]);
        }
        return spec;
    }
    function unzip(object) {
        return unzipRecursive(object);
    }
    async function waitSpec(spec) {
        const paths = [];
        const awaitables = [];
        for (const [path, value] of spec) {
            paths.push(path);
            awaitables.push(value);
        }
        const values = await Promise.all(awaitables);
        return paths.map((path, index) => [path, values[index]]);
    }
    function applyProperty(object, path, value) {
        let level = object;
        for (let i = 0; i < path.length; i++) {
            const final = i === (path.length - 1);
            const key = path[i];
            const existing = level[key];
            if (final)
                level[key] = value;
            else {
                const existingIsObject = isPlainObject(existing);
                if (existingIsObject)
                    level = existing;
                else {
                    const next = {};
                    level[key] = next;
                    level = next;
                }
            }
        }
    }
    function zip(spec) {
        const result = {};
        for (const [path, value] of spec)
            applyProperty(result, path, value);
        return result;
    }
    async function waitForProperties(input) {
        const specWithPromises = unzip(input);
        const specWithValues = await waitSpec(specWithPromises);
        return zip(specWithValues);
    }

    const isNode = (typeof process !== "undefined")
        && (process?.release?.name === "node");

    function encodeHex(binary) {
        let result = "";
        for (const byte of new Uint8Array(binary))
            result += ("0" + (byte & 0xFF).toString(16)).slice(-2);
        return result;
    }

    const base42characters = "256789BCDFGHJKMNPRSTWXYZbcdfghkmnpqrstwxyz";
    function bigFromBinary(binary) {
        const hex = encodeHex(binary);
        return BigInt("0x" + hex);
    }
    function encodeBase42(binary) {
        const recurse = (value) => value < 42n
            ? base42characters[Number(value)]
            : recurse(value / 42n) + base42characters[Number(value % 42n)];
        const big = bigFromBinary(binary);
        return recurse(big);
    }

    function identifierFromBinary(binary) {
        let id = encodeBase42(binary);
        while (id.length < 48)
            id = base42characters[0] + id;
        return id;
    }

    async function getRando({ isNode: isNode$1 = isNode } = {}) {
        const randomBuffer = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (bytes) => crypto.randomBytes(bytes).buffer;
            })()
            : (bytes) => crypto.getRandomValues(new Uint8Array(bytes)).buffer;
        const compare = isNode$1
            ? await (async () => {
                const crypto = await import('crypto');
                return (a, b) => crypto.timingSafeEqual(Buffer.from(a, "utf8"), Buffer.from(b, "utf8"));
            })()
            : (a, b) => {
                console.warn("insecure compare");
                return a === b;
            };
        function random() {
            const buffer = randomBuffer(8);
            const ints = new Int8Array(buffer);
            ints[7] = 63;
            ints[6] |= 0xf0;
            const view = new DataView(buffer);
            return view.getFloat64(0, true) - 1;
        }
        function randomId() {
            const buffer = randomBuffer(32);
            return identifierFromBinary(buffer);
        }
        function randomSample(palette) {
            return palette[Math.floor(random() * palette.length)];
        }
        function randomSequence(length, palette) {
            const results = [];
            while (results.length < length) {
                const sample = randomSample(palette);
                results.push(sample);
            }
            return results.join("");
        }
        return {
            random,
            compare,
            randomId,
            randomBuffer,
            randomSample,
            randomSequence,
        };
    }

    function isFunction(value) {
        return typeof value === "function";
    }

    const _context = Symbol();

    const _descriptor = Symbol();

    function apiContext() {
        return function recurse({ expose, policy }) {
            return objectMap$1(expose, (value, key) => {
                if (isFunction(value))
                    return {
                        [_descriptor]: true,
                        policy,
                        func: value,
                    };
                else if (isObject(value))
                    return {
                        [_context]: true,
                        ...recurse({ policy, expose: value })
                    };
                else
                    throw new Error(`unknown api context subtype for "${key}"`);
            });
        };
    }

    function asTopic() {
        return function (topic) {
            return topic;
        };
    }

    function isPlatform(appId, config) {
        return config.platform.appDetails.appId === appId;
    }

    async function concurrent(obj) {
        const keys = Object.keys(obj);
        const awaitables = Object.values(obj);
        const values = await Promise.all(awaitables);
        const result = {};
        keys.forEach((key, i) => result[key] = values[i]);
        return result;
    }

    function validator$1(...conditions) {
        return value => {
            const problems = [];
            for (const condition of conditions) {
                for (const problem of condition(value))
                    problems.push(problem);
            }
            return problems;
        };
    }
    function schema(schematic) {
        const schematicKeys = Object.keys(schematic);
        return object => (Object.entries(object).flatMap(([key, value]) => schematicKeys.includes(key)
            ? schematic[key](value)
                .map(problem => `"${key}": ${problem}`)
            : [`"${key} not in schema"`]));
    }
    function branch(...conditions) {
        return value => {
            const results = conditions.map(condition => condition(value));
            let anySuccess = false;
            for (const problems of results)
                if (problems.length === 0)
                    anySuccess = true;
            return anySuccess
                ? []
                : results.flat()
                    .map((problem, index) => index > 0 ? `or, ${problem}` : problem);
        };
    }
    function one(...conditions) {
        return value => {
            let problems = [];
            for (const condition of conditions) {
                problems = condition(value);
                if (problems.length > 0)
                    break;
            }
            return problems;
        };
    }
    function each(...conditions) {
        return arr => {
            if (!Array.isArray(arr))
                return ["must be array"];
            const validate = validator$1(...conditions);
            const problems = [];
            arr.forEach((item, index) => {
                for (const problem of validate(item))
                    problems.push(`(${index + 1}) ${problem}`);
            });
            return problems;
        };
    }
    const notDefined = () => value => typeof value !== undefined
        ? ["must be undefined or null"]
        : [];
    const string = () => value => typeof value !== "string"
        ? ["must be a string"]
        : [];
    const number = () => value => typeof value !== "number"
        ? ["must be a number"]
        : [];
    const boolean = () => value => typeof value !== "boolean"
        ? ["must be a boolean"]
        : [];
    const array = () => value => Array.isArray(value)
        ? []
        : ["must be an array"];
    const length = (len) => value => value.length !== len
        ? [`length must be ${len}`]
        : [];
    const minLength = (min) => value => value.length < min
        ? ["too small"]
        : [];
    const maxLength = (max) => value => value.length > max
        ? ["too big"]
        : [];
    const notWhitespace = () => value => value.length > 0 && value.trim().length === 0
        ? ["can't be all whitespace"]
        : [];
    const url = () => value => {
        try {
            void new URL(value);
            return [];
        }
        catch (error) {
            return ["invalid url"];
        }
    };
    const localhost = () => value => {
        return /^https?:\/\/(127\.0\.0\.1|localhost)(|:\d{1,5})(|\/\S*)$/i.test(value)
            ? []
            : ["must be a localhost address"];
    };
    const https = () => value => {
        return /^https:\/\//i.test(value)
            ? []
            : ["must be secure, starting with 'https'"];
    };
    const origin = () => value => /^https?:\/\/[a-zA-Z\.\d-]+(?:|:\d+)$/i.test(value)
        ? []
        : ["invalid origin"];
    const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const email = () => value => emailRegex.test(value)
        ? []
        : ["invalid email"];
    // const labelValidator = validator<string>(string(), minLength(1), maxLength(50), notWhitespace())
    // const problems = labelValidator("hello")
    // const problems2 = validator<string[]>(array(string()))

    const validateAppOrigin = one(string(), maxLength(1000), origin(), branch(https(), localhost()));
    const appDraftValidators = Object.freeze({
        home: validator$1(one(string(), minLength(1), maxLength(2000), branch(one(url(), https()), localhost()))),
        label: validator$1(one(string(), minLength(1), maxLength(50), notWhitespace())),
        origins: validator$1(one(minLength(1), maxLength(100), each(validateAppOrigin))),
        additionalOrigins: validator$1(one(array(), minLength(0), maxLength(99), each(validateAppOrigin))),
    });

    const validator = schema({
        home: appDraftValidators.home,
        label: appDraftValidators.label,
        origins: appDraftValidators.origins,
    });
    function validateAppDraft(appDraft) {
        return validator(appDraft);
    }

    function escapeRegex(subject) {
        return subject.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }

    function originsToDatabase(origins) {
        return origins.join(";");
    }

    function originsFromDatabase(origins) {
        return origins.split(";");
    }

    function throwProblems(problems) {
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
    }

    const appTopic = ({ rando, config, }) => asTopic()({
        async listApps({ tables, statsHub }, { ownerUserId }) {
            const ownerships = await tables.app.appOwnership.read(find({ userId: ownerUserId }));
            const appRows = ownerships.length
                ? await tables.app.app.read({
                    conditions: and(or(...ownerships.map(own => ({ equal: { appId: own.appId } }))), { equal: { archived: false } })
                })
                : [];
            return Promise.all(appRows.map(async (row) => ({
                appId: row.appId,
                label: row.label,
                home: row.home,
                origins: originsFromDatabase(row.origins),
                platform: isPlatform(row.appId, config),
                stats: await concurrent({
                    users: statsHub.countUsers(row.appId),
                    usersActiveDaily: statsHub.countUsersActiveDaily(row.appId),
                    usersActiveMonthly: statsHub.countUsersActiveMonthly(row.appId),
                }),
            })));
        },
        async registerApp({ tables }, { appDraft, ownerUserId }) {
            throwProblems(validateAppDraft(appDraft));
            const appId = rando.randomId();
            await Promise.all([
                tables.app.app.create({
                    appId,
                    label: appDraft.label,
                    home: appDraft.home,
                    origins: originsToDatabase(appDraft.origins),
                    archived: false,
                }),
                tables.app.appOwnership.create({
                    appId,
                    userId: ownerUserId,
                }),
            ]);
            return {
                ...appDraft,
                appId,
                stats: {
                    users: 1,
                    usersActiveDaily: 0,
                    usersActiveMonthly: 0,
                },
            };
        },
    });

    const profileFromRow = ({ avatar, tagline, nickname, }) => ({
        tagline,
        nickname,
        avatar: JSON.parse(avatar),
    });

    async function fetchUsers({ userIds, authTables, permissionsEngine }) {
        if (!userIds.length)
            throw new Error("invalid: userIds cannot be empty");
        const conditions = or(...userIds.map(userId => ({ equal: { userId } })));
        const accounts = await authTables.user.account.read({ conditions });
        const profiles = await authTables.user.profile.read({ conditions });
        const publicRolesForUsers = await permissionsEngine.getPublicRolesForUsers(userIds);
        function assembleDetailsForEachUser(userId) {
            const account = accounts.find(a => a.userId === userId);
            const profile = profiles.find(p => p.userId === userId);
            if (!account)
                throw new ApiError(404, `account not found for user id ${userId}`);
            if (!profile)
                throw new ApiError(404, `profile not found for user id ${userId}`);
            const roles = publicRolesForUsers
                .find(r => r.userId === userId)
                .publicUserRoles;
            const stats = {
                joined: account.created,
            };
            return {
                userId,
                profile: profileFromRow(profile),
                roles,
                stats,
            };
        }
        return userIds.map(assembleDetailsForEachUser);
    }

    async function fetchUser({ userId, ...options }) {
        const results = await fetchUsers({ ...options, userIds: [userId] });
        return results.find(r => r.userId);
    }

    function merge(newItems, oldItems, compare) {
        const result = [...newItems];
        for (const oldItem of oldItems) {
            const included = !!result.find(newItem => compare(newItem, oldItem));
            if (!included)
                result.push(oldItem);
        }
        return result;
    }

    function asPermissions(permissions) {
        return permissions;
    }
    function has(privileges, hasPrivilege) {
        const hasPrivileges = {};
        for (const key of Object.keys(privileges))
            hasPrivileges[key] = hasPrivilege;
        return hasPrivileges;
    }
    function mutable(active, privileges) {
        return has(privileges, { active, immutable: false });
    }
    function immutable(active, privileges) {
        return has(privileges, { active, immutable: true });
    }

    const commonPrivileges = {
        "read questions": "22M8Tcp2xMg9hN5YxKkbffXpNHScTCnPXSXztzRnPXbC9RsD",
        "post questions": "75KrRyRPRnZZZKrh2zcwB98MCsZX9HCwg66qrzYTSprdqSTf",
        "like questions": "8qpc7M8nGkscwcSSW8d6Z7FyKGsxB8W5PWt2PCzk2sSJGgYb",
        "report questions": "86qRZfryfMWSfRhmkWkpq6pRYWCybmyNsD8RfxS7RpTqXN9J",
    };
    const commonPowerPrivileges = {
        "edit any profile": "2Z5M2n7pg9nRhwztgqztK6rBTPnyfr6fxk6T29sdfRTNGTqp",
        "customize permissions": "5Y5sBg2JtqqWnPXq5xXYRDB2cFygtc9StwN7GSZsBXzDBNNW",
        "moderate questions": "5dHqPzNHGsYnbqkF252ZhWS25hwCGrBSS67RBpmfm7by9dGF",
        "view stats": "2DWWssJp7G88kH9swMPxSZ529mXqn6kFM7zFMS9yn5P5RkGZ",
        "administrate user roles": "6HpSB2ZGcCsDGwHHmHKZCqYgpPxSg5kyw8PYtx5R2m6zBxmt",
    };
    const platformPowerPrivileges = {
        "edit any app": "77nZH9ksyDDBf6ptNZ9MNZzJdfMyWfG5PYbYwmmX6kTGMhkw",
        "view platform stats": "2nth28xGTC6TbPNzCHf72pRchr8FpPyDbwMRTnTsppPk9DC8",
    };
    const appPowerPrivileges = {
        "manage store": "658Kh8yMybF8hNr55JGkbCYtwyJpFd6MfRhFPcYdGskbtbzG",
        "give away freebies": "8R5fFWCJy8PMDJsPNkn8HqzpMGHBkMMfXz9HCzx7XdnrcKzJ",
    };
    const active = true;
    const INACTIVE = false;
    const universalPermissions = asPermissions({
        privileges: {
            ...commonPrivileges,
            ...commonPowerPrivileges,
            "banned": "5BrX6GbqgzDnhsTGsX6xxqsxNSNdC2RzFZzntNXdGc7bmmkK",
        },
        roles: {
            "anonymous": {
                roleId: "2tcdnygHqf9YXdtXWnk5hrzTWH5z9ynp6S8SFHXgdd67THDS",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "banned": { active: false, immutable: true },
                    "read questions": { active: true, immutable: false },
                },
            },
            "authenticated": {
                roleId: "2NJPCdCByYJ9N2yPmY6TNypCbksyMwDhKtfhNKXRdsRPCMDK",
                public: false,
                assignable: false,
                hasPrivileges: {
                    ...mutable(active, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "banned": { active: false, immutable: true },
                },
            },
            "banned": {
                roleId: "8FN9yGdMCBptMMCqHTHSJJ6PHtwpBWmtdPGGDzbTKCqdzsHC",
                public: true,
                assignable: true,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "banned": { active: true, immutable: true },
                },
            },
            "technician": {
                roleId: "9DTMZY2NJm9HXMS7Tc2MYBf5HqcKWD98yNdZFNPrRhtb6yFq",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "banned": { active: false, immutable: true },
                },
            },
        },
    });
    const platformPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...platformPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "anonymous": {
                ...universalPermissions.roles.anonymous,
                hasPrivileges: {
                    ...universalPermissions.roles.anonymous.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, platformPowerPrivileges),
                },
            },
        },
    });
    const appPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...appPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "anonymous": {
                ...universalPermissions.roles.anonymous,
                hasPrivileges: {
                    ...universalPermissions.roles.anonymous.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "admin": {
                roleId: "7KWz2MKkFynJ5FNBG86tChyXwGDkpBZcdJxCxpkmhrmnScqm",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, appPowerPrivileges),
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "banned": { active: false, immutable: true },
                },
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, appPowerPrivileges),
                },
            },
        },
    });

    function permissionsMergingFacility({ isPlatform }) {
        const hardPermissions = isPlatform
            ? platformPermissions
            : appPermissions;
        function getHardPrivilegeDetails(...roleIds) {
            const results = [];
            for (const roleId of roleIds) {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role2]) => role2.roleId === roleId);
                if (found) {
                    const [, role] = found;
                    for (const [label, has] of Object.entries(role.hasPrivileges)) {
                        const privilegeId = hardPermissions.privileges[label];
                        const already = results.find(detail => detail.roleId === roleId &&
                            detail.privilegeId === privilegeId);
                        if (!already) {
                            results.push({
                                privilegeId,
                                roleId,
                                active: has.active,
                                immutable: has.immutable,
                            });
                        }
                    }
                }
            }
            return results;
        }
        function mergeRoleHasPrivileges({ hard, soft }) {
            const results = [];
            function rowMatch(hardy, softy) {
                return hardy.roleId === softy.roleId
                    && hardy.privilegeId === softy.privilegeId;
            }
            function toSofty(hardy) {
                return {
                    roleId: hardy.roleId,
                    privilegeId: hardy.privilegeId,
                    active: hardy.active,
                    immutable: hardy.immutable,
                };
            }
            for (const softy of soft) {
                const hardy = hard.find(h => rowMatch(h, softy));
                results.push(hardy && hardy.immutable
                    ? toSofty(hardy)
                    : softy);
            }
            for (const hardy of hard) {
                const alreadyIncluded = !!results.find(softy => rowMatch(hardy, softy));
                if (!alreadyIncluded)
                    results.push(toSofty(hardy));
            }
            return results;
        }
        function getActivePrivilegeIds(roleHasPrivileges) {
            return roleHasPrivileges
                .filter(row => row.active)
                .map(row => row.privilegeId);
        }
        return {
            hardPermissions,
            mergeRoleHasPrivileges,
            getActivePrivilegeIds,
            getHardPrivilegeDetails,
        };
    }

    function isCurrentlyWithinTimeframe({ timeframeStart, timeframeEnd }) {
        const time = Date.now();
        const tooEarly = timeframeStart !== undefined
            ? time > timeframeStart
            : false;
        const tooLate = timeframeEnd !== undefined
            ? time < timeframeEnd
            : false;
        return !tooEarly && !tooLate;
    }

    function makePermissionsEngine({ isPlatform, permissionsTables }) {
        const { hardPermissions, mergeRoleHasPrivileges, getActivePrivilegeIds, getHardPrivilegeDetails, } = permissionsMergingFacility({ isPlatform });
        async function getAnonymousPrivileges() {
            const roleId = hardPermissions.roles.anonymous.roleId;
            const hard = getHardPrivilegeDetails(roleId);
            const soft = await permissionsTables.roleHasPrivilege
                .read(find({ roleId }));
            return getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }));
        }
        async function getUsersHaveRoles({ userIds, onlyGetPublicRoles }) {
            const isPublic = (row) => row.public;
            const all = (x) => x;
            const usersHaveRoles = await (async () => {
                if (userIds.length === 0)
                    throw new Error("invalid: user ids cannot be empty");
                const usersHaveRolesRaw = await permissionsTables.userHasRole.read({
                    conditions: or(...userIds.map(userId => ({ equal: { userId } })))
                });
                const roleIds = usersHaveRolesRaw.map(u => u.roleId);
                if (userIds.length === 0)
                    throw new Error("invalid: role ids cannot be empty");
                const roles = await permissionsTables.role.read({
                    conditions: or(...roleIds.map(roleId => ({ equal: { roleId } })))
                });
                const roleIdsThatActuallyExist = [
                    ...roles.map(r => r.roleId),
                    ...Object.entries(hardPermissions.roles)
                        .map(([, role]) => role.roleId),
                ];
                return usersHaveRolesRaw
                    .filter(u => roleIdsThatActuallyExist.includes(u.roleId));
            })();
            return userIds.map(userId => {
                const raw = usersHaveRoles.filter(r => r.userId === userId);
                const userHasRoles = raw
                    .filter(isCurrentlyWithinTimeframe)
                    .filter(onlyGetPublicRoles ? isPublic : all);
                return { userId, userHasRoles };
            });
        }
        async function getPrivilegesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: false,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles.map(r2 => r2.roleId));
            const allRolesHavePrivileges = allRoleIds.length
                ? await permissionsTables.roleHasPrivilege.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: ({ roleId }) })))
                })
                : [];
            function resolvePrivilegesForEachUser(userId) {
                const roleIds = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles
                    .map(r => r.roleId);
                // roleIds.push(universalPermissions.roles.authenticated.roleId)
                const hard = getHardPrivilegeDetails(...roleIds);
                const soft = roleIds
                    .flatMap(roleId => allRolesHavePrivileges.filter(p => p.roleId === roleId));
                const privileges = getActivePrivilegeIds(mergeRoleHasPrivileges({ hard, soft }));
                return { userId, privileges };
            }
            return userIds.map(resolvePrivilegesForEachUser);
        }
        async function getPublicRolesForUsers(userIds) {
            const rolesForUsers = await getUsersHaveRoles({
                userIds,
                onlyGetPublicRoles: true,
            });
            const allRoleIds = rolesForUsers
                .flatMap(r => r.userHasRoles
                .filter(r2 => r2.public)
                .map(r2 => r2.roleId));
            const allHardRoles = allRoleIds.map(roleId => {
                const found = Object.entries(hardPermissions.roles)
                    .find(([, role]) => role.roleId === roleId);
                if (found) {
                    const [label, role] = found;
                    return {
                        roleId,
                        label,
                        hard: true,
                        public: role.public,
                        assignable: role.assignable,
                    };
                }
                else {
                    return undefined;
                }
            }).filter(r => !!r);
            const allSoftRoles = allRoleIds.length
                ? await permissionsTables.role.read({
                    conditions: or(...allRoleIds.map(roleId => ({ equal: { roleId } })))
                })
                : [];
            const mergedRoles = [...allHardRoles];
            for (const role of allSoftRoles) {
                const found = mergedRoles.find(r => r.roleId === role.roleId);
                if (!found)
                    mergedRoles.push(role);
            }
            function assemblePublicRolesForEachUser(userId) {
                const userHasRoles = rolesForUsers
                    .find(r => r.userId === userId)
                    .userHasRoles;
                const publicUserRoles = userHasRoles
                    .map(userHasRole => {
                    const roleRow = mergedRoles.find(row => row.roleId === userHasRole.roleId);
                    return { ...userHasRole, ...roleRow };
                })
                    .filter(isCurrentlyWithinTimeframe)
                    .map(r => ({
                    label: r.label,
                    roleId: r.roleId,
                    timeframeEnd: r.timeframeEnd,
                    timeframeStart: r.timeframeStart,
                }));
                return { userId, publicUserRoles };
            }
            return userIds.map(assemblePublicRolesForEachUser);
        }
        async function getPermissionsDisplay() {
            const all = { conditions: false };
            return concurrent({
                roles: (async () => {
                    const soft = await permissionsTables.role.read(all);
                    const hard = Object.entries(hardPermissions.roles)
                        .map(([label, r]) => ({
                        label,
                        hard: true,
                        roleId: r.roleId,
                        public: r.public,
                        assignable: r.assignable,
                    }));
                    return merge(soft, hard, (a, b) => a.roleId === b.roleId);
                })(),
                privileges: (async () => {
                    const soft = await permissionsTables.privilege.read(all);
                    const hard = Object.entries(hardPermissions.privileges)
                        .map(([label, privilegeId]) => ({ privilegeId, label, hard: true }));
                    return merge(soft, hard, (a, b) => a.privilegeId === b.privilegeId);
                })(),
                rolesHavePrivileges: (async () => {
                    const roleIds = Object.values(hardPermissions.roles)
                        .map(role => role.roleId);
                    const hard = getHardPrivilegeDetails(...roleIds);
                    const soft = await permissionsTables.roleHasPrivilege.read(all);
                    return mergeRoleHasPrivileges({ hard, soft });
                })(),
            });
        }
        async function getUserPrivileges(userId) {
            const result = await getPrivilegesForUsers([userId]);
            return result
                .find(r => r.userId === userId)
                .privileges;
        }
        // async function getUserPublicRoles(userId: string) {
        // 	const result = await getPublicRolesForUsers([userId])
        // 	return result
        // 		.find(r => r.userId === userId)
        // 		.publicUserRoles
        // }
        return {
            getUsersHaveRoles,
            getAnonymousPrivileges,
            getPrivilegesForUsers,
            getPublicRolesForUsers,
            getPermissionsDisplay,
            getUserPrivileges,
        };
    }

    const userTopic = ({ config }) => asTopic()({
        async getUser({ tables, access }, { userId }) {
            const permissionsEngine = makePermissionsEngine({
                isPlatform: access.appId === config.platform.appDetails.appId,
                permissionsTables: tables.permissions,
            });
            return await fetchUser({ userId, authTables: tables, permissionsEngine });
        },
    });

    async function signAuthTokens({ scope, appId, userId, tables, origins, lifespans, permissionsEngine, signToken, generateNickname, }) {
        const { user, permit } = await concurrent({
            user: fetchUser({ userId, authTables: tables, permissionsEngine }),
            permit: (async () => ({
                privileges: await permissionsEngine.getUserPrivileges(userId),
            }))(),
        });
        return concurrent({
            accessToken: signToken({
                payload: { appId, origins, user, permit, scope },
                lifespan: lifespans.access,
            }),
            refreshToken: signToken({
                payload: { userId: user.userId },
                lifespan: lifespans.refresh,
            }),
        });
    }

    function generateAccountRow({ rando }) {
        return {
            userId: rando.randomId(),
            created: Date.now(),
        };
    }

    const generateProfileRow = ({ userId, avatar, generateNickname }) => ({
        userId,
        avatar,
        tagline: "",
        nickname: generateNickname(),
    });

    function randomXioAvatarSimpleSpec() {
        return {
            type: "simple",
            value: Math.random(),
        };
    }

    async function initializeUserProfile({ userId, authTables, email, generateNickname }) {
        const avatar = JSON.stringify(randomXioAvatarSimpleSpec());
        await authTables.user.profile.create(generateProfileRow({
            userId,
            avatar,
            generateNickname,
        }));
    }

    const standardRoleIds = {
        anonymous: universalPermissions.roles.anonymous.roleId,
        authenticated: universalPermissions.roles.authenticated.roleId,
        technician: universalPermissions.roles.technician.roleId,
    };
    async function assertEmailAccount({ rando, email, tables, config, generateNickname, }) {
        const { userId } = await tables.user.accountViaEmail.assert({
            ...find({ email }),
            make: async function makeNewAccountViaEmail() {
                const isTechnician = email === config.platform.technician.email;
                const account = generateAccountRow({ rando });
                const { userId } = account;
                const createAccount = tables.user.account.create(account);
                const createProfile = initializeUserProfile({
                    userId,
                    email,
                    authTables: tables,
                    generateNickname,
                });
                const assignAnonymous = tables.permissions.userHasRole.create({
                    userId,
                    hard: true,
                    public: false,
                    roleId: standardRoleIds.anonymous,
                    timeframeEnd: undefined,
                    timeframeStart: undefined,
                });
                const assignAuthenticated = tables.permissions.userHasRole.create({
                    userId,
                    hard: true,
                    public: false,
                    roleId: standardRoleIds.authenticated,
                    timeframeEnd: undefined,
                    timeframeStart: undefined,
                });
                const assignTechnician = isTechnician
                    ? tables.permissions.userHasRole.create({
                        userId,
                        hard: true,
                        public: true,
                        timeframeEnd: undefined,
                        roleId: standardRoleIds.technician,
                        timeframeStart: undefined,
                    })
                    : Promise.resolve();
                await Promise.all([
                    createAccount,
                    createProfile,
                    assignAnonymous,
                    assignAuthenticated,
                    assignTechnician,
                ]);
                return { email, userId };
            },
        });
        return { userId };
    }

    const loginTopic = ({ rando, config, signToken, verifyToken, sendLoginEmail, generateNickname, }) => asTopic()({
        async sendLoginLink({ access, tables }, { email }) {
            const appRow = await tables.app.app.one(find({ appId: access.appId }));
            const { userId } = await assertEmailAccount({
                rando, email, config, tables, generateNickname,
            });
            await sendLoginEmail({
                appHome: appRow.home,
                appLabel: appRow.label,
                to: email,
                legalLink: config.platform.legalLink,
                platformLink: config.platform.appDetails.home,
                lifespan: config.crypto.tokenLifespans.login,
                loginToken: await signToken({
                    payload: { userId },
                    lifespan: config.crypto.tokenLifespans.login,
                }),
            });
        },
        async authenticateViaLoginToken({ tables, access }, { loginToken }) {
            const { userId } = await verifyToken(loginToken);
            const authTokens = await signAuthTokens({
                userId,
                tables,
                scope: { core: true },
                appId: access.appId,
                origins: access.origins,
                lifespans: config.crypto.tokenLifespans,
                permissionsEngine: makePermissionsEngine({
                    isPlatform: access.appId === config.platform.appDetails.appId,
                    permissionsTables: tables.permissions,
                }),
                signToken,
                generateNickname,
            });
            await tables.user.latestLogin.update({
                ...find({ userId }),
                upsert: { userId, time: Date.now() },
            });
            return authTokens;
        },
        // async authorizeAsUser(
        // 		{access, tables},
        // 		{scope, refreshToken}: {
        // 			scope: Scope
        // 			refreshToken: RefreshToken
        // 		}
        // 	) {
        // 	const {userId} = await verifyToken<RefreshPayload>(refreshToken)
        // 	const {user, permit} = await fetchUserAndPermit({
        // 		userId,
        // 		tables,
        // 		generateNickname,
        // 	})
        // 	await tables.user.latestLogin.update({
        // 		...find({userId}),
        // 		upsert: {userId, time: Date.now()},
        // 	})
        // 	return signToken<AccessPayload>({
        // 		lifespan: config.tokens.lifespans.access,
        // 		payload: {
        // 			user,
        // 			scope,
        // 			permit,
        // 			appId: access.appId,
        // 			origins: access.origins,
        // 		},
        // 	})
        // },
    });

    const profileValidators = {
        nickname: one(string(), minLength(1), maxLength(24), notWhitespace()),
        tagline: one(string(), minLength(0), maxLength(32), notWhitespace()),
    };
    const validateProfileDraft = schema({
        ...profileValidators,
    });

    const personalTopic = ({ config }) => asTopic()({
        async setProfile({ access, tables, checker }, { userId, profileDraft }) {
            const isProfileOwner = access.user.userId === userId;
            const canEditAnyProfile = checker.hasPrivilege("edit any profile");
            const allowed = isProfileOwner || canEditAnyProfile;
            if (!allowed)
                throw new ApiError(403, "forbidden: you are not allowed to edit this profile");
            throwProblems(validateProfileDraft(profileDraft));
            await tables.user.profile.update({
                ...find({ userId }),
                write: {
                    nickname: profileDraft.nickname,
                    tagline: profileDraft.tagline,
                },
            });
        },
    });

    const greenTopic = ({ config, signToken, verifyToken, }) => asTopic()({
        async authorize({ bakeTables }, { appId, scope, refreshToken }) {
            const tables = await bakeTables(appId);
            const permissionsEngine = makePermissionsEngine({
                isPlatform: appId === config.platform.appDetails.appId,
                permissionsTables: tables.permissions,
            });
            const appRow = await tables.app.app.one(find({ appId }));
            if (!appRow)
                throw new ApiError(400, "incorrect app id");
            if (appRow.archived)
                throw new ApiError(403, "app has been archived");
            if (refreshToken) {
                const { userId } = await verifyToken(refreshToken);
                const user = await fetchUser({
                    userId,
                    permissionsEngine,
                    authTables: tables,
                });
                await tables.user.latestLogin.update({
                    ...find({ userId }),
                    upsert: { userId, time: Date.now() },
                });
                const privileges = await permissionsEngine.getUserPrivileges(userId);
                return signToken({
                    lifespan: config.crypto.tokenLifespans.access,
                    payload: {
                        user,
                        scope,
                        permit: { privileges },
                        appId: appId,
                        origins: originsFromDatabase(appRow.origins),
                    },
                });
            }
            else {
                const privileges = await permissionsEngine.getAnonymousPrivileges();
                return signToken({
                    lifespan: config.crypto.tokenLifespans.access,
                    payload: {
                        user: undefined,
                        appId,
                        scope,
                        origins: originsFromDatabase(appRow.origins),
                        permit: { privileges },
                    },
                });
            }
        },
    });

    async function fetchPermissionsDisplay({ config, access, permissionsTables, }) {
        const permissionsEngine = makePermissionsEngine({
            permissionsTables,
            isPlatform: access.appId === config.platform.appDetails.appId,
        });
        return permissionsEngine.getPermissionsDisplay();
    }

    const roleLabelValidator = one(string(), minLength(1), maxLength(16), notWhitespace());

    const permissionsTopic = ({ config, rando }) => asTopic()({
        async fetchPermissions({ tables, access }) {
            return fetchPermissionsDisplay({
                config,
                access,
                permissionsTables: tables.permissions,
            });
        },
        async createRole({ tables }, { label }) {
            const problems = roleLabelValidator(label);
            if (problems.length)
                throw new ApiError(400, `validation error on label: ${problems.join("; ")}`);
            await tables.permissions.role.create({
                label,
                hard: false,
                public: true,
                assignable: true,
                roleId: rando.randomId(),
            });
        },
        async deleteRole({ tables }, { roleId }) {
            const role = await tables.permissions.role.one(find({ roleId }));
            if (!role)
                throw new ApiError(404, "role not found");
            if (role.hard)
                throw new ApiError(400, "cannot delete hard role");
            await Promise.all([
                tables.permissions.userHasRole.delete(find({ roleId })),
                tables.permissions.role.delete(find({ roleId })),
            ]);
        },
        async assignPrivilege({ tables }, { roleId, privilegeId }) {
            await tables.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: true,
                    immutable: false,
                },
            });
        },
        async unassignPrivilege({ tables }, { roleId, privilegeId }) {
            await tables.permissions.roleHasPrivilege.update({
                ...find({ roleId, privilegeId }),
                upsert: {
                    roleId,
                    privilegeId,
                    active: false,
                    immutable: false,
                },
            });
        },
    });

    const adminRoleId$1 = appPermissions.roles.admin.roleId;
    async function appointAdmin({ email, tablesForApp, rando, config, generateNickname, }) {
        const { userId: adminUserId } = await assertEmailAccount({
            rando,
            email,
            config,
            tables: tablesForApp,
            generateNickname,
        });
        await tablesForApp.permissions.userHasRole.assert({
            ...find({ userId: adminUserId, roleId: adminRoleId$1 }),
            make: async () => ({
                userId: adminUserId,
                roleId: adminRoleId$1,
                hard: false,
                public: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
            })
        });
    }

    const emailValidator = validator$1(one(string(), maxLength(256), email()));

    const adminRoleId = appPermissions.roles.admin.roleId;
    const manageAdminsTopic = ({ rando, config, generateNickname, }) => asTopic()({
        async listAdmins(auth, { appId }) {
            const tablesForApp = await auth.getTablesNamespacedForApp(appId);
            const usersWithAdminRole = await tablesForApp.permissions.userHasRole
                .read(find({ roleId: adminRoleId }));
            const adminsViaEmail = await tablesForApp.user.accountViaEmail
                .read(find(...usersWithAdminRole.map(({ userId }) => ({ userId }))));
            return adminsViaEmail.map(({ userId, email }) => ({
                userId,
                email,
            }));
        },
        async assignPlatformUserAsAdmin(auth, { appId, platformUserId }) {
            const tablesForPlatform = auth.tables;
            const tablesForApp = await auth.getTablesNamespacedForApp(appId);
            const platformAccount = await tablesForPlatform.user.accountViaEmail
                .one(find({ userId: platformUserId }));
            if (!platformAccount)
                throw new ApiError(404, "platform email account not found");
            const { email } = platformAccount;
            await appointAdmin({
                rando,
                config,
                email,
                tablesForApp,
                generateNickname,
            });
        },
        async assignAdmin(auth, { appId, email }) {
            const tablesForApp = await auth.getTablesNamespacedForApp(appId);
            const problems = emailValidator(email);
            if (problems.length)
                throw new ApiError(400, "email failed validation: " + problems.join(";"));
            await appointAdmin({
                rando,
                config,
                email,
                tablesForApp,
                generateNickname,
            });
        },
        async revokeAdmin(auth, { appId, userId }) {
            const tablesForApp = await auth.getTablesNamespacedForApp(appId);
            await tablesForApp.permissions.userHasRole.delete(find({
                userId,
                roleId: adminRoleId,
            }));
        },
    });

    const appEditTopic = (options) => asTopic()({
        async updateApp({ tables, access }, { appId, appDraft }) {
            // await requireUserIsAllowedToEditApp({tables, access, appId})
            throwProblems(validateAppDraft(appDraft));
            await tables.app.app.update({
                ...find({ appId }),
                whole: {
                    appId,
                    home: appDraft.home,
                    label: appDraft.label,
                    origins: originsToDatabase(appDraft.origins),
                    archived: false,
                },
            });
        },
        async deleteApp({ tables, access }, { appId }) {
            // await requireUserIsAllowedToEditApp({tables, access, appId})
            await tables.app.app.update({
                ...find({ appId }),
                write: { archived: true },
            });
        },
    });

    const makeAuthApi = ({ tables, authPolicies, ...options }) => {
        return asApi({
            greenService: apiContext()({
                policy: authPolicies.green,
                expose: greenTopic(options),
            }),
            loginService: apiContext()({
                policy: authPolicies.anon,
                expose: loginTopic(options),
            }),
            appService: apiContext()({
                policy: authPolicies.platformUser,
                expose: appTopic(options),
            }),
            appEditService: apiContext()({
                policy: authPolicies.appOwner,
                expose: appEditTopic(),
            }),
            manageAdminsService: apiContext()({
                policy: authPolicies.appOwner,
                expose: manageAdminsTopic(options),
            }),
            personalService: apiContext()({
                policy: authPolicies.user,
                expose: personalTopic(options),
            }),
            userService: apiContext()({
                policy: authPolicies.anon,
                expose: userTopic(options),
            }),
            permissionsService: apiContext()({
                policy: authPolicies.userWhoManagesPermissions,
                expose: permissionsTopic(options),
            }),
        });
    };

    var Ops;
    (function (Ops) {
        (function (Mode) {
            Mode[Mode["None"] = 0] = "None";
            Mode[Mode["Loading"] = 1] = "Loading";
            Mode[Mode["Error"] = 2] = "Error";
            Mode[Mode["Ready"] = 3] = "Ready";
        })(Ops.Mode || (Ops.Mode = {}));
    })(Ops || (Ops = {}));
    const ops = {
        none: () => ({
            mode: Ops.Mode.None,
        }),
        loading: () => ({
            mode: Ops.Mode.Loading,
        }),
        error: (reason) => ({
            mode: Ops.Mode.Error,
            reason,
        }),
        ready: (value) => ({
            mode: Ops.Mode.Ready,
            value,
        }),
        replaceValue(op, value) {
            return op.mode === Ops.Mode.Ready
                ? { ...op, value }
                : op;
        },
        isNone: (op) => op.mode === Ops.Mode.Ready,
        isLoading: (op) => op.mode === Ops.Mode.Loading,
        isError: (op) => op.mode === Ops.Mode.Error,
        isReady: (op) => op.mode === Ops.Mode.Ready,
        value(op) {
            return op.mode === Ops.Mode.Ready
                ? op.value
                : undefined;
        },
        select(op, options) {
            switch (op.mode) {
                case Ops.Mode.None: return options.none();
                case Ops.Mode.Loading: return options.loading();
                case Ops.Mode.Error: return options.error(op.reason);
                case Ops.Mode.Ready: return options.ready(op.value);
            }
        },
        async operation({ promise, errorReason = "an error occurred", setOp, }) {
            setOp(ops.loading());
            try {
                const value = await promise;
                setOp(ops.ready(value));
                return value;
            }
            catch (error) {
                setOp(ops.error(errorReason));
                throw error;
            }
        },
        mode(op) {
            return ops.select(op, {
                none: () => "none",
                loading: () => "loading",
                error: () => "error",
                ready: () => "ready",
            });
        },
        debug(op) {
            return ops.select(op, {
                none: () => [`<op {mode: None}>`],
                loading: () => [`<op {mode: Loading}>`],
                error: reason => [`<op {mode: Error, reason: "${reason}"}>`],
                ready: value => [`<op {mode: Ready, value: `, value, `}>`],
            });
        },
    };

    function debounce2(delay, action) {
        let latestArgs;
        let timeout;
        return ((...args) => {
            latestArgs = args;
            if (!timeout) {
                const operation = () => {
                    action(...latestArgs);
                    timeout = undefined;
                };
                timeout = setTimeout(operation, delay);
            }
        });
    }
    function debounce3(delay, action) {
        let latestArgs;
        let timeout;
        let promise;
        let resolve;
        let reject;
        function reset() {
            latestArgs = undefined;
            timeout = undefined;
            promise = new Promise((res, rej) => {
                resolve = res;
                reject = rej;
            });
        }
        reset();
        return ((...args) => {
            latestArgs = args;
            if (!timeout) {
                const operation = () => {
                    timeout = undefined;
                    Promise.resolve(action(...latestArgs))
                        .then(r => {
                        if (!timeout)
                            resolve(r);
                    })
                        .catch(err => {
                        if (!timeout)
                            reject(err);
                    })
                        .finally(() => {
                        if (!timeout)
                            reset();
                    });
                };
                timeout = setTimeout(operation, delay);
            }
            return promise;
        });
    }

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    function deepFreeze(object) {
        Object.freeze(object);
        for (const value of Object.values(object)) {
            if (value && typeof value === "object")
                deepFreeze(value);
        }
        return object;
    }
    const isSet = (a) => (a !== null && a !== undefined);
    function deepEqual(a, b) {
        if (!isSet(a) || !isSet(b))
            return a === b;
        for (const [key, aValue] of Object.entries(a)) {
            if (!b.hasOwnProperty(key))
                return false;
            const bValue = b[key];
            switch (typeof aValue) {
                case "object":
                    if (!deepEqual(aValue, bValue))
                        return false;
                    break;
                case "function":
                    if (!isSet(bValue) || aValue.toString() !== bValue.toString())
                        return false;
                    break;
                default:
                    if (aValue !== bValue)
                        return false;
            }
        }
        for (const [key] of Object.entries(a))
            if (!b.hasOwnProperty(key))
                return false;
        for (const [key] of Object.entries(b))
            if (!a.hasOwnProperty(key))
                return false;
        return true;
    }

    function happystate({ state: realState, actions: makeActions, }) {
        let frozenState = deepFreeze(deepClone(realState));
        const actions = makeActions(realState);
        const { publish, subscribe: onStateChange, dispose: clearStateListeners, } = pubsub();
        const change = debounce2(1, publish);
        const augmentedActions = {};
        for (const [key, action] of Object.entries(actions)) {
            augmentedActions[key] = (...args) => {
                action(...args);
                frozenState = deepFreeze(deepClone(realState));
                change();
            };
        }
        return {
            actions: augmentedActions,
            onStateChange,
            clearStateListeners,
            getState: () => frozenState,
        };
    }

    function makeAppModel({ appService, appEditService, manageAdminsService, getAccess, }) {
        const { actions, getState, onStateChange } = happystate({
            state: {
                active: false,
                appRecords: ops.none(),
                addingNewApp: ops.none(),
                // loadingPromise: <Promise<void>>Promise.resolve(),
            },
            actions: state => ({
                setActive(active) {
                    state.active = active;
                },
                setAddingNewApp(op) {
                    state.addingNewApp = op;
                },
                // setLoadingPromise(promise: Promise<void>) {
                // 	state.loadingPromise = promise
                // },
                setAppRecords(op) {
                    const appList = ops.value(op) ?? [];
                    let records = {};
                    for (const app of appList)
                        records[app.appId] = ops.ready(app);
                    state.appRecords = ops.replaceValue(op, records);
                },
                setIndividualAppRecord(appId, op) {
                    if (ops.isLoading(state.appRecords))
                        throw new Error("cannot set individual app while apps are loading");
                    const apps = ops.value(state.appRecords) ?? {};
                    state.appRecords = ops.ready({ ...apps, [appId]: op });
                },
                deleteIndividualAppRecord(appId) {
                    if (ops.isReady(state.appRecords)) {
                        const existingRecords = ops.value(state.appRecords);
                        const records = {};
                        for (const [key, value] of Object.entries(existingRecords)) {
                            if (key !== appId)
                                records[key] = value;
                        }
                        state.appRecords = ops.ready(records);
                    }
                    else
                        throw new Error("cannot delete individual app while apps are loading");
                },
            }),
        });
        async function getUserId() {
            const access = await getAccess();
            return access?.user?.userId;
        }
        async function loadApps() {
            actions.setActive(true);
            const appsPromise = ops.operation({
                promise: (async () => {
                    const userId = await getUserId();
                    return userId
                        ? appService.listApps({ ownerUserId: userId })
                        : [];
                })(),
                setOp: op => actions.setAppRecords(op),
            });
            // actions.setLoadingPromise(appsPromise.then(() => undefined))
            return appsPromise;
        }
        async function registerApp(appDraft) {
            const userId = await getUserId();
            const result = await ops.operation({
                errorReason: "failed to register app",
                promise: (async () => {
                    const result = await appService.registerApp({
                        appDraft,
                        ownerUserId: userId,
                    });
                    await manageAdminsService.assignPlatformUserAsAdmin({
                        appId: result.appId,
                        platformUserId: userId,
                    });
                    return result;
                })(),
                setOp: op => {
                    actions.setAddingNewApp(ops.replaceValue(op, null));
                    if (ops.isReady(op)) {
                        const newApp = { ...ops.value(op), ...appDraft };
                        actions.setIndividualAppRecord(newApp.appId, ops.ready(newApp));
                    }
                },
            });
            return result;
        }
        async function updateApp(appId, appDraft) {
            const records = ops.value(getState().appRecords);
            if (!records)
                throw new Error("cannot update app while loading records");
            const existingApp = ops.value(records[appId]);
            if (!existingApp)
                throw new Error("cannot update app not present in records");
            return ops.operation({
                promise: appEditService.updateApp({ appId, appDraft }),
                setOp: op => actions.setIndividualAppRecord(appId, ops.replaceValue(op, { ...existingApp, ...appDraft })),
            });
        }
        function getApp(appId) {
            const records = ops.value(getState().appRecords);
            return records
                ? ops.value(records[appId])
                : undefined;
        }
        async function deleteApp(appId) {
            await ops.operation({
                promise: appEditService.deleteApp({ appId }),
                setOp: op => {
                    actions.setIndividualAppRecord(appId, ops.replaceValue(op, getApp(appId)));
                },
            });
            actions.deleteIndividualAppRecord(appId);
        }
        return {
            get state() { return getState(); },
            getApp(appId) {
                const records = ops.value(getState().appRecords);
                return records
                    ? ops.value(records[appId])
                    : undefined;
            },
            onStateChange,
            loadApps,
            deleteApp,
            updateApp,
            registerApp,
            manageAdminsService,
            async accessChange() {
                if (getState().active)
                    await loadApps();
            },
        };
    }
    // export function makeAppModel({
    // 		appService,
    // 		appEditService,
    // 		manageAdminsService,
    // 		getAccess,
    // 	}: AppModelOptions) {
    // 	const auto = autowatcher()
    // 	const state = auto.state({
    // 		active: false,
    // 		appList: <Op<AppDisplay[]>>ops.none(),
    // 	})
    // 	const actions = auto.actions({
    // 		setActive(active: boolean) {
    // 			state.active = active
    // 		},
    // 		setAppList(op: Op<AppDisplay[]>) {
    // 			state.appList = op
    // 		},
    // 	})
    // 	async function getUserId() {
    // 		const access = await getAccess()
    // 		return access?.user?.userId
    // 	}
    // 	async function appListOperation(promise: Promise<AppDisplay[]>) {
    // 		return ops.operation({
    // 			promise,
    // 			setOp: op => actions.setAppList(op),
    // 		})
    // 	}
    // 	async function loadAppList() {
    // 		actions.setActive(true)
    // 		return appListOperation((async() => {
    // 			const userId = await getUserId()
    // 			return userId
    // 				? appService.listApps({ownerUserId: userId})
    // 				: []
    // 		})())
    // 	}
    // 	async function loadingOperation<xResult>({errorReason, promise}: {
    // 			errorReason: string
    // 			promise: Promise<xResult>
    // 		}) {
    // 		let result: xResult
    // 		let error: any
    // 		await appListOperation((async() => {
    // 			try { result = await promise }
    // 			catch (err) { error = err }
    // 			return loadAppList()
    // 		})())
    // 		if (error) throw error
    // 		else return result
    // 	}
    // 	return {
    // 		track: auto.track,
    // 		manageAdminsService,
    // 		get appList() {
    // 			return state.appList
    // 		},
    // 		loadAppList,
    // 		async accessChange() {
    // 			if (state.active)
    // 				await loadAppList()
    // 		},
    // 		async registerApp(appDraft: AppDraft) {
    // 			const userId = await getUserId()
    // 			const result = await loadingOperation({
    // 				errorReason: "failed to register app",
    // 				promise: (async() => {
    // 					const result = await appService.registerApp({
    // 						appDraft,
    // 						ownerUserId: userId,
    // 					})
    // 					await manageAdminsService.assignPlatformUserAsAdmin({
    // 						appId: result.appId,
    // 						platformUserId: userId,
    // 					})
    // 					return result
    // 				})(),
    // 			})
    // 			return result
    // 		},
    // 		async updateApp(appId: string, appDraft: AppDraft) {
    // 			await loadingOperation({
    // 				errorReason: "failed to update app",
    // 				promise: appEditService.updateApp({
    // 					appId,
    // 					appDraft,
    // 				})
    // 			})
    // 		},
    // 		async deleteApp(appId: string) {
    // 			return loadingOperation({
    // 				errorReason: "failed to delete app",
    // 				promise: appEditService.deleteApp({appId}),
    // 			})
    // 		},
    // 	}
    // }

    class AutowatcherCircularError extends Error {
        constructor(scheduled) {
            super(`an effect changes an observable, named "${scheduled.key}", that triggers that same effect, causing an infinite circle`);
        }
    }
    class AutowatcherLeakError extends Error {
        constructor(key) {
            super(`cannot set observable, named "${key}", outside a formalized action`);
        }
    }

    function autowatcherCore() {
        const context = {
            observableRecords: new Map(),
            newObservablesSchedule: [],
            activeAction: undefined,
            activeStakeout: undefined,
        };
        function obtainRecord(object) {
            if (context.observableRecords.has(object)) {
                return context.observableRecords.get(object);
            }
            else {
                const record = {};
                context.observableRecords.set(object, record);
                return record;
            }
        }
        function forbidCircularProblems(object, key) {
            const scheduled = context.newObservablesSchedule.find(s => s.object === object &&
                s.key === key);
            if (scheduled)
                throw new AutowatcherCircularError(scheduled);
        }
        function subscribe(subscription) {
            const { object, key, stakeout } = subscription;
            const record = obtainRecord(object);
            const stakeouts = record[key] ?? [];
            record[key] = [...stakeouts, stakeout];
            return { subscription, record };
        }
        function triggerObservation(object, key) {
            forbidCircularProblems(object, key);
            const record = obtainRecord(object);
            const stakeouts = record[key] ?? [];
            for (const { watcher, effect } of stakeouts) {
                if (effect)
                    effect(watcher());
                else
                    watcher();
            }
        }
        return {
            context,
            subscribe,
            triggerObservation,
        };
    }

    function autowatcher() {
        const { context, subscribe, triggerObservation } = autowatcherCore();
        function observable(object) {
            return new Proxy(object, {
                get(t, key) {
                    if (context.activeStakeout)
                        context.newObservablesSchedule.push({
                            object,
                            key,
                            stakeout: context.activeStakeout,
                        });
                    return object[key];
                },
                set(t, key, value) {
                    const oldValue = object[key];
                    object[key] = value;
                    const isChanged = value !== oldValue;
                    if (!context.activeAction)
                        throw new AutowatcherLeakError(key);
                    if (isChanged)
                        triggerObservation(object, key);
                    return true;
                },
            });
        }
        function track(stakeout) {
            let unsubscribe = () => { };
            let done = () => { };
            context.activeStakeout = stakeout;
            context.newObservablesSchedule = [];
            try {
                const initialObservation = stakeout.watcher();
                done = stakeout.effect
                    ? () => stakeout.effect(initialObservation)
                    : done;
                const recent = context.newObservablesSchedule
                    .map(scheduled => subscribe(scheduled));
                unsubscribe = () => {
                    for (const { subscription: { key }, record } of recent) {
                        const existingStakeouts = record[key] ?? [];
                        record[key] = existingStakeouts.filter(s => s !== stakeout);
                    }
                };
            }
            finally {
                context.activeStakeout = undefined;
                context.newObservablesSchedule = [];
                done();
            }
            return unsubscribe;
        }
        function watch(watcher, effect) {
            return track({ watcher, effect });
        }
        function runInAction(act) {
            context.activeAction = act;
            act();
            context.activeAction = undefined;
        }
        function action(act) {
            return ((...args) => {
                context.activeAction = act;
                const result = act(...args);
                context.activeAction = undefined;
                return result;
            });
        }
        function state(object) {
            for (const [key, value] of Object.entries(object)) {
                if (value !== null && typeof value === "object" && !Array.isArray(value))
                    object[key] = state(value);
            }
            return observable(object);
        }
        function actions(object) {
            return objectMap(object, value => {
                if (value !== null && typeof value === "object")
                    return actions(value);
                else if (typeof value === "function")
                    return action(value);
                else
                    return value;
            });
        }
        function dispose() {
            context.observableRecords = new Map();
        }
        // function setup<xState extends {}, xActions extends Actions>({
        // 		state: stateObject,
        // 		actions: actionsObject,
        // 	}: {
        // 		state: xState
        // 		actions: xActions
        // 	}) {
        // 	return {
        // 		state: state(stateObject),
        // 		actions: actions(actionsObject),
        // 	}
        // }
        return {
            observable,
            state,
            track,
            watch,
            action,
            actions,
            dispose,
            runInAction,
            // setup,
        };
    }

    function makeAuthModel({ authMediator, loginService }) {
        const auto = autowatcher();
        const state = auto.state({
            access: ops.none(),
        });
        const actions = auto.actions({
            setAccess(op) {
                state.access = op;
            },
        });
        authMediator.subscribeToAccessChange(access => {
            actions.setAccess(ops.ready(access));
        });
        async function accessOperation(promise) {
            return ops.operation({
                promise,
                setOp: op => actions.setAccess(op),
            });
        }
        return {
            track: auto.track,
            get access() {
                return state.access;
            },
            onAccessChange: authMediator.subscribeToAccessChange,
            async getValidAccess() {
                return authMediator.getAccess();
            },
            async useExistingLogin() {
                await accessOperation(authMediator.initialize());
            },
            async sendLoginLink(email) {
                return loginService.sendLoginLink({ email });
            },
            async login(loginToken) {
                try {
                    if (isTokenValid(loginToken))
                        await accessOperation(loginService
                            .authenticateViaLoginToken({ loginToken })
                            .then(tokens => authMediator.login(tokens)));
                    else
                        actions.setAccess(ops.error("login link expired"));
                }
                catch (error) {
                    console.error(error);
                    actions.setAccess(ops.error("error with login"));
                }
            },
            async logout() {
                await ops.operation({
                    promise: authMediator.logout(),
                    setOp: op => actions.setAccess(op),
                });
            },
            async reauthorize() {
                await accessOperation(authMediator.reauthorize());
            },
        };
    }

    function makePersonalModel({ personalService, getAccess, reauthorize, }) {
        const auto = autowatcher();
        const state = auto.state({
            submitDraftOp: ops.ready(undefined)
        });
        const actions = auto.actions({
            setSubmitDraft(op) {
                state.submitDraftOp = op;
            },
        });
        return {
            get submitDraftOp() {
                return state.submitDraftOp;
            },
            async saveProfile(profileDraft) {
                await ops.operation({
                    promise: (async () => {
                        const { user: { userId } } = await getAccess();
                        await personalService.setProfile({ userId, profileDraft });
                        await reauthorize();
                    })(),
                    errorReason: "error saving profile",
                    setOp(op) {
                        actions.setSubmitDraft(op);
                    },
                });
            }
        };
    }

    function makePermissionsModel({ permissionsService, reauthorize, }) {
        const { getState, actions, onStateChange } = happystate({
            state: {
                active: false,
                access: undefined,
                permissionsDisplay: ops.none(),
            },
            actions: state => ({
                setActive(active) {
                    state.active = active;
                },
                setPermissionsDisplay(op) {
                    state.permissionsDisplay = op;
                },
                setAccess(access) {
                    state.access = access;
                },
            }),
        });
        async function reload() {
            await ops.operation({
                promise: Promise.resolve()
                    .then(async () => getUserCanCustomizePermissions()
                    ? permissionsService.fetchPermissions()
                    : undefined),
                setOp: op => actions.setPermissionsDisplay(op),
            });
        }
        function getUserCanCustomizePermissions() {
            const { access } = getState();
            return access?.user
                ? access.permit.privileges.includes(appPermissions.privileges["customize permissions"])
                : false;
        }
        async function initialize() {
            actions.setActive(true);
            if (getUserCanCustomizePermissions())
                await reload();
        }
        function reloadAfter(func) {
            return (async (...args) => {
                const result = await func(...args);
                await reload();
                await reauthorize();
                return result;
            });
        }
        return {
            onStateChange,
            getState,
            initialize,
            getUserCanCustomizePermissions,
            createRole: reloadAfter(permissionsService.createRole),
            deleteRole: reloadAfter(permissionsService.deleteRole),
            assignPrivilege: reloadAfter(permissionsService.assignPrivilege),
            unassignPrivilege: reloadAfter(permissionsService.unassignPrivilege),
            async accessChange(access) {
                actions.setAccess(access);
                if (access?.user && getState().active)
                    await reload();
            },
        };
    }

    function makeQuestionsModel({ questionsReadingService, questionsPostingService, questionsModerationService, getAccess, }) {
        const { actions, getState, onStateChange } = happystate({
            state: {
                access: undefined,
                users: [],
                questions: [],
                boardOps: {},
                postingOp: ops.ready(undefined),
            },
            actions: state => ({
                setAccess(access) {
                    state.access = access;
                },
                setBoardOp(board, op) {
                    state.boardOps = { ...state.boardOps, [board]: op };
                },
                setPostingOp(op) {
                    state.postingOp = op;
                },
                addUsers(newUsers) {
                    state.users = [...merge(newUsers, state.users, (a, b) => a.userId === b.userId)];
                },
                addQuestions(newQuestions) {
                    state.questions = [...merge(newQuestions, state.questions, (a, b) => a.questionId === b.questionId)];
                },
                setQuestionLike(questionId, like) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            liked: like,
                            likes: question.liked === like
                                ? question.likes
                                : like
                                    ? question.likes + 1
                                    : question.likes - 1
                        }
                        : { ...question });
                },
                setQuestionReport(questionId, report) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? {
                            ...question,
                            reported: report,
                            reports: question.reported === report
                                ? question.reports
                                : report
                                    ? question.reports + 1
                                    : question.reports - 1
                        }
                        : { ...question });
                },
                setQuestionArchive(questionId, archive) {
                    state.questions = state.questions.map(question => question.questionId === questionId
                        ? { ...question, archive }
                        : { ...question });
                },
            }),
        });
        async function loadQuestionsForBoard(board) {
            await ops.operation({
                promise: (async () => {
                    const { users, questions } = await questionsReadingService
                        .fetchQuestions({ board });
                    actions.addUsers(users);
                    actions.addQuestions(questions);
                })(),
                setOp: op => actions.setBoardOp(board, op),
            });
        }
        function makeBoardModel(board) {
            return {
                getPermissions() {
                    const { access } = getState();
                    return {
                        "read questions": access
                            ? access.permit.privileges.includes(appPermissions.privileges["read questions"])
                            : false,
                        "post questions": access
                            ? access.permit.privileges.includes(appPermissions.privileges["post questions"]) && !access.permit.privileges.includes(appPermissions.privileges["banned"])
                            : false,
                        "moderate questions": access
                            ? access.permit.privileges.includes(appPermissions.privileges["moderate questions"])
                            : false,
                    };
                },
                getBoardName() {
                    return board;
                },
                getAccess() {
                    return getState().access;
                },
                getBoardOp() {
                    return getState().boardOps[board];
                },
                getPostingOp() {
                    return getState().postingOp;
                },
                getQuestions() {
                    return getState().questions
                        .filter(question => question.board === board)
                        .filter(question => question.archive === false);
                },
                getUser(userId) {
                    return getState().users.find(user => user.userId === userId);
                },
                async loadQuestions() {
                    await loadQuestionsForBoard(board);
                },
                async postQuestion(questionDraft) {
                    const question = await ops.operation({
                        promise: questionsPostingService.postQuestion({ questionDraft }),
                        setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                    });
                    actions.addQuestions([question]);
                    const access = ops.value(getAccess());
                    actions.addUsers([access.user]);
                },
                async likeQuestion(questionId, like) {
                    await questionsPostingService.likeQuestion({
                        like,
                        questionId,
                    });
                    actions.setQuestionLike(questionId, like);
                },
                async reportQuestion(questionId, report) {
                    await questionsPostingService.reportQuestion({
                        report,
                        questionId,
                    });
                    actions.setQuestionReport(questionId, report);
                },
                async archiveQuestion(questionId, archive) {
                    await questionsPostingService.archiveQuestion({
                        archive,
                        questionId,
                    });
                    actions.setQuestionArchive(questionId, archive);
                },
                async archiveBoard() {
                    await questionsModerationService.archiveBoard({ board });
                    for (const question of getState().questions)
                        actions.setQuestionArchive(question.questionId, true);
                },
            };
        }
        async function refreshAllBoards() {
            const state = getState();
            await Promise.all(Object.keys(state.boardOps).map(loadQuestionsForBoard));
        }
        return {
            onStateChange,
            makeBoardModel,
            accessChange: (access) => {
                actions.setAccess(access);
                if (access?.user)
                    actions.addUsers([access.user]);
                refreshAllBoards();
            },
        };
    }

    function makeAllowanceChecker(access, privileges) {
        const allowed = {};
        for (const [key, privilegeId] of Object.entries(privileges))
            allowed[key] = access
                ? access.permit.privileges.includes(privilegeId)
                : false;
        return (privilege) => allowed[privilege];
    }

    function makeAdministrativeModel({ roleAssignmentService, reauthorize, }) {
        const { actions, getState, onStateChange } = happystate({
            state: {
                access: undefined,
                permissionsOp: ops.none(),
            },
            actions: state => ({
                setAccess(access) {
                    state.access = access;
                },
                setPermissionsOp(op) {
                    state.permissionsOp = op;
                },
            }),
        });
        let initializedInDom = false;
        function allowanceChecker() {
            return makeAllowanceChecker(getState().access, appPermissions.privileges);
        }
        async function loadPermissions() {
            if (initializedInDom && allowanceChecker()("administrate user roles"))
                await ops.operation({
                    promise: roleAssignmentService.fetchPermissions(),
                    setOp: actions.setPermissionsOp,
                });
        }
        async function initialize() {
            initializedInDom = true;
            await loadPermissions();
        }
        return {
            getState,
            onStateChange,
            initialize,
            get isAllowed() {
                return allowanceChecker();
            },
            accessChange: (access) => {
                actions.setAccess(access);
                loadPermissions();
            },
            reauthorize,
            searchUsers: roleAssignmentService.searchUsers,
            assignRoleToUser: roleAssignmentService.assignRoleToUser,
            revokeRoleFromUser: roleAssignmentService.revokeRoleFromUser,
        };
    }

    async function assembleModels({ appId, remote, popups, storage, authMediator, }) {
        const authModel = makeAuthModel({
            authMediator,
            loginService: remote.auth.loginService,
        });
        const { getValidAccess, reauthorize } = authModel;
        const personalModel = makePersonalModel({
            reauthorize,
            getAccess: getValidAccess,
            personalService: remote.auth.personalService,
        });
        const appModel = makeAppModel({
            getAccess: getValidAccess,
            appService: remote.auth.appService,
            appEditService: remote.auth.appEditService,
            manageAdminsService: remote.auth.manageAdminsService,
        });
        const permissionsModel = makePermissionsModel({
            permissionsService: remote.auth.permissionsService,
            reauthorize,
        });
        // // TODO reactivate store
        // const storeModel = makeStoreModel({
        // 	appId,
        // 	storage,
        // 	shopkeepingService: remote.store.shopkeepingService,
        // 	stripeAccountsService: remote.store.stripeConnectService,
        // 	statusCheckerService: remote.store.ecommerce.statusCheckerService,
        // 	statusTogglerService: remote.store.ecommerce.statusTogglerService,
        // 	triggerBankPopup: popups.triggerBankPopup,
        // })
        const administrativeModel = makeAdministrativeModel({
            roleAssignmentService: remote.administrative.roleAssignmentService,
            reauthorize: () => authModel.reauthorize(),
        });
        const questionsModel = makeQuestionsModel({
            ...remote.questions,
            getAccess: () => authModel.access,
        });
        authModel.onAccessChange(async (access) => {
            await Promise.all([
                appModel.accessChange(),
                permissionsModel.accessChange(access),
                // storeModel.accessChange(access),
                questionsModel.accessChange(access),
                administrativeModel.accessChange(access),
            ]);
        });
        return {
            appModel,
            authModel,
            // storeModel,
            personalModel,
            questionsModel,
            permissionsModel,
            administrativeModel,
        };
    }

    function mockModalSystem() {
        const nextModalResults = {
            confirm: true,
            prompt: undefined,
        };
        const modals = {
            popup() {
                return {
                    controls: {
                        close() { },
                        rerender() { },
                    },
                    modal: {},
                };
            },
            async confirm() {
                return nextModalResults.confirm;
            },
            async prompt() {
                return nextModalResults.prompt;
            },
        };
        return {
            modals,
            nextModalResults,
        };
    }

    function memoryFlexStorage() {
        const map = new Map();
        return {
            async read(key) {
                return map.get(key);
            },
            async write(key, data) {
                map.set(key, data);
            },
            async delete(key) {
                map.delete(key);
            },
        };
    }

    async function mockBrowser({ api, mockStripeOperations }) {
        async function mockAppWindow({ appId, apiLink, latency, windowLink, }) {
            const storage = memoryFlexStorage();
            const { remote, authMediator } = mockRemote({
                api,
                appId,
                apiLink,
                latency,
                storage,
                origin: new URL(windowLink).origin,
            });
            const { modals, nextModalResults } = mockModalSystem();
            const models = await assembleModels({
                appId,
                remote,
                storage,
                authMediator,
                popups: mockPopups({ mockStripeOperations }),
            });
            return { models, remote, nextModalResults };
        }
        return { mockAppWindow };
    }

    function processBlueprintRecursive({ blueprint, path = [], process, }) {
        return objectMap2(blueprint, (value, key) => (value === true
            ? process([...path, key])
            : processBlueprintRecursive({
                blueprint: value,
                path: [...path, key],
                process,
            })));
    }
    function processBlueprint({ blueprint, process }) {
        return processBlueprintRecursive({ blueprint, process });
    }

    function loginEmailRecaller(sendLoginEmail) {
        let latestLoginEmail;
        return {
            sendLoginEmail: async (details) => {
                latestLoginEmail = details;
                await sendLoginEmail(details);
            },
            recallLatestLoginEmail: () => latestLoginEmail,
        };
    }

    async function resolveQuestions({ userId, posts, questionsTables }) {
        const ids = posts.map(post => post.questionId);
        const likes = ids.length
            ? await questionsTables.questionLikes.read({
                conditions: or(...ids.map(id => ({ equal: { questionId: id } })))
            })
            : [];
        const reports = ids.length
            ? await questionsTables.questionReports.read({
                conditions: or(...ids.map(id => ({ equal: { questionId: id } })))
            })
            : [];
        return ids.map(id => {
            const questionPost = posts.find(post => post.questionId === id);
            const questionLikes = likes.filter(like => like.questionId === id);
            const questionReports = reports.filter(report => report.questionId === id);
            const userLike = questionLikes.find(like => like.userId === userId);
            const userReport = questionReports.find(report => report.userId === userId);
            return {
                ...questionPost,
                likes: questionLikes.length,
                reports: questionReports.length,
                liked: !!userLike,
                reported: !!userReport,
            };
        });
    }

    const namespaceKeyAppId = "_appId";

    function dbbyConstrain(table, namespace) {
        const spike = (conditionTree) => (conditionTree
            ? and({ equal: namespace }, conditionTree)
            : and({ equal: namespace }));
        return {
            async create(...rows) {
                return table.create(...rows.map(row => ({ ...row, ...namespace })));
            },
            async read(options) {
                return table.read({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async one(options) {
                return table.one({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async assert(options) {
                return table.assert({
                    ...options,
                    conditions: spike(options.conditions),
                    make: async () => {
                        const row = await options.make();
                        return { ...row, ...namespace };
                    },
                });
            },
            async update(options) {
                const opts = options;
                return table.update({
                    ...options,
                    conditions: spike(options.conditions),
                    upsert: opts.upsert
                        ? { ...opts.upsert, ...namespace }
                        : undefined,
                    whole: opts.whole
                        ? { ...opts.whole, ...namespace }
                        : undefined,
                    write: opts.write
                        ? { ...opts.write, ...namespace }
                        : undefined,
                });
            },
            async delete(options) {
                return table.delete({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
            async count(options) {
                return table.count({
                    ...options,
                    conditions: spike(options.conditions),
                });
            },
        };
    }
    function prepareConstrainTables(tables) {
        return (namespace) => objectMap(tables, table => dbbyConstrain(table, namespace));
    }

    function prepareNamespacerForTables(tables) {
        return async function bakeTable(appId) {
            return prepareConstrainTables(tables)({ [namespaceKeyAppId]: appId });
        };
    }

    async function spikeQuestionsAuth(meta, request, questionsTables, basePolicy) {
        const auth = await basePolicy.processAuth(meta, request);
        return {
            ...auth,
            questionsTables: await prepareNamespacerForTables(questionsTables)(auth.access.appId),
        };
    }

    function anonQuestionsPolicy({ authPolicies, questionsTables, }) {
        return async function (meta, request) {
            return spikeQuestionsAuth(meta, request, questionsTables, authPolicies.anon);
        };
    }

    function asServiceParts() {
        return function (parts) {
            return parts;
        };
    }

    const questionsReadingParts = (options) => asServiceParts()({
        policy: async (meta, request) => {
            const auth = await anonQuestionsPolicy(options)(meta, request);
            auth.checker.requirePrivilege("read questions");
            return auth;
        },
        expose: {
            async fetchQuestions({ questionsTables, tables, access }, { board }) {
                const posts = await questionsTables.questionPosts
                    .read({
                    ...find({ board, archive: false }),
                    limit: 100,
                    offset: 0,
                    order: { timePosted: "descend" },
                });
                let questions = [];
                let users = [];
                if (posts.length) {
                    const permissionsEngine = makePermissionsEngine({
                        isPlatform: access.appId === options.config.platform.appDetails.appId,
                        permissionsTables: tables.permissions,
                    });
                    users = await fetchUsers({
                        permissionsEngine,
                        authTables: tables,
                        userIds: posts.map(p => p.authorUserId),
                    });
                    questions = await resolveQuestions({
                        posts,
                        questionsTables,
                        userId: access?.user?.userId,
                    });
                }
                return { questions, users };
            },
        },
    });

    const validateQuestionDraftContent = one(string(), minLength(10), maxLength(280), notWhitespace());
    const validateQuestionDraft = schema({
        board: one(string(), minLength(1), maxLength(32), notWhitespace()),
        content: validateQuestionDraftContent,
    });

    function authenticatedQuestionsPolicy({ authPolicies, questionsTables, }) {
        return async function (meta, request) {
            return spikeQuestionsAuth(meta, request, questionsTables, authPolicies.user);
        };
    }

    function requireUserCanEditQuestion({ userId, questionPost, checker }) {
        const userIsModerator = checker.hasPrivilege("moderate questions");
        const userIsOwner = questionPost.authorUserId === userId;
        const isAllowed = userIsModerator || userIsOwner;
        if (!isAllowed)
            throw new Error(`user is not authorized to edit question`);
    }

    const questionsPostingParts = (options) => asServiceParts()({
        policy: async (meta, request) => {
            const auth = await authenticatedQuestionsPolicy(options)(meta, request);
            auth.checker.requirePrivilege("post questions");
            auth.checker.requireNotHavePrivilege("banned");
            return auth;
        },
        expose: {
            async postQuestion({ questionsTables, access, checker }, { questionDraft }) {
                checker.requirePrivilege("post questions");
                throwProblems(validateQuestionDraft(questionDraft));
                const row = {
                    questionId: options.rando.randomId(),
                    authorUserId: access.user.userId,
                    archive: false,
                    timePosted: Date.now(),
                    ...questionDraft,
                };
                await questionsTables.questionPosts.create(row);
                return {
                    ...row,
                    likes: 0,
                    reports: 0,
                    liked: false,
                    reported: false,
                };
            },
            async archiveQuestion({ access: { user: { userId } }, questionsTables, checker }, { questionId, archive }) {
                const questionPost = await questionsTables.questionPosts
                    .one(find({ questionId }));
                requireUserCanEditQuestion({ userId, checker, questionPost });
                await questionsTables.questionPosts.update({
                    ...find({ questionId }),
                    write: { archive: !!archive },
                });
            },
            async likeQuestion({ questionsTables, checker, access: { user: { userId } } }, { questionId, like }) {
                checker.requirePrivilege("like questions");
                const myLikeCount = await questionsTables.questionLikes
                    .count(find({ questionId, userId }));
                const alreadyLiked = myLikeCount > 0;
                const addLike = () => questionsTables.questionLikes
                    .create({ userId, questionId });
                const removeLike = () => questionsTables.questionLikes
                    .delete(find({ userId, questionId }));
                if (like && !alreadyLiked)
                    await addLike();
                else if (!like && alreadyLiked)
                    await removeLike();
            },
            async reportQuestion({ questionsTables, checker, access: { user: { userId } } }, { questionId, report }) {
                checker.requirePrivilege("report questions");
                const myReportCount = await questionsTables.questionReports
                    .count(find({ questionId, userId }));
                const alreadyReported = myReportCount > 0;
                const addReport = () => questionsTables.questionReports
                    .create({ userId, questionId });
                const removeReport = () => questionsTables.questionReports
                    .delete(find({ userId, questionId }));
                if (report && !alreadyReported)
                    await addReport();
                else if (!report && alreadyReported)
                    await removeReport();
            },
        },
    });

    function assembleApiContext(parts) {
        return apiContext()({
            policy: { processAuth: parts.policy },
            expose: parts.expose,
        });
    }

    const questionsModerationParts = (options) => asServiceParts()({
        policy: async (meta, request) => {
            const auth = await authenticatedQuestionsPolicy(options)(meta, request);
            auth.checker.requirePrivilege("moderate questions");
            auth.checker.requireNotHavePrivilege("banned");
            return auth;
        },
        expose: {
            async archiveBoard({ questionsTables }, { board }) {
                await questionsTables.questionPosts.update({
                    ...find({ board }),
                    write: { archive: true },
                });
            },
        },
    });

    function questionsApi(options) {
        return asApi({
            questionsReadingService: assembleApiContext(questionsReadingParts(options)),
            questionsPostingService: assembleApiContext(questionsPostingParts(options)),
            questionsModerationService: assembleApiContext(questionsModerationParts(options)),
        });
    }

    function makeEmailEnabler(actuallySendEmail) {
        let enabled = true;
        const sendEmail = async (details) => {
            if (enabled)
                return actuallySendEmail(details);
        };
        return {
            sendEmail,
            enableEmails() { enabled = true; },
            disableEmails() { enabled = false; },
        };
    }

    function jsonStorage(storage) {
        return {
            read(key) {
                let data = undefined;
                const raw = storage.getItem(key);
                if (raw) {
                    try {
                        data = JSON.parse(raw);
                    }
                    catch (error) {
                        storage.removeItem(key);
                    }
                }
                return data;
            },
            write(key, data) {
                const json = JSON.stringify(data);
                storage.setItem(key, json);
            },
            delete(key) {
                storage.removeItem(key);
            },
        };
    }

    function simpleFlexStorage(storage) {
        const json = jsonStorage(storage);
        return {
            async read(key) {
                return json.read(key);
            },
            async write(key, data) {
                return json.write(key, data);
            },
            async delete(key) {
                return json.delete(key);
            },
        };
    }

    function isOriginValid(request, origins) {
        return !!request.headers.origin
            && origins.some(origin => origin === request.headers.origin);
    }

    function prepareStatsHub({ tables }) {
        return async function getStatsHub(userId) {
            async function throwForbiddenUser(appId) {
                const row = await tables.app.appOwnership.one(find({ appId }));
                if (row.userId !== userId)
                    throw new ApiError(403, "forbidden");
            }
            function exposeNamespacing(table) {
                return table;
            }
            return {
                countUsers: async (appId) => {
                    await throwForbiddenUser(appId);
                    return exposeNamespacing(tables.user.account)
                        .count(find({ [namespaceKeyAppId]: appId }));
                },
                countUsersActiveDaily: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - day;
                    return exposeNamespacing(tables.user.latestLogin)
                        .count({
                        conditions: and({ equal: { _appId: appId } }, { greater: { time: timeToStartCounting } })
                    });
                },
                countUsersActiveMonthly: async (appId) => {
                    await throwForbiddenUser(appId);
                    const timeToStartCounting = Date.now() - month;
                    return exposeNamespacing(tables.user.latestLogin)
                        .count({
                        conditions: and({ equal: { _appId: appId } }, { greater: { time: timeToStartCounting } })
                    });
                },
            };
        };
    }

    async function dbbyMemory(rows) {
        const table = await dbbyX(memoryFlexStorage(), "");
        if (rows)
            await table.create(...rows);
        return table;
    }

    function dbbyHardback({ frontTable, backTable }) {
        async function one(options) {
            return await backTable.one(options) ?? await frontTable.one(options);
        }
        return {
            one,
            create: frontTable.create,
            update: frontTable.update,
            delete: frontTable.delete,
            async read(options) {
                const [hardRows, actualRows] = await Promise.all([
                    backTable.read(options),
                    await frontTable.read(options),
                ]);
                return [...hardRows, ...actualRows];
            },
            async assert(options) {
                const row = await one(options);
                return row || await (async () => {
                    const newRow = await options.make();
                    await frontTable.create(newRow);
                    return newRow;
                })();
            },
            async count(options) {
                const [hardCount, actualCount] = await Promise.all([
                    backTable.count(options),
                    frontTable.count(options),
                ]);
                return hardCount + actualCount;
            },
        };
    }

    function bakeryForAppTables({ config, appTables }) {
        return async function bakeAppTables() {
            const platformApp = config.platform.appDetails;
            return {
                app: dbbyHardback({
                    frontTable: appTables.app,
                    backTable: await dbbyMemory([
                        {
                            appId: platformApp.appId,
                            home: platformApp.home,
                            label: platformApp.label,
                            origins: originsToDatabase(platformApp.origins),
                            archived: false,
                        }
                    ]),
                }),
                appOwnership: appTables.appOwnership,
            };
        };
    }

    function authTablesBakery({ config, tables }) {
        const bakeAppTables = bakeryForAppTables({
            config,
            appTables: tables.app,
        });
        return async function bakeTables(appId) {
            return {
                app: await bakeAppTables(),
                user: await prepareNamespacerForTables(tables.user)(appId),
                permissions: await prepareNamespacerForTables(tables.permissions)(appId),
            };
        };
    }

    async function isUserOwnerOfApp({ appId, access, tables }) {
        const { userId } = access.user;
        const ownershipRow = await tables.app.appOwnership.one(find({ userId, appId }));
        return !!ownershipRow;
    }

    function makePrivilegeChecker(permit, privileges) {
        function hasPrivilege(key) {
            return permit.privileges.includes(privileges[key]);
        }
        function requirePrivilege(key) {
            if (!hasPrivilege(key))
                throw new ApiError(403, `forbidden; privilege required "${key}"`);
        }
        function requireNotHavePrivilege(key) {
            if (hasPrivilege(key))
                throw new ApiError(403, `forbidden: must not have privilege "${key}"`);
        }
        return {
            hasPrivilege,
            requirePrivilege,
            requireNotHavePrivilege,
        };
    }

    function prepareAuthPolicies({ config, tables, verifyToken, }) {
        const bakeTables = authTablesBakery({ config, tables });
        const getStatsHub = prepareStatsHub({ tables });
        // policy for completely unknown user
        const green = {
            processAuth: async (meta, request) => {
                return { bakeTables };
            },
        };
        // policy for authorized anonymous user
        const anon = {
            processAuth: async ({ accessToken }, request) => {
                const access = await verifyToken(accessToken);
                if (isOriginValid(request, access.origins))
                    return {
                        access,
                        tables: await bakeTables(access.appId),
                        checker: makePrivilegeChecker(access.permit, appPermissions.privileges),
                    };
                else
                    throw new ApiError(403, "invalid origin");
            },
        };
        // policy for logged in user
        const user = {
            processAuth: async (meta, request) => {
                const auth = await anon.processAuth(meta, request);
                if (auth.access.user)
                    return auth;
                else
                    throw new ApiError(403, "not logged in");
            },
        };
        // app user who is allowed to manage permissions
        const userWhoManagesPermissions = {
            processAuth: async (meta, request) => {
                const auth = await user.processAuth(meta, request);
                auth.checker.requirePrivilege("customize permissions");
                return auth;
            },
        };
        // policy for logged in user on the platform app
        const platformUser = {
            processAuth: async (meta, request) => {
                const auth = await user.processAuth(meta, request);
                if (auth.access.appId == config.platform.appDetails.appId)
                    return {
                        ...auth,
                        checker: makePrivilegeChecker(auth.access.permit, platformPermissions.privileges),
                        statsHub: await getStatsHub(auth.access.user.userId),
                    };
                else
                    throw new ApiError(403, "not platform app");
            },
        };
        // platform user who is the owner of an app
        const appOwner = {
            processAuth: async (meta, request) => {
                const auth = await platformUser.processAuth(meta, request);
                async function getTablesNamespacedForApp(appId) {
                    const canEditAnyApp = auth.checker.hasPrivilege("edit any app");
                    const isOwner = isUserOwnerOfApp({ appId, access: auth.access, tables });
                    const allowed = isOwner || canEditAnyApp;
                    if (allowed)
                        return bakeTables(appId);
                    else
                        throw new ApiError(403, "forbidden: not privileged over app");
                }
                return { ...auth, getTablesNamespacedForApp };
            },
        };
        return {
            green,
            anon,
            user,
            appOwner,
            platformUser,
            userWhoManagesPermissions,
        };
    }

    function makeLoginLink({ home, loginToken }) {
        return `${home}?login=${loginToken}`;
    }

    function prepareSendLoginEmail({ sendEmail }) {
        return async function sendLoginEmail({ to, appHome, appLabel, lifespan, legalLink, loginToken, platformLink, }) {
            const loginLink = makeLoginLink({ loginToken, home: appHome });
            const minutesLeft = (lifespan / minute).toFixed(0);
            return sendEmail({
                to,
                subject: `Login to ${appLabel}`,
                body: (`
Login link for ${appLabel} (expires in ${minutesLeft} minutes)

 » ${loginLink} «

If you didn't request this login link, just ignore it

 * logins powered by ${platformLink} *
 * policies and terms of service ${legalLink} *
`),
            });
        };
    }

    function stripeWebhooks({ logger, stripeComplex, tables }) {
        return {
            async "checkout.session.completed"(event) {
                logger.info("stripe-webhook checkout.session.completed:", event.data.object);
            },
            async "invoice.paid"(event) {
                logger.info("stripe-webhook invoice.paid:", event.data.object);
            },
            async "invoice.payment_failed"(event) {
                logger.info("stripe-webhook invoice.payment_failed:", event.data.object);
            },
            async "customer.subscription.updated"(event) {
                logger.info("stripe-webhook customer.subscription.updated:", event.data.object);
            },
        };
    }

    function mockStripeComplex({ rando, tables, webhooks }) {
        const generateId = () => rando.randomId();
        function respond(resource) {
            return {
                headers: {},
                lastResponse: undefined,
                ...resource,
            };
        }
        const stripeLiaisonForPlatform = {
            accounts: {
                async create(params) {
                    const account = {
                        id: generateId(),
                        type: params.type,
                        email: params.email,
                    };
                    await tables.accounts.create(account);
                    return respond(account);
                },
                async retrieve(id) {
                    const account = await tables.accounts.one(find({ id }));
                    return respond(account);
                },
            },
            accountLinks: {
                async create(params) {
                    const accountLink = {
                        url: `https://fake.xiome.io/stripe-account-setup`,
                    };
                    return respond(accountLink);
                },
            },
        };
        async function webhookEvent(type, object) {
            return webhooks[type]({
                type,
                data: { object },
            });
        }
        const rawTables = tables;
        function connectStripeLiaisonForApp(stripeConnectAccountId) {
            const tables = prepareConstrainTables(rawTables)({
                "_connectedAccount": stripeConnectAccountId,
            });
            function ignoreUndefined(input) {
                const output = {};
                for (const [key, value] of Object.entries(input)) {
                    if (value !== undefined)
                        output[key] = value;
                }
                return output;
            }
            function prepMockResource(table) {
                return {
                    create({ makeData, hook = async () => { } }) {
                        return async function (params) {
                            const resource = {
                                id: generateId(),
                                ...makeData(params),
                            };
                            await table.create(resource);
                            await hook(resource);
                            return respond(resource);
                        };
                    },
                    retrieve() {
                        return async function (id) {
                            const resource = await table.one(find({ id }));
                            return respond(resource);
                        };
                    },
                    update({ makeData, hook = async () => { } }) {
                        return async function (id, params) {
                            await table.update({
                                ...find({ id }),
                                write: ignoreUndefined(makeData(params)),
                            });
                            const resource = await table.one(find({ id }));
                            await hook(resource);
                            return respond(resource);
                        };
                    },
                    delete() {
                        return async function (id) {
                            await table.delete(find({ id }));
                        };
                    },
                };
            }
            function mockResource({ table, createData, updateData, createHook, updateHook, }) {
                const context = prepMockResource(table);
                return {
                    create: context.create({
                        makeData: createData,
                        hook: createHook,
                    }),
                    retrieve: context.retrieve(),
                    update: context.update({
                        makeData: updateData,
                        hook: updateHook,
                    }),
                    delete: context.delete(),
                };
            }
            return {
                customers: mockResource({
                    table: tables.customers,
                    createData: params => ({
                        email: params.email,
                        invoice_settings: params.invoice_settings
                            ?? { default_payment_method: undefined },
                    }),
                    updateData: params => ({
                        email: params.email,
                        invoice_settings: params.invoice_settings,
                    }),
                }),
                products: mockResource({
                    table: tables.products,
                    createData: params => ({
                        name: params.name,
                        description: params.description,
                    }),
                    updateData: params => ({
                        name: params.name,
                        description: params.description,
                    }),
                }),
                prices: mockResource({
                    table: tables.prices,
                    createData: params => ({
                        product: params.product,
                        currency: params.currency,
                        unit_amount: params.unit_amount,
                        recurring: params.recurring,
                    }),
                    updateData: params => ({
                        active: params.active,
                    }),
                }),
                checkout: {
                    sessions: mockResource({
                        table: tables.checkoutSessions,
                        createData: params => ({
                            customer: params.customer,
                        }),
                        updateData: params => ({}),
                        createHook: async (session) => {
                            await webhookEvent("checkout.session.completed", session);
                        },
                        updateHook: async (session) => {
                            await webhookEvent("checkout.session.completed", session);
                        },
                    }),
                },
                paymentMethods: mockResource({
                    table: tables.paymentMethods,
                    createData: params => ({
                        type: params.type,
                        customer: params.customer,
                    }),
                    updateData: params => ({}),
                }),
                setupIntents: mockResource({
                    table: tables.setupIntents,
                    createData: params => ({
                        customer: params.customer,
                        payment_method: params.payment_method,
                        usage: params.usage,
                    }),
                    updateData: params => ({
                        payment_method: params.payment_method,
                    }),
                }),
                subscriptions: mockResource({
                    table: tables.subscriptions,
                    createData: params => ({
                        customer: params.customer,
                        default_payment_method: params.default_payment_method,
                        cancel_at_period_end: params.cancel_at_period_end,
                        items: {
                            url: "",
                            object: "list",
                            has_more: false,
                            data: params.items.map(itemParams => ({
                                id: generateId(),
                                billing_thresholds: itemParams.billing_thresholds,
                                price: itemParams.price,
                                price_data: itemParams.price_data,
                                quantity: itemParams.quantity,
                                tax_rates: itemParams.tax_rates,
                            })),
                        },
                    }),
                    updateData: params => ({
                        cancel_at_period_end: params.cancel_at_period_end,
                        default_payment_method: params.default_payment_method,
                    }),
                    updateHook: async (subscription) => {
                        await webhookEvent("customer.subscription.updated", subscription);
                    },
                }),
            };
        }
        return { stripeLiaisonForPlatform, connectStripeLiaisonForApp };
    }

    async function mockStripeTables({ tableStorage }) {
        const spec = {
            prices: undefined,
            accounts: undefined,
            products: undefined,
            customers: undefined,
            setupIntents: undefined,
            subscriptions: undefined,
            paymentMethods: undefined,
            checkoutSessions: undefined,
        };
        const tables = await concurrent(objectMap2(spec, (value, key) => dbbyX(tableStorage, `mock-stripe-${key}`)));
        return tables;
    }

    async function mockStripeCircuit({ rando, tableStorage, tables: xiomeTables, }) {
        const { publishers: webhookPublishers, subscribers: webhookSubscribers, } = pubsubs({
            "checkout.session.completed": pubsub(),
            "invoice.paid": pubsub(),
            "invoice.payment_failed": pubsub(),
            "customer.subscription.updated": pubsub(),
        });
        const stripeTables = await mockStripeTables({ tableStorage });
        const stripeComplex = mockStripeComplex({
            rando,
            tables: stripeTables,
            webhooks: webhookPublishers,
        });
        const webhooks = stripeWebhooks({
            stripeComplex,
            logger: console,
            tables: xiomeTables,
        });
        for (const [key, subscribe] of Object.entries(webhookSubscribers))
            subscribe(webhooks[key].bind(webhooks));
        return {
            stripeComplex,
            mockStripeOperations: {
                linkBankWithExistingStripeAccount: async (stripeAccountId) => {
                    await stripeTables.accounts.update({
                        ...find({ id: stripeAccountId }),
                        write: {
                            payouts_enabled: true,
                            details_submitted: true,
                        },
                    });
                },
            },
        };
    }

    const validateId = validator$1(one(string(), length(48)));

    const validateTimeframe = branch(notDefined(), number());

    const validateUserSearchTerm = validator$1(one(string(), minLength(1), maxLength(48)));
    // export const validateUserSearchTerm = validator<string>(
    // 	one(
    // 		string(),
    // 		minLength(1),
    // 		branch(
    // 			profileValidators.nickname,
    // 			profileValidators.tagline,
    // 			validateId,
    // 		)
    // 	)
    // )

    function runValidation(value, validator) {
        const problems = validator(value);
        if (problems.length > 0)
            throw new ApiError(400, problems.join("; "));
        else
            return value;
    }

    const roleAssignmentParts = ({ config, authPolicies, }) => asServiceParts()({
        policy: async (meta, request) => {
            const auth = await authPolicies.user.processAuth(meta, request);
            auth.checker.requirePrivilege("administrate user roles");
            return auth;
        },
        expose: {
            async fetchPermissions({ tables, access }) {
                return fetchPermissionsDisplay({
                    config,
                    access,
                    permissionsTables: tables.permissions,
                });
            },
            async searchUsers({ tables, access }, options) {
                const { term } = runValidation(options, schema({
                    term: validateUserSearchTerm,
                }));
                const regex = new RegExp(escapeRegex(term), "i");
                const profiles = await tables.user.profile.read({
                    limit: 100,
                    conditions: or({ equal: { userId: term } }, { search: { nickname: regex } }, { search: { tagline: regex } }),
                });
                const userIds = profiles.map(profile => profile.userId);
                if (!userIds.length)
                    return [];
                const permissionsEngine = makePermissionsEngine({
                    isPlatform: access.appId === config.platform.appDetails.appId,
                    permissionsTables: tables.permissions,
                });
                const users = await fetchUsers({
                    userIds,
                    permissionsEngine,
                    authTables: tables,
                });
                const usersAndRoles = await permissionsEngine.getUsersHaveRoles({
                    userIds: users.map(user => user.userId),
                    onlyGetPublicRoles: false,
                });
                return users.map(user => ({
                    user,
                    roleIds: usersAndRoles
                        .find(u => u.userId === user.userId)
                        .userHasRoles
                        .map(role => role.roleId)
                }));
            },
            async assignRoleToUser({ tables }, options) {
                const { roleId, userId, isPublic, timeframeEnd, timeframeStart } = (runValidation(options, schema({
                    roleId: validateId,
                    userId: validateId,
                    isPublic: validator$1(boolean()),
                    timeframeEnd: validateTimeframe,
                    timeframeStart: validateTimeframe,
                })));
                const existing = await tables.permissions.userHasRole.one(find({
                    userId,
                    roleId,
                }));
                if (existing?.hard)
                    throw new ApiError(400, "hard role assignment cannot be overwritten");
                else
                    await tables.permissions.userHasRole.assert({
                        conditions: or({ equal: { roleId, userId } }),
                        make: async () => ({
                            hard: false,
                            public: isPublic,
                            roleId,
                            userId,
                            timeframeEnd,
                            timeframeStart,
                        }),
                    });
            },
            async revokeRoleFromUser({ tables }, options) {
                const { roleId, userId } = runValidation(options, schema({
                    roleId: validateId,
                    userId: validateId,
                }));
                const existing = await tables.permissions.userHasRole.one(find({
                    userId,
                    roleId,
                }));
                if (existing?.hard)
                    throw new ApiError(400, "hard role assignment cannot be overwritten");
                else
                    await tables.permissions.userHasRole.delete({
                        conditions: or({ equal: { roleId, userId } }),
                    });
            },
        },
    });

    function makeAdministrativeApi(options) {
        return asApi({
            roleAssignmentService: assembleApiContext(roleAssignmentParts(options)),
        });
    }

    const sendEmail = async (email) => console.log(`

====== EMAIL ======
to: ${email.to}
subject: ${email.subject}
time: ${new Date().toLocaleString()}

${email.body}

===================

`);

    const colors = [
        "Red",
        "Yellow",
        "Green",
        "Cyan",
        "Blue",
        "Magenta",
        "Dark",
        "Grey",
        "Silver",
        "Bright",
        "Light",
        "Gold",
        "Golden",
        "Aqua",
        "Minty",
    ];

    const animals = [
        "Aardvark",
        "Mongoose",
        "Alligator",
        "Robin",
        "Monkey",
        "Seahorse",
        "Shark",
        "Leopard",
        "Eagle",
        "Raven",
        "Owl",
        "Hawk",
        "Duck",
        "Wolf",
        "Coyote",
        "Dingo",
        "Ostrich",
        "Llama",
        "Alpaca",
        "Zebra",
        "Bear",
        "Kiwi",
        "Penguin",
        "Otter",
        "Dolphin",
        "Starfish",
        "Sunfish",
        "Salmon",
        "Swordfish",
        "Sparrow",
        "Turtle",
        "Puppy",
        "Kitten",
    ];

    const adjectives = [
        "Funny",
        "Charming",
        "Wonderful",
        "Fancy",
        "Whimsical",
        "Gregarious",
        "Curious",
        "Fabulous",
        "Saavy",
        "Groovy",
        "Happy",
        "Snappy",
        "Quick",
        "Super",
        "Fast",
        "Fuzzy",
        "Clever",
        "Genius",
        "Marvelous",
        "Eccentric",
        "Fantastic",
        "Quaint",
        "Young",
        "Wise",
        "Creative",
        "Helpful",
        "Nice",
        "Sincere",
        "Loyal",
        "Honest",
        "Truthful",
        "Thoughtful",
        "Clean",
        "Friendly",
        "Gentle",
        "Pleasant",
        "Brilliant",
        "Polite",
        "Original",
        "Ambitious",
        "Lively",
        "Wholesome",
        "Cordial",
        "Eager",
        "Relaxed",
        "Skilled",
        "Tidy",
        "Calm",
        "Hopeful",
        "Positive",
        "Social",
        "Quick",
        "Fearless",
        "Daring",
        "Bold",
        "Quiet",
    ];

    const standardDictionary = {
        colors,
        animals,
        adjectives,
    };

    function makeNicknameGenerator({ rando, delimiter, dictionary, nicknameStructure, }) {
        const nicknameData = nicknameStructure.map(dictionarySet => dictionarySet.reduce((previous, wordGroupName) => [
            ...previous,
            ...dictionary[wordGroupName],
        ], []));
        return () => nicknameData
            .map(names => rando.randomSample(names))
            .join(delimiter);
    }

    function standardNicknameGenerator({ rando }) {
        return makeNicknameGenerator({
            rando,
            delimiter: " ",
            dictionary: standardDictionary,
            nicknameStructure: [["adjectives", "colors"], ["animals"]],
        });
    }

    function prepareApiConfigurator(configurators) {
        return async function configureApi(config) {
            const rando = await getRando();
            //
            // emails
            //
            const emails = await (async () => {
                let sendEmail$1;
                if (config.email === "mock-console") {
                    sendEmail$1 = sendEmail;
                }
                else {
                    sendEmail$1 = configurators
                        .configureMailgun(config.email)
                        .sendEmail;
                }
                const enabler = makeEmailEnabler(sendEmail$1);
                sendEmail$1 = enabler.sendEmail;
                const { disableEmails, enableEmails } = enabler;
                const { sendLoginEmail, recallLatestLoginEmail } = loginEmailRecaller(prepareSendLoginEmail({ sendEmail: sendEmail$1 }));
                return {
                    sendEmail: sendEmail$1,
                    enableEmails,
                    disableEmails,
                    sendLoginEmail,
                    recallLatestLoginEmail,
                };
            })();
            //
            // database
            //
            const { database, mockStorage } = await (async () => {
                const blueprint = {
                    core: {
                        app: {
                            app: true,
                            appOwnership: true,
                        },
                        permissions: {
                            privilege: true,
                            role: true,
                            roleHasPrivilege: true,
                            userHasRole: true,
                        },
                        user: {
                            account: true,
                            accountViaEmail: true,
                            accountViaGoogle: true,
                            latestLogin: true,
                            profile: true,
                        },
                    },
                    questions: {
                        questionLikes: true,
                        questionPosts: true,
                        questionReports: true,
                    },
                    store: {
                        billing: {
                            customers: true,
                            storeInfo: true,
                            subscriptions: true,
                            subscriptionPlans: true,
                        },
                        merchant: {
                            stripeAccounts: true,
                        },
                    },
                };
                async function mockWithStorage(mockStorage) {
                    return {
                        mockStorage,
                        database: await waitForProperties(processBlueprint({
                            blueprint,
                            process: path => dbbyX(mockStorage, path.join("-")),
                        }))
                    };
                }
                switch (config.database) {
                    case "mock-file": {
                        return mockWithStorage(configurators.configureMockFileStorage("./data.json"));
                    }
                    case "mock-memory": {
                        return mockWithStorage(memoryFlexStorage());
                    }
                    case "mock-localstorage": {
                        return mockWithStorage(simpleFlexStorage(window.localStorage));
                    }
                    default: {
                        return configurators.configureMongo({
                            blueprint,
                            config: { ...config, database: config.database },
                        });
                    }
                }
            })();
            //
            // crypto
            //
            const { signToken, verifyToken } = await (async () => {
                if (config.crypto.keys === "mock-mode") {
                    return {
                        signToken: mockSignToken(),
                        verifyToken: mockVerifyToken(),
                    };
                }
                else {
                    return configurators.configureTokenFunctions(config.crypto.keys);
                }
            })();
            //
            // stripe
            //
            const { stripeComplex, mockStripeOperations } = await mockStripeCircuit({
                rando,
                tableStorage: mockStorage,
                tables: { ...database.core, ...database.store },
            });
            //
            // api
            //
            const api = await (async () => {
                const generateNickname = standardNicknameGenerator({ rando });
                const authPolicies = prepareAuthPolicies({
                    config,
                    tables: database.core,
                    verifyToken,
                });
                return asApi({
                    auth: makeAuthApi({
                        rando,
                        config,
                        authPolicies,
                        tables: database.core,
                        signToken,
                        verifyToken,
                        generateNickname,
                        sendLoginEmail: emails.sendLoginEmail,
                    }),
                    administrative: makeAdministrativeApi({
                        config,
                        authTables: database.core,
                        authPolicies,
                    }),
                    questions: questionsApi({
                        rando,
                        config,
                        authPolicies,
                        questionsTables: database.questions,
                    }),
                });
            })();
            return {
                api,
                config,
                emails,
                database,
                stripeComplex,
                mockStripeOperations,
                platformAppId: config.platform.appDetails.appId,
                mockBrowser: async () => mockBrowser({
                    api,
                    mockStripeOperations,
                }),
            };
        };
    }

    class ConfigNotSupportedInBrowserError extends Error {
        constructor(message) {
            super(message);
        }
    }
    function nope(message) {
        return function () {
            throw new ConfigNotSupportedInBrowserError(message);
        };
    }
    const configureApiForBrowser = prepareApiConfigurator({
        configureMongo: nope("config.database.mongo not supported in browser"),
        configureMailgun: nope("config.email.mailgun not supported in browser"),
        configureTokenFunctions: nope("config.crypto.keys must be 'mock-mode' in browser"),
        configureMockFileStorage: nope("config.database 'mock-file' not supported in browser"),
    });

    async function mockConnectApp({ origins, latency, storage, appWindowLink, }) {
        const backend = await configureApiForBrowser(mockConfig({
            platformHome: appWindowLink,
            platformOrigins: origins,
        }));
        backend.emails.disableEmails();
        const apiLink = apiOrigin + "/";
        const ownerEmail = "creative@xiome.io";
        let appId = await storage.read("mock-app");
        if (!appId) {
            appId = await mockRegisterApp({
                apiLink,
                backend,
                ownerEmail,
                appOrigins: origins,
            });
            await storage.write("mock-app", appId);
        }
        console.log(`mock: app owner email "${ownerEmail}"`);
        backend.emails.enableEmails();
        const { remote, authMediator } = await mockWiredRemote({
            appId,
            apiLink,
            backend,
            storage,
            latency,
            appWindowLink,
        });
        const popups = mockPopups({
            mockStripeOperations: backend.mockStripeOperations,
        });
        return { appId, remote, authMediator, backend, popups };
    }

    /**
     * Convert a camel-case name into a dashed name
     * - for example
     *       dashify("BigManStyle")
     *       //> "big-man-style"
     */
    function dashify(camel) {
        return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
    }

    function registerComponents(components) {
        for (const [name, component] of Object.entries(components))
            customElements.define(dashify(name), component);
    }

    var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function mixinAutowatcher(Base) {
        var _unsubscribers, _a;
        return _a = class extends Base {
                constructor() {
                    super(...arguments);
                    this.auto = autowatcher();
                    _unsubscribers.set(this, []);
                    this.subscribeAutotrack = (track) => {
                        __classPrivateFieldGet$3(this, _unsubscribers, "f").push(track({
                            watcher: () => this.render(),
                            effect: () => this.requestUpdate(),
                        }));
                    };
                }
                render() { }
                firstUpdated(changes) {
                    this.subscribeAutotrack(this.auto.track);
                }
                dispose() {
                    for (const unsubscribe of __classPrivateFieldGet$3(this, _unsubscribers, "f"))
                        unsubscribe();
                    __classPrivateFieldSet$2(this, _unsubscribers, [], "f");
                    this.auto.dispose();
                }
            },
            _unsubscribers = new WeakMap(),
            _a;
    }

    function mixinInitiallyHidden(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                if (this.hasAttribute("initially-hidden"))
                    this.removeAttribute("initially-hidden");
            }
        };
    }

    function mixinAutotrack(...tracks) {
        return function (Base) {
            return class extends Base {
                firstUpdated(changes) {
                    super.firstUpdated(changes);
                    for (const track of tracks)
                        this.subscribeAutotrack(track);
                }
            };
        };
    }

    function mixinFocusable(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                this.setAttribute("focusable", "");
            }
        };
    }

    function mixinShare(s) {
        return function (Base) {
            return class extends Base {
                get share() {
                    return s;
                }
            };
        };
    }

    function arrayize(item) {
        return [item].flat();
    }
    const notUndefined = (x) => x !== undefined;
    function combineStyles(parentStyles, newStyles) {
        const styles = [
            ...(arrayize(parentStyles) ?? []),
            ...arrayize(newStyles),
        ];
        return styles
            .flat()
            .filter(notUndefined);
    }
    function mixinStyles(...newStyles) {
        return function (Base) {
            var _a;
            return _a = class extends Base {
                },
                _a.styles = combineStyles(Base.styles, newStyles),
                _a;
        };
    }

    const themeComponents = (theme, components) => {
        return objectMap(components, Component => mixinStyles(theme)(Component));
    };

    class Component2 extends mixinAutowatcher(mixinInitiallyHidden(LitElement)) {
        init() { }
        firstUpdated(changes) {
            this.init();
            super.firstUpdated(changes);
        }
    }
    class Component2WithShare extends Component2 {
        constructor() {
            super();
            if (this.share === undefined)
                throw new Error("component requires share");
        }
    }
    /////////
    class Component3 extends mixinInitiallyHidden(LitElement) {
        init() { }
        firstUpdated(changes) {
            super.firstUpdated(changes);
            this.init();
        }
    }
    class Component3WithShare extends Component3 {
        constructor() {
            super();
            if (this.share === undefined)
                throw new Error("component requires share");
        }
    }

    var theme = css `

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

*:focus {
	outline: var(--focus-outline, 3px solid cyan);
}

`;

    var styles$e = css `

button {
	font-size: unset;
	color: unset;
	background: transparent;
}

.container {
	position: relative;
	display: flex;
	flex-direction: row;
	user-select: none;
	cursor: pointer;
	border: none;
}

:host {
	display: inline-block;
	position: relative;
}

:host::before {
	opacity: 0;
	content: "copied!";
	display: block;
	position: absolute;
	top: -0.5em;
	right: -0.5em;
	background: #0a0c;
	padding: 0 0.5em;
	border-radius: 1em;
	pointer-events: none;
	z-index: 1;
}

:host(:not([copied]))::before {
	transition: opacity 500ms ease;
}

:host([copied])::before {
	opacity: 1;
}

.content {
	display: flex;
	justify-content: row;
}

.label::after {
	content: ":";
	margin-right: 0.2em;
}

.id {
	opacity: 0.75;
	max-width: var(--id-max-width, 6em);
	overflow: hidden;
	text-overflow: ellipsis;
}

.copy svg {
	width: 1em;
	height: 1em;
}

.copy {
	opacity: 0.4;
	transition: opacity 100ms linear;
}

.container:hover .copy {
	opacity: 0.9;
}

.container:active .copy {
	opacity: 1;
}

`;

    var clipboardIcon = svg `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clipboard"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>`;

    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioId = class XioId extends Component2 {
        constructor() {
            super(...arguments);
            this.copied = false;
        }
        async copy() {
            try {
                await navigator.clipboard.writeText(this.id);
                const activeElement = document.activeElement;
                if (activeElement)
                    activeElement.blur();
                if (this.copyTimeout) {
                    clearTimeout(this.copyTimeout);
                }
                this.copied = true;
                this.copyTimeout = setTimeout(() => {
                    this.copied = false;
                    this.copyTimeout = undefined;
                }, 1000);
            }
            catch (error) {
                console.error("failed to copy");
            }
        }
        render() {
            return html `
			<button class=container @click=${this.copy}>
				<div class=id>${this.id}</div>
				<div class=copy>
					${clipboardIcon}
				</div>
			</button>
		`;
        }
    };
    __decorate$e([
        property()
    ], XioId.prototype, "id", void 0);
    __decorate$e([
        property({ type: Boolean, reflect: true })
    ], XioId.prototype, "copied", void 0);
    XioId = __decorate$e([
        mixinFocusable,
        mixinStyles(styles$e)
    ], XioId);

    var styles$d = css `

svg, span {
	vertical-align: middle;
}

svg {
	width: 1.2em;
	height: 1.2em;
}

slot[name=loading] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

slot[name=error] * {
	color: var(--loading-error-color, red);
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    var warningSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M10 7a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4A.5.5 0 0 1 10 7z" fill="#626262"/><path d="M10 14.5a.75.75 0 1 0 0-1.5a.75.75 0 0 0 0 1.5z" fill="#626262"/><path d="M8.686 2.852a1.5 1.5 0 0 1 2.628 0l6.56 11.925A1.5 1.5 0 0 1 16.558 17H3.44a1.5 1.5 0 0 1-1.314-2.223L8.686 2.852zm1.752.482a.5.5 0 0 0-.876 0L3.003 15.26a.5.5 0 0 0 .438.741H16.56a.5.5 0 0 0 .438-.74L10.438 3.333z" fill="currentColor"/></g></svg>`;

    var spinnerIcon = svg `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-loader"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>`;

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioOp = class XioOp extends Component2 {
        constructor() {
            super(...arguments);
            this.mode = "none";
            // @property({type: Object})
            // op: Op<xPayload> = ops.none()
            this._op = ops.none();
            this.errorIcon = warningSvg;
            this.loadingIcon = spinnerIcon;
            this["loading-message"] = "loading...";
            this["error-message"] = "error";
        }
        get op() {
            return this._op;
        }
        set op(op) {
            const old = this._op;
            this._op = op;
            this.mode = ops.mode(op);
            this.requestUpdate("op", old);
        }
        render() {
            return ops.select(this.op, {
                none: () => html `
				<slot name=none></slot>
			`,
                loading: () => html `
				<slot name=loading>
					${this.loadingIcon}
					<span>${this["loading-message"]}</span>
				</slot>
			`,
                error: reason => html `
				<slot name=error>
					${this.errorIcon}
					<span>${reason ?? this["fallbackErrorMessage"]}</span>
				</slot>
			`,
                ready: () => html `
				<slot></slot>
			`,
            });
        }
    };
    __decorate$d([
        property({ type: String, reflect: true })
    ], XioOp.prototype, "mode", void 0);
    __decorate$d([
        property({ type: Object })
    ], XioOp.prototype, "op", null);
    __decorate$d([
        property()
    ], XioOp.prototype, "errorIcon", void 0);
    __decorate$d([
        property()
    ], XioOp.prototype, "loadingIcon", void 0);
    __decorate$d([
        property({ type: String })
    ], XioOp.prototype, "loading-message", void 0);
    __decorate$d([
        property({ type: String })
    ], XioOp.prototype, "error-message", void 0);
    XioOp = __decorate$d([
        mixinStyles(styles$d)
    ], XioOp);

    var styles$c = css `

:host {
	display: inline-block;
	width: var(--avatar-size, 3em);
	height: var(--avatar-size, 3em);
	border-radius: var(--avatar-border-radius, 0.3em);
	overflow: hidden;
	user-select: none;
}

.avatar {
	display: block;
	width: 100%;
	height: 100%;
	color: #444;
	background: #888;
}

.avatar[data-logged-in] {
	color: #fff;
}

svg, img {
	pointer-events: none;
	display: block;
	width: 100%;
	height: 100%;
	object-fit: cover;
}

`;

    var svgSilhouette = svg `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill="currentColor" fill-rule="evenodd" d="M12 14.002a.998.998 0 0 1-.998.998H1.001A1 1 0 0 1 0 13.999V13c0-2.633 4-4 4-4s.229-.409 0-1c-.841-.62-.944-1.59-1-4 .173-2.413 1.867-3 3-3s2.827.586 3 3c-.056 2.41-.159 3.38-1 4-.229.59 0 1 0 1s4 1.367 4 4v1.002z"/></svg>`;

    function cap(x, min, max) {
        return x < min
            ? min
            : x > max
                ? max
                : x;
    }
    function hsl(xHue, xSaturation, xLightness) {
        const hue = xHue % 360;
        const saturation = cap(xSaturation, 0, 100);
        const lightness = cap(xLightness, 0, 100);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    function getNiceColors(value) {
        const base = Math.ceil(value * 360);
        const split_a = (base - 30) % 360;
        const split_b = (base + 30) % 360;
        return {
            color1: hsl(base, 100, 90),
            color2: hsl(split_a, 50, 60),
            color3: hsl(split_b, 50, 40),
        };
    }

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioAvatar = class XioAvatar extends Component3 {
        renderBlankAvatar(spec) {
            return html `
			<div class=avatar>
				${svgSilhouette}
			</div>
		`;
        }
        renderSimpleAvatar({ value }) {
            const { color1, color2, color3 } = getNiceColors(value);
            const style = `color: ${color1}; background: linear-gradient(to bottom right, ${color2}, ${color3});`;
            return html `
			<div class=avatar style=${style}>
				${svgSilhouette}
			</div>
		`;
        }
        renderImageAvatar({ link }) {
            return html `
			<div class=avatar>
				<img src="${link}" alt=""/>
			</div>
		`;
        }
        render() {
            const { spec = { type: "blank" } } = this;
            switch (spec.type) {
                case "blank":
                    return this.renderBlankAvatar(spec);
                case "simple":
                    return this.renderSimpleAvatar(spec);
                case "image":
                    return this.renderImageAvatar(spec);
                default:
                    return html `avatar missing`;
            }
        }
    };
    __decorate$c([
        property({ type: Object })
    ], XioAvatar.prototype, "spec", void 0);
    XioAvatar = __decorate$c([
        mixinStyles(styles$c)
    ], XioAvatar);

    var styles$b = css `

:host {
	display: inline-block;
	--_padding: var(--xio-button-padding, 0.2em 0.5em);
	--_background: var(--xio-button-background, transparent);
	--_border: var(--xio-button-border, 1px solid);
	--_border-radius: var(--xio-button-border-radius, 0);
	--_opacity: var(--xio-button-opacity, 0.7);
	--_hover-opacity: var(--xio-button-hover-opacity, 1);
	--_hover-color: var(--xio-button-hover-color, inherit);
	--_hover-background: var(--xio-button-hover-background, var(--_background));
	--_disabled-opacity: var(--xio-button-disabled-opacity, 0.2);
	--_disabled-border-style: var(--xio-button--disabled-border-style, dashed);
}

button {
	cursor: pointer;
	font: inherit;
	color: inherit;
	padding: var(--_padding);
	font-weight: bold;
	background: var(--_background);
	border: var(--_border);
	border-radius: var(--_border-radius);
	opacity: var(--_opacity);
}

button:not([disabled]):hover,
button:not([disabled]):focus {
	opacity: var(--_hover-opacity);
	color: var(--_hover-color);
	background: var(--_hover-background);
}

button[disabled] {
	cursor: default;
	opacity: var(--_disabled-opacity);
	border-style: var(--_disabled-border-style);
}

`;

    class PressEvent extends CustomEvent {
        constructor(button) {
            super("press", { detail: button });
        }
    }

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioButton = class XioButton extends Component2 {
        constructor() {
            super(...arguments);
            this["disabled"] = false;
            this.handleClick = () => {
                const event = new PressEvent(this);
                if (this.onpress)
                    this.onpress(event);
                if (!this.disabled)
                    this.dispatchEvent(event);
                event.stopPropagation();
            };
        }
        focus() {
            this.shadowRoot.querySelector("button").focus();
        }
        render() {
            return html `
			<button
				part=button
				@click=${this.handleClick}
				?disabled=${this.disabled}>
					<slot></slot>
			</button>
		`;
        }
    };
    __decorate$b([
        property({ type: Boolean, reflect: true })
    ], XioButton.prototype, "disabled", void 0);
    __decorate$b([
        property({ type: Function })
    ], XioButton.prototype, "onpress", void 0);
    XioButton = __decorate$b([
        mixinFocusable,
        mixinStyles(styles$b)
    ], XioButton);

    var styles$a = css `

.example {
	color: #f90;
}

`;

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioExample = class XioExample extends Component2 {
        render() {
            return html `
			<div class=example>
				<p>xio-example</p>
				<slot></slot>
			</div>
		`;
        }
    };
    XioExample = __decorate$a([
        mixinStyles(styles$a)
    ], XioExample);

    var styles$9 = css `

* {box-sizing: border-box;}

:host {
	display: inline-block;
	vertical-align: middle;
	color: white;
}

:host([disabled]) {
	opacity: 0.25;
}

button {
	display: inline-block;
	border: unset;
	color: unset;
	background: unset;
}

button {
	position: relative;
	width: 1.5em;
	height: 1.5em;
	background: #3338;
	box-shadow: inset 1px 2px 3px #000a;
	border-radius: 0.5em;
	border: 1px solid #fff4;
}

button[data-mode="ready"] {
	cursor: pointer;
}

button[data-mode="ready"]:hover,
button[data-mode="ready"]:focus {
	background: #5558;
	border: 1px solid #fff8;
}

button > span {
	display: inline-block;
}

button svg {
	width: 100%;
	height: 100%;
}

button .error {
	display: inline-block;
	position: absolute;
	top: 80%;
	left: 0;
	width: max-content;
	max-width: 16em;
	color: red;
	background: #200a;
	text-shadow: 1px 2px 3px #0008;
	text-align: left;
	padding: 0.2em 0.5em;
	border-radius: 0.5em;
	pointer-events: none;
}

button[data-mode="loading"] svg,
button[data-mode="error"] svg {
	padding: 10%;
}

button[data-mode="error"] svg {
	color: red;
	animation: fade 1s ease infinite alternate;
}

button[data-mode="loading"] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    class CheckEvent extends CustomEvent {
        constructor(checkbox) {
            super("press", { detail: checkbox });
        }
    }

    var checkIcon = svg `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioCheckbox = class XioCheckbox extends Component2 {
        constructor() {
            super(...arguments);
            this.loading = ops.none();
            this["initially-checked"] = false;
            this["error-message"] = "error";
            this.disabled = false;
            this.handleClick = () => {
                if (!this.disabled) {
                    this.toggle();
                    const activeElement = document.activeElement;
                    if (activeElement)
                        activeElement.blur();
                }
            };
        }
        init() {
            this.loading = ops.ready(this["initially-checked"]);
        }
        get checked() {
            return ops.value(this.loading);
        }
        set checked(value) {
            this.loading = ops.ready(value);
        }
        async toggle(previousChecked = ops.value(this.loading), dispatchEvent = true) {
            const checked = !previousChecked;
            const isNotDisabled = !this.disabled;
            const isLoadingDone = ops.isReady(this.loading);
            return (isNotDisabled && isLoadingDone)
                ? ops.operation({
                    setOp: op => this.loading = op,
                    errorReason: this["error-message"],
                    promise: (async () => {
                        await (this.save ?? (async () => { }))(checked);
                        if (dispatchEvent) {
                            const event = new CheckEvent(this);
                            if (this.oncheck)
                                this.oncheck(event);
                            this.dispatchEvent(event);
                            event.stopPropagation();
                        }
                        return checked;
                    })(),
                })
                : checked;
        }
        render() {
            return html `
			<button
				data-mode="${ops.mode(this.loading)}"
				?data-checked=${ops.value(this.loading)}
				@click=${this.handleClick}>
					${ops.select(this.loading, {
            none: () => null,
            loading: () => spinnerIcon,
            error: reason => html `${warningSvg}<div class=error>${reason}</div>`,
            ready: checked => checked
                ? checkIcon
                : null,
        })}
			</button>
		`;
        }
    };
    __decorate$9([
        property()
    ], XioCheckbox.prototype, "loading", void 0);
    __decorate$9([
        property({ type: Boolean })
    ], XioCheckbox.prototype, "initially-checked", void 0);
    __decorate$9([
        property({ type: String })
    ], XioCheckbox.prototype, "error-message", void 0);
    __decorate$9([
        property({ type: Boolean, reflect: true })
    ], XioCheckbox.prototype, "disabled", void 0);
    __decorate$9([
        property({ type: Function })
    ], XioCheckbox.prototype, "oncheck", void 0);
    __decorate$9([
        property({ type: Function })
    ], XioCheckbox.prototype, "save", void 0);
    XioCheckbox = __decorate$9([
        mixinFocusable,
        mixinStyles(styles$9)
    ], XioCheckbox);

    var styles$8 = css `

/* * { outline: 1px solid #f002; } */

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
	--height: var(--xio-text-input-height, 5rem);
	--pad: var(--xio-text-input-pad, 0.2em);
	--font: var(--xio-text-input-font, inherit);
	--color: var(--xio-text-input-color, inherit);
	--label-font: var(--xio-text-input-label-font, inherit);
	--label-color: var(--xio-text-input-label-color, inherit);
	--problems-font: var(--xio-text-input-problems-font, inherit);
	--problems-color: var(--xio-text-input-problems-color);
	--background: var(--xio-text-input-background, transparent);
	--valid-color: var(--xio-text-input-valid-color, #00ff8c);
	--invalid-color: var(--xio-text-input-invalid-color, #ff6100);
	--border: var(--xio-text-input-border, 1px solid);
	--border-radius: var(--xio-text-input-border-radius, 0.3em);
}

:host([hidden]) {
	display: none;
}

label {
	font: var(--label-font);
	color: var(--label-color);
}

slot {
	display: block;
	padding: 0 var(--pad);
}

.flexy {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.flexy > * {
	flex: 0 0 auto;
}

:host([textarea]) .flexy {
	flex-direction: column;
}

.inputbox {
	display: block;
	/* max-width: var(--width); */
	position: relative;
	flex: 1 1 auto;
}

:host([textarea]) .inputbox {
	flex: 1 1 auto;
	/* max-width: unset; */
}

.inputbox svg {
	position: absolute;
	display: block;
	top: var(--pad);
	right: var(--pad);
	width: 1.2em;
	height: 1.2em;
	pointer-events: none;
}

.container[data-valid] .inputbox svg {
	color: var(--valid-color);
}

.container:not([data-valid]) .inputbox svg {
	color: var(--invalid-color);
}

#textinput {
	min-width: 1em;
	width: 100%;
	font: var(--font);
	padding: var(--pad);
	padding-right: calc(1em + calc(2 * var(--pad)));
	margin: 0;
	color: var(--color);
	background: var(--background);
	border: var(--border);
	border-radius: var(--border-radius);
	text-overflow: ellipsis;
}

textarea {
	min-height: var(--height);
}

.problems {
	display: flex;
	font: var(--problems-font);
	padding: 0 calc(2 * var(--pad));
	flex-direction: column;
	justify-content: flex-start;
	flex: 1 1 auto;
	/* min-width: 12rem; */
	list-style: none;
	color: var(--problems-color, var(--invalid-color));
}

.problems > li {
	margin-top: 0.2em;
}

`;

    function noopParser(text) {
        return text;
    }

    class EnterPressEvent extends CustomEvent {
        constructor() {
            super("enterpress", {
                bubbles: true,
                composed: true,
                detail: undefined,
            });
        }
    }

    class ValueChangeEvent extends CustomEvent {
        constructor(value) {
            super("valuechange", {
                bubbles: true,
                composed: true,
                detail: { value },
            });
        }
    }

    var svgCircleCheck = svg `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>`;

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioTextInput = class XioTextInput extends Component2 {
        constructor() {
            super(...arguments);
            this["initial"] = "";
            this["readonly"] = false;
            this["textarea"] = false;
            this["hide-validation"] = false;
            this["show-validation-when-empty"] = false;
            this["disabled"] = false;
            this["placeholder"] = "";
            this["hidden"] = false;
            this.parser = noopParser;
            this.problems = [];
            this.onvaluechange = () => { };
            this.onenterpress = () => { };
            this.draft = "";
            this.lastDraft = "";
            this.dispatchValueChange = () => {
                const { draft, lastDraft } = this;
                if (draft !== lastDraft)
                    this.dispatchEvent(new ValueChangeEvent(this.value));
                this.lastDraft = draft;
            };
            this.dispatchEnterPress = () => {
                this.dispatchEvent(new EnterPressEvent());
            };
            this.updateFromRawInput = () => {
                this.draft = this.input.value;
            };
            this.handleInputKeyUp = (event) => {
                this.updateFromRawInput();
                if (!this.textarea && event.key === "Enter") {
                    this.dispatchEnterPress();
                }
                else {
                    this.dispatchValueChange();
                }
            };
            this.handleInputChange = () => {
                this.updateFromRawInput();
                this.dispatchValueChange();
            };
        }
        focus() {
            this.shadowRoot.querySelector("#textinput").focus();
        }
        get value() {
            const { draft } = this;
            const parsed = (this.parser ?? noopParser)(draft);
            this.problems = this.validator ? this.validator(parsed) : [];
            return this.problems.length === 0
                ? parsed
                : undefined;
        }
        get text() {
            return this.draft;
        }
        set text(value) {
            const { input } = this;
            if (input) {
                this.input.value = value;
                this.updateFromRawInput();
            }
            else {
                this.initial = value;
            }
        }
        init() {
            this.draft = this.initial;
            this.addEventListener("valuechange", this.onvaluechange);
            this.addEventListener("enterpress", this.onenterpress);
        }
        render() {
            const { readonly, disabled, problems, draft, placeholder, textarea, validator, handleInputKeyUp, handleInputChange, } = this;
            const valid = problems.length === 0;
            const showValidation = !this["hide-validation"] && !readonly && validator && (this["show-validation-when-empty"]
                ? true
                : draft.length !== 0);
            const showProblems = showValidation && !valid;
            const icon = showValidation
                ? valid
                    ? svgCircleCheck
                    : warningSvg
                : null;
            return html `
			<div class=container ?data-valid=${valid}>
				<label for=textinput part=label><slot></slot></label>
				<div class=flexy>
					<div class=inputbox part=inputbox>
						${showValidation ? icon : null}
						${textarea ? html `
							<textarea
								id=textinput
								part=textinput
								.value="${draft}"
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@keyup=${handleInputKeyUp}
								@change=${handleInputChange}
							></textarea>
						` : html `
							<input
								id=textinput
								type=text
								part=textinput
								.value="${draft}"
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@keyup=${handleInputKeyUp}
								@change=${handleInputChange}
								/>
						`}
					</div>
					<ol class=problems part=problems>
						${showProblems
            ? problems.map(problem => html `
								<li>${problem}</li>
							`)
            : null}
					</ol>
				</div>
			</div>
		`;
        }
    };
    __decorate$8([
        property({ type: String, reflect: true })
    ], XioTextInput.prototype, "initial", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "readonly", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "textarea", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hide-validation", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "show-validation-when-empty", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "disabled", void 0);
    __decorate$8([
        property({ type: String, reflect: true })
    ], XioTextInput.prototype, "placeholder", void 0);
    __decorate$8([
        property({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hidden", void 0);
    __decorate$8([
        property({ type: Function })
    ], XioTextInput.prototype, "parser", void 0);
    __decorate$8([
        property({ type: Function })
    ], XioTextInput.prototype, "validator", void 0);
    __decorate$8([
        property({ type: Object })
    ], XioTextInput.prototype, "problems", void 0);
    __decorate$8([
        query("#textinput")
    ], XioTextInput.prototype, "input", void 0);
    __decorate$8([
        property({ type: String })
    ], XioTextInput.prototype, "draft", void 0);
    XioTextInput = __decorate$8([
        mixinFocusable,
        mixinStyles(styles$8)
    ], XioTextInput);

    var styles$7 = css `

:host {
	display: inline-block;
	--local-avatar-size: var(--avatar-size, 3em);
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

xio-avatar {
	flex: 0 0 auto;
	margin-right: 0.4em;
	--avatar-size: var(--local-avatar-size);
}

.box {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	flex: 1;
	flex-basis: 8em;
}

.textfields {
	flex: 1 1 auto;
	margin-right: 1em;
}

.detail {
	margin-top: 0.5em;
}

.buttonbar {
	margin-top: 0.5em;
}

.cardplate > * {
	display: block;
}

.tags {
	list-style: none;
	font-size: 0.6em;
	cursor: default;
}

.tags > li {
	display: inline-block;
	margin: 0 0.1em;
	padding: 0 0.25em;
	border: 1px solid;
	border-radius: 1em;
}

[data-tag=staff] {
	color: var(--cobalt-tagcolor-staff, lime);
}

[data-tag=banned] {
	color: var(--cobalt-tagcolor-banned, red);
}

p[data-field=tagline] {
	opacity: 0.7;
	font-size: 0.8em;
	font-style: italic;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7rem;
}

xio-text-input + xio-text-input {
	margin-top: 0.1em;
}

.detail {
	font-size: 0.7em;
	list-style: none;
}

.detail > li {
	margin-top: 0.2em;
}

.detail > li > :first-child {
	font-weight: bold;
}

.detail code {
	font-size: 0.6em;
	padding: 0.2em;
	border-radius: 0.3em;
	word-break: break-all;
	background: #0002;
}

.roles {
	font-size: 0.6em;
	list-style: none;
	padding: 0;
	margin-top: 0.3rem;
}

.roles li {
	display: inline-block;
	border: 1px solid;
	border-radius: 1em;
	padding: 0.1em 0.3em;
	line-height: 0.8em;
}

`;

    function renderText({ field, text, input }) {
        return input
            ? html `
			<xio-text-input
				data-field="${field}"
				initial=${text}
				part="xiotextinput"
				exportparts="${`
					label: xiotextinput-label,
					textinput: xiotextinput-textinput,
					problems: xiotextinput-problems,
				`}"
				show-validation-when-empty
				?readonly=${input.readonly}
				?hide-validation=${!input.draftIsChanged}
				.validator=${input.validator}
				@valuechange=${input.onvaluechange}>
					<span>${input.label}</span>
			</xio-text-input>
		`
            : html `
			<p part="textfield" data-field="${field}">${text}</p>
		`;
    }

    function renderRoles(user) {
        return html `
		<ul class=roles>
			${user.roles.map(role => html `
				<li
					data-role-label="${role.label}"
					data-role-id="${role.roleId}">
						${role.label}
				</li>
			`)}
		</ul>
	`;
    }

    function select(selector, context = document) {
        return context.querySelector(selector);
    }

    function formatDate(milliseconds) {
        const d = new Date(milliseconds);
        const twoDigit = (n) => n.toString().padStart(2, "0");
        const year = twoDigit(d.getFullYear());
        const month = twoDigit(d.getMonth() + 1);
        const day = twoDigit(d.getDate());
        const hours24 = d.getHours();
        let hours = d.getHours();
        hours %= 12;
        hours = hours ? hours : 12;
        const minutes = twoDigit(d.getMinutes());
        const ampm = hours24 >= 12 ? "pm" : "am";
        const timezoneOffsetMinutes = -d.getTimezoneOffset();
        const timezoneOffset = (timezoneOffsetMinutes / 60).toFixed(timezoneOffsetMinutes % 60 === 0
            ? 0
            : 1);
        const timezoneUtc = timezoneOffsetMinutes === 0
            ? "UTC"
            : `UTC${timezoneOffsetMinutes < 0 ? "" : "+"}${timezoneOffset}`;
        const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const timezone = `${timezoneName} ${timezoneUtc}`;
        const date = `${year}-${month}-${day}`;
        const time = `${hours}:${minutes} ${ampm}`;
        const zone = `${timezone}`;
        const full = `${date} ${time} (${zone})`;
        return {
            date,
            time,
            zone,
            full,
        };
    }

    function renderDetails(user) {
        return html `
		<ul class=detail>
			<li>
				<span>joined:</span>
				<span>${formatDate(user.stats.joined).date}</span>
			</li>
			<li>
				<span>user id:</span>
				<span><xio-id id="${user.userId}"></xio-id></span>
			</li>
		</ul>
	`;
    }

    function makeProfileDraft(profile) {
        return {
            tagline: profile.tagline,
            nickname: profile.nickname,
        };
    }

    function whenOpReady(op, render) {
        return ops.isReady(op)
            ? render(ops.value(op))
            : null;
    }

    function renderOp(op, render, more = null) {
        return html `
		<xio-op .op=${op}>
			${whenOpReady(op, render)}
			${more}
		</xio-op>
	`;
    }

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioProfileCard_state, _XioProfileCard_actions;
    let XioProfileCard = class XioProfileCard extends Component2 {
        constructor() {
            super(...arguments);
            _XioProfileCard_state.set(this, this.auto.state({
                busy: ops.ready(undefined),
            }));
            _XioProfileCard_actions.set(this, this.auto.actions({
                setBusy: (op) => {
                    __classPrivateFieldGet$2(this, _XioProfileCard_state, "f").busy = op;
                },
            }));
            this.profileDraft = undefined;
            this.problems = [];
            this.handleChange = debounce2(200, () => {
                if (!this.user)
                    return;
                const { profileDraft, isChanged } = this.generateNewProfileDraftFromInputs();
                this.profileDraft = isChanged ? profileDraft : undefined;
            });
            this.handleSave = async () => {
                await ops.operation({
                    promise: this.saveProfile(this.profileDraft)
                        .finally(() => {
                        this.profileDraft = null;
                    }),
                    setOp: op => __classPrivateFieldGet$2(this, _XioProfileCard_actions, "f").setBusy(op),
                });
            };
        }
        init() {
            __classPrivateFieldGet$2(this, _XioProfileCard_actions, "f").setBusy(ops.ready(undefined));
        }
        get draftIsChanged() {
            return !!this.profileDraft;
        }
        get readonly() {
            return !this.saveProfile;
        }
        getTextInputField(name) {
            return select(`xio-text-input[data-field="${name}"]`, this.shadowRoot);
        }
        generateNewProfileDraftFromInputs() {
            const { profile } = this.user;
            const profileDraft = makeProfileDraft(profile);
            const nicknameInput = this.getTextInputField("nickname");
            if (!nicknameInput)
                return { profileDraft, isChanged: false };
            const taglineInput = this.getTextInputField("tagline");
            profileDraft.nickname = nicknameInput.value;
            profileDraft.tagline = taglineInput.value;
            this.problems = [...nicknameInput.problems, ...taglineInput.problems];
            const isChanged = !deepEqual(makeProfileDraft(profile), profileDraft);
            return { profileDraft, isChanged };
        }
        render() {
            const { user, draftIsChanged } = this;
            if (!user)
                return null;
            const avatarSpec = user.profile.avatar;
            return renderOp(__classPrivateFieldGet$2(this, _XioProfileCard_state, "f").busy, () => html `
			<div class=container ?data-readonly=${this.readonly}>
				<xio-avatar .spec=${avatarSpec}></xio-avatar>
				<div class=box>
					<div class=textfields>
						${renderText({
            field: "nickname",
            text: user.profile.nickname,
            input: this.readonly
                ? undefined
                : {
                    label: "nickname",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.nickname,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderText({
            field: "tagline",
            text: user.profile.tagline,
            input: this.readonly
                ? undefined
                : {
                    label: "tagline",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.tagline,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderRoles(user)}
						${this.readonly ? null : html `
							<div class=buttonbar>
								<xio-button
									?disabled=${!this.profileDraft || this.problems.length > 0}
									@press=${this.handleSave}>
										<slot name=save-button>save profile</slot>
								</xio-button>
							</div>
						`}
					</div>
					${this["show-details"]
            ? renderDetails(user)
            : null}
				</div>
			</div>
		`);
        }
    };
    _XioProfileCard_state = new WeakMap(), _XioProfileCard_actions = new WeakMap();
    __decorate$7([
        property({ type: Boolean })
    ], XioProfileCard.prototype, "show-details", void 0);
    __decorate$7([
        property({ type: Object })
    ], XioProfileCard.prototype, "user", void 0);
    __decorate$7([
        property({ type: Object })
    ], XioProfileCard.prototype, "saveProfile", void 0);
    __decorate$7([
        property({ type: Object })
    ], XioProfileCard.prototype, "profileDraft", void 0);
    XioProfileCard = __decorate$7([
        mixinStyles(styles$7)
    ], XioProfileCard);

    function xioComponents() {
        return {
            XioId,
            XioOp,
            XioAvatar,
            XioButton,
            XioExample,
            XioCheckbox,
            XioTextInput,
            XioProfileCard,
        };
    }

    var adminManagerCss = css `

.adminmanager .adminassigner {
	display: flex;
	flex-direction: row;
	margin: 0.5em 0;
}

.adminmanager .adminassigner > * {
	display: block;
}

.adminmanager .adminassigner > xio-text-input {
	flex: 1 1 auto;
}

.adminmanager .adminassigner > xio-text-input {
	width: 100%;
	max-width: 100%;
}

.adminmanager .adminassigner > xio-text-input::part(problems) {
	min-width: unset;
}

.adminmanager .adminassigner > xio-button {
	margin-top: 1.1em;
	margin-left: 0.3em;
}

.adminmanager .adminlist ul {
	list-style: none;
	padding: 0 1em;
	border: 1px solid #fff1;
}

.adminmanager .adminlist li {
	display: flex;
	flex-direction: row;
	align-content: center;
	padding: 0.3em 0;
	font-size: 0.8em;
}

.adminmanager .adminlist li + li {
	border-top: 1px solid #fff1;
}

.adminmanager .adminlist li > * {
	display: block;
}

.adminmanager .adminlist li > span {
	flex: 1 1 auto;
	display: flex;
	align-items: center;
	word-break: break-all;
}

.adminmanager .adminlist li > xio-button {
	color: #fff3;
}

`;

    var styles$6 = css `

:host {
	display: block;
}

.app-list {
	margin-top: 2em;
	margin-bottom: 2em;
}

.app-list > xio-op {
	display: block;
	border: 1px solid #f00;
	margin-top: 0.5em;
	border: 1px solid #fff1;
	border-radius: 0.2em;
}

.app-list > xio-op[mode="loading"] {
	padding: 4em 2em;
}

.app > * + * {
	margin-top: 0.3em;
}

.app + .app {
	margin-top: 1.5em;
}

.app > * {
	padding: 0.4em 1rem;
}

.app-header {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	justify-content: flex-end;
	padding: 0;
	background: #0001;
}

.app-header .title {
	max-width: 100%;
	flex: 1 0 auto;
	padding: 0.3em 1em;
}

.app-header .title h3 {
	font-size: 1.5em;
	font-weight: bold;
}

.app-header .title h3::before {
	content: "🌐";
	color: white;
}

.app-header .stats {
	display: flex;
	flex-direction: row;
	justify-content: center;
	flex-wrap: wrap;
	padding: 0.2em;
}

.app-header .stats [data-stat] {
	display: flex;
	flex-direction: column;
	justify-content: flex-end;
	max-width: 6em;
	text-align: center;
}

.app-header .stats [data-stat] > span {
	padding: 0.1em 0.6em;
}

.app-header .stats [data-stat] > span:nth-child(1) {
	justify-self: flex-start;
}

.app-header .stats [data-stat] > span:nth-child(2) {
	opacity: 0.3;
	font-size: 0.6em;
}

.twoside {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.twoside > div {
	max-width: 100%;
	flex: 1 0 16em;
	padding-bottom: 1em;
}

.twoside > div:nth-child(1) {
	padding-right: 1rem;
}

.editside > .buttons {
	display: flex;
	justify-content: center;
	align-items: center;
}

.app-form > * + * {
	margin-top: 0.3em;
}

.app-form xio-button {
	margin-top: 0.6em;
}

.app-options {
	border: 1px solid #fff1;
	padding: 1em;
}

.app-options > * + * {
	margin-top: 3em;
}

code {
	display: inline-block;
	font-size: 0.8em;
	padding: 0.2em;
	border-radius: 0.3em;
	background: #0002;
	overflow-wrap: anywhere;
	word-break: break-all;
}

code.id {
	opacity: 0.7;
	font-size: 0.5em;
}

.codeblock {
	display: block;
}

.htmlcode { color: #fff6; }
.htmlcode [data-syntax=tag] { color: deepskyblue; }
.htmlcode [data-syntax=attr] { color: skyblue; }
.htmlcode [data-syntax=data] { color: #aaffa0; }
.htmlcode [data-syntax=indent] {
	display: block;
	margin-left: 1em;
}

.app-code > * {
	margin-top: 1em;
}

.app-code code {
	display: block;
	font-size: 0.6em;
	padding: 1em;
	margin: 0.5em 0;
}

.delete-app-button {
	display: block;
	text-align: right;
	--xio-button-hover-color: red;
}

${adminManagerCss}

.app-list {
	margin-bottom: 5rem;
}

.app-registration {
	max-width: 40em;
	margin-bottom: 5em;
}

`;

    function renderXiomeConfig(appId) {
        const h = (syntax, s) => html `<span data-syntax=${syntax}>${s}</span>`;
        const tag = (s) => h("tag", s);
        const attr = (s) => h("attr", s);
        const data = (s) => h("data", s);
        const glue = (s) => h("glue", s);
        const quote = glue(`"`);
        const bundle_link = "https://unpkg.com/xiome/x/xiome.bundle.min.js";
        return html `
		${glue(`<`)}${tag(`script`)} ${attr(`async`)} ${attr(`defer`)} ${attr(`src`)}${glue(`=`)}${quote}${data(bundle_link)}${quote}${glue(`>`)}${glue(`</`)}${tag(`script`)}${glue(`>`)}
		<br/>
		${glue(`<`)}${tag(`xiome-config`)} ${attr(`app`)}${glue(`=`)}${quote}${data(appId)}${quote}${glue(`>`)}${glue(`</`)}${tag(`xiome-config`)}${glue(`>`)}
	`;
    }

    const parseOrigins = (text) => text
        .split("\n")
        .map(line => line.trim().toLowerCase())
        .filter(line => line.length > 0);

    function validateAppFormDraft(formDraft) {
        const problems = [
            ...appDraftValidators.label(formDraft.label),
            ...appDraftValidators.home(formDraft.home),
            ...appDraftValidators.additionalOrigins(formDraft.additionalOrigins),
        ];
        return problems;
    }

    function getEmptyAppFormDraft() {
        return {
            home: "",
            label: "",
            additionalOrigins: [],
        };
    }

    function makeAppForm({ clearOnSubmit, submitButtonText, showAdditionalOrigins, initialValues = getEmptyAppFormDraft(), query, submit, requestUpdate, }) {
        const state = {
            problems: [],
            formDisabled: false,
            draft: initialValues,
            get valid() {
                return !this.formDisabled
                    && this.draft
                    && this.problems.length === 0;
            },
        };
        function getFormElements() {
            return {
                home: query(`.app-form [data-form="home"]`),
                label: query(`.app-form [data-form="label"]`),
                additionalOrigins: query(`.app-form [data-form="additional-origins"]`),
            };
        }
        function setFormValues(draft) {
            const elements = getFormElements();
            elements.home.text = draft.home;
            elements.label.text = draft.label;
            elements.additionalOrigins.text = draft.additionalOrigins.join("\n");
        }
        const refreshAndValidateForm = () => {
            const { home, label, additionalOrigins } = getFormElements();
            state.draft = {
                home: home.value,
                label: label.value,
                additionalOrigins: additionalOrigins.value,
            };
            state.problems = validateAppFormDraft(state.draft);
            requestUpdate();
        };
        function handleFormChange() {
            state.problems = [];
            if (!state.formDisabled)
                refreshAndValidateForm();
        }
        async function handleSubmitClick() {
            refreshAndValidateForm();
            state.formDisabled = true;
            requestUpdate();
            try {
                await submit(state.draft);
                if (clearOnSubmit) {
                    initialValues = getEmptyAppFormDraft();
                    setFormValues(initialValues);
                }
                else {
                    initialValues = state.draft;
                }
            }
            finally {
                state.formDisabled = false;
                requestUpdate();
            }
        }
        function render({ partNamespace }) {
            const { formDisabled, draft, problems } = state;
            const changes = !deepEqual(initialValues, draft);
            const submitButtonDisabled = !changes
                || formDisabled
                || problems.length > 0;
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: ${partNamespace}-appform-xiotextinput-label,
			textinput: ${partNamespace}-appform-xiotextinput-textinput,
			problems: ${partNamespace}-appform-xiotextinput-problems,
		`;
            const renderTextInput = ({ hide, textarea, label, dataForm, initialText, showValidationWhenEmpty, parser, validator, }) => html `
			<xio-text-input
				?textarea=${textarea}
				part="${partNamespace}-appform-xiotextinput"
				exportparts="${exportPartsTextInput}"
				data-form="${dataForm}"
				initial="${initialText}"
				?hidden=${hide}
				?disabled=${formDisabled}
				?hide-validation=${!changes}
				?show-validation-when-empty=${showValidationWhenEmpty}
				.parser=${parser}
				.validator=${validator}
				@valuechange=${handleFormChange}>
					<span part=xio-text-input-label>
						${label}
					</span>
			</xio-text-input>
		`;
            return html `
			<div class=app-form>
				<slot name=create-app-heading></slot>

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "label",
            label: "community name",
            initialText: initialValues.label,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.label,
        })}

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "home",
            label: `website homepage, like "https://chasemoskal.com/"`,
            initialText: initialValues.home,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.home,
        })}

				${renderTextInput({
            hide: !showAdditionalOrigins,
            textarea: true,
            dataForm: "additional-origins",
            label: "(optional) additional domain names",
            initialText: initialValues.additionalOrigins.join("\n"),
            showValidationWhenEmpty: true,
            parser: parseOrigins,
            validator: appDraftValidators.additionalOrigins,
        })}

				<xio-button
					class="create-app-button"
					?disabled=${submitButtonDisabled}
					@press=${handleSubmitClick}>
						${submitButtonText}
				</xio-button>
			</div>
		`;
        }
        return { render };
    }

    function adminManagerControls({ app, state, actions, manageAdminsService }) {
        const { appId } = app;
        const load = (firstStep = Promise.resolve(undefined)) => (ops.operation({
            promise: firstStep
                .then(() => manageAdminsService.listAdmins({ appId })),
            setOp: admins => actions.setAdmins(admins)
        }));
        async function listAdmins() {
            await load();
        }
        async function assignAdmin() {
            const { email } = state.assignerDraft;
            actions.setAssignerDraft({ email: undefined });
            await load(manageAdminsService.assignAdmin({ appId, email }));
        }
        async function revokeAdmin(userId) {
            await load(manageAdminsService.revokeAdmin({ appId, userId }));
        }
        return { listAdmins, assignAdmin, revokeAdmin };
    }

    function adminManagerStateAndActions() {
        const auto = autowatcher();
        const state = auto.state({
            admins: ops.none(),
            assignerDraft: {
                email: undefined,
            },
        });
        const actions = auto.actions({
            setAdmins(op) {
                state.admins = op;
            },
            setAssignerDraft(draft) {
                state.assignerDraft = draft;
            },
        });
        return {
            track: auto.track,
            state,
            actions,
        };
    }

    function makeAdminManager({ app, manageAdminsService, query }) {
        const { state, actions, track } = adminManagerStateAndActions();
        const controls = adminManagerControls({
            app,
            state,
            actions,
            manageAdminsService,
        });
        function handleEmailChange(event) {
            const email = event.detail.value ?? undefined;
            actions.setAssignerDraft({ email });
        }
        function handleAssignButtonPress() {
            const textInput = query(".adminassigner xio-text-input");
            controls.assignAdmin();
            textInput.text = "";
        }
        function renderAdminAssigner() {
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: adminmanager-xiotextinput-label,
			textinput: adminmanager-xiotextinput-textinput,
			problems: adminmanager-xiotextinput-problems,
		`;
            return html `
			<div class=adminassigner>
				<xio-text-input
					part=adminmanager-xiotextinput
					exportparts="${exportPartsTextInput}"
					.validator=${emailValidator}
					@valuechange=${handleEmailChange}>
						email
				</xio-text-input>
				<xio-button
					?disabled=${!state.assignerDraft.email}
					@press=${handleAssignButtonPress}>
						grant
				</xio-button>
			</div>
		`;
        }
        function renderAdminList() {
            return html `
			<div class=adminlist>
				${renderOp(state.admins, admins => html `
					<ul>
						${admins.map(({ email, userId }) => html `
							<li>
								<span>${email}</span>
								<xio-button @press=${() => controls.revokeAdmin(userId)}>
									revoke
								</xio-button>
							</li>
						`)}
					</ul>
				`)}
			</div>
		`;
        }
        function render() {
            return html `
			${renderAdminAssigner()}
			${renderAdminList()}
		`;
        }
        return { render, controls, track };
    }

    function dedupe(arr) {
        return [...new Set(arr)];
    }

    function formDraftToAppDraft(formDraft) {
        return {
            home: formDraft.home,
            label: formDraft.label,
            origins: dedupe([
                new URL(formDraft.home).origin,
                ...formDraft.additionalOrigins,
            ])
        };
    }

    function originsMinusHome(home, origins) {
        return origins
            .filter(o => o.toLowerCase() !== new URL(home.toLowerCase()).origin)
            .map(o => o.toLowerCase());
    }

    function appDisplayToFormDraft(display) {
        return {
            home: display.home,
            label: display.label,
            additionalOrigins: originsMinusHome(display.home, display.origins),
        };
    }

    function strongRecordKeeper() {
        return function (makeRecord) {
            const map = new Map();
            return function getRecord(key) {
                let record;
                if (map.has(key))
                    record = map.get(key);
                else {
                    record = makeRecord(key);
                    map.set(key, record);
                }
                return record;
            };
        };
    }

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeAppManager = class XiomeAppManager extends Component3WithShare {
        constructor() {
            super(...arguments);
            this.appRegistrationForm = makeAppForm({
                clearOnSubmit: true,
                showAdditionalOrigins: false,
                submitButtonText: "create community",
                requestUpdate: () => this.requestUpdate(),
                query: selector => (this.shadowRoot
                    .querySelector(".app-registration")
                    .querySelector(selector)),
                submit: async (formDraft) => {
                    const appDraft = formDraftToAppDraft(formDraft);
                    await this.share.appModel.registerApp(appDraft);
                },
            });
            this.getAppState = strongRecordKeeper()(appId => {
                const app = this.share.appModel.getApp(appId);
                const { actions, getState, onStateChange } = happystate({
                    state: { editMode: false },
                    actions: state => ({
                        toggleEditMode() { state.editMode = !state.editMode; },
                    }),
                });
                onStateChange(() => { this.requestUpdate(); });
                return {
                    toggleEditMode: actions.toggleEditMode,
                    get editMode() { return getState().editMode; },
                    appForm: makeAppForm({
                        clearOnSubmit: false,
                        showAdditionalOrigins: true,
                        submitButtonText: "save changes",
                        initialValues: appDisplayToFormDraft(app),
                        requestUpdate: () => { this.requestUpdate(); },
                        query: selector => (this.shadowRoot
                            .querySelector(`.app[data-app-id="${app.appId}"] .app-options`)
                            .querySelector(selector)),
                        submit: async (formDraft) => {
                            const appDraft = formDraftToAppDraft(formDraft);
                            await this.share.appModel.updateApp(app.appId, appDraft);
                        },
                    }),
                    adminManager: (() => {
                        const manager = makeAdminManager({
                            app,
                            manageAdminsService: this.share.appModel.manageAdminsService,
                            query: selector => this.shadowRoot
                                .querySelector(`.app[data-app-id="${app.appId}"] .adminmanager`)
                                .querySelector(selector)
                        });
                        manager.track({
                            watcher: () => { manager.render(); },
                            effect: () => this.requestUpdate(),
                        });
                        manager.controls.listAdmins();
                        return manager;
                    })(),
                };
            });
            this.deleteApp = async (app) => {
                const userIsSure = await this.share.modals.confirm({
                    title: "are you certain?",
                    body: `you really want to delete your community "${app.label}"?`,
                    yes: { label: "delete whole community", vibe: "negative" },
                    no: { label: "nevermind", vibe: "neutral" },
                    focusNthElement: 2,
                });
                if (userIsSure)
                    await this.share.appModel.deleteApp(app.appId);
            };
        }
        init() {
            this.share.appModel.loadApps();
        }
        renderAppRegistration() {
            return html `
			<div class=app-registration>
				<slot name="register-app-heading"></slot>
				${this.appRegistrationForm.render({ partNamespace: "appregistration" })}
			</div>
		`;
        }
        renderNoApps() {
            return html `
			<slot name=no-apps></slot>
			${this.renderAppRegistration()}
		`;
        }
        renderAppList(records) {
            return html `
			<slot></slot>
			<div class=app-list>
				${Object.entries(records)
            .map(([appId, record]) => renderOp(record, app => this.renderApp(app)))}
			</div>
			${this.renderAppRegistration()}
		`;
        }
        renderAppBankLinking(app) {
            return null;
            // return html`
            // 	<div>
            // 		<h4>bank link to receive payouts</h4>
            // 		<xiome-bank-connect .appId=${app.appId}></xiome-bank-connect>
            // 	</div>
            // `
        }
        renderAppCode(appId) {
            return html `
			<div class=app-code>
				<h4>connect your website</h4>
				<p>copy-paste this html into your website's &lt;head&gt; section:</p>
				<code class=htmlcode>
					${renderXiomeConfig(appId)}
				</code>
				<p>then head over to the <a part=link href="./components">components page</a></p>
			</div>
		`;
        }
        renderApp(app) {
            const appState = this.getAppState(app.appId);
            return html `
			<div class=app data-app-id=${app.appId}>

				<div class=app-header part=app-header>
					<div class=title>
						<h3>
							<a part=link target=_blank href="${app.home}">
								${app.label}
							</a>
						</h3>
					</div>
					<div class=stats>
						<div data-stat=users>
							<span>${app.stats.users.toLocaleString()}</span>
							<span>users</span>
						</div>
						<div data-stat=monthly-active>
							<span>${app.stats.usersActiveMonthly.toLocaleString()}</span>
							<span>monthly active</span>
						</div>
						<div data-stat=active-last-day>
							<span>${app.stats.usersActiveDaily.toLocaleString()}</span>
							<span>daily active</span>
						</div>
					</div>
				</div>

				<div class=twoside>
					${this.renderAppCode(app.appId)}
					<div class=editside>
						<div class=buttons>
							<xio-button @click=${appState.toggleEditMode}>edit community</xio-button>
						</div>
						<div class=app-options ?hidden=${!appState.editMode}>
							<div class=app-details>
								${appState.appForm.render({ partNamespace: "appeditor" })}
							</div>
							<div class=adminmanager>
								<h4>manage admins</h4>
								${appState.adminManager.render()}
							</div>
							${this.renderAppBankLinking(app)}
							<div class=finalbox>
								<xio-button
									class=delete-app-button
									@press=${() => this.deleteApp(app)}>
										delete community
								</xio-button>
							</div>
						</div>
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { appRecords } = this.share.appModel.state;
            return html `
			${renderOp(appRecords, records => Object.values(records).length
            ? this.renderAppList(records)
            : this.renderNoApps())}
		`;
        }
    };
    XiomeAppManager = __decorate$6([
        mixinStyles(styles$6)
    ], XiomeAppManager);

    var styles$5 = css `

.avatar {
	display: block;
	width: 3em;
	height: 3em;
	padding: 0.2em;
	border-radius: 0.3em;
	color: #333;
	background: #4448;
}

:host([logged-in]) .avatar {
	color: #fff;
}

svg {
	display: block;
	width: 100%;
	height: 100%;
}

`;

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAvatar = class XiomeMyAvatar extends Component2WithShare {
        render() {
            const access = ops.value(this.share.authModel.access);
            const avatarSpec = access?.user?.profile.avatar;
            return html `
			<xio-avatar .spec=${avatarSpec} part="xio-avatar"></xio-avatar>
		`;
        }
    };
    XiomeMyAvatar = __decorate$5([
        mixinStyles(styles$5)
    ], XiomeMyAvatar);

    var styles$4 = css `

xio-profile-card {
	--avatar-size: 7em;
}

`;

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAccount = class XiomeMyAccount extends Component2WithShare {
        constructor() {
            super(...arguments);
            this.saveProfile = async (profileDraft) => {
                this.share.personalModel.saveProfile(profileDraft);
            };
        }
        render() {
            return renderOp(this.share.authModel.access, ({ user }) => html `
			<xio-profile-card
				show-details
				.user=${user}
				.saveProfile=${this.saveProfile}
			></xio-profile-card>
		`);
        }
    };
    XiomeMyAccount = __decorate$4([
        mixinStyles(styles$4)
    ], XiomeMyAccount);

    var styles$3 = css `

slot {
	display: block;
}

xio-text-input,
xio-button {
	margin-top: 0.2em;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7em;
}

.buttonbar {
	margin-top: 0.5em;
	vertical-align: middle;
}

slot[name="legal"] {
	display: inline-block;
	margin: 0 1em;
}

small {
	display: block;
	opacity: 0.5;
	font-size: 0.7em;
}

`;

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeLoginPanel = class XiomeLoginPanel extends Component2WithShare {
        constructor() {
            super(...arguments);
            this["show-logout"] = false;
            this.sentLoading = ops.none();
            this.emailIsValid = false;
        }
        async sendEmail() {
            const email = this.textInput.value;
            await ops.operation({
                promise: this.share.authModel.sendLoginLink(email)
                    .then(() => ({ email })),
                setOp: op => this.sentLoading = op,
                errorReason: `failed sending email to "${email}"`,
            });
        }
        resetSentLoading() {
            this.sentLoading = ops.none();
            if (this.textInput)
                this.textInput.text = "";
        }
        logout() {
            this.share.authModel.logout()
                .then(() => this.sentLoading = ops.none());
        }
        subscribe() {
            return this.share.authModel.onAccessChange(() => {
                this.resetSentLoading();
            });
        }
        renderLoggedIn(access) {
            return html `
			<slot>
				<p>Welcome ${access.user.profile.nickname}!</p>
			</slot>
			${this["show-logout"]
            ? html `
					<div part=buttonbar>
						<xio-button class=logout-button @press=${this.logout}>
							Logout
						</xio-button>
					</div>
				`
            : null}
		`;
        }
        handleEmailChange() {
            this.emailIsValid = this.textInput.problems.length === 0;
        }
        renderLegalLink() {
            return html `
			<small>
				<p>
					<a
						part=link
						target=_blank
						href="https://xiome.io/legal">
							policies and terms
					</a>
				</p>
			</small>
		`;
        }
        renderLoggedOut() {
            const { emailIsValid } = this;
            return html `
			<xio-op .op=${this.sentLoading}>
				<div slot=none>
					<slot name=logged-out>
						<p>login with your email address</p>
					</slot>
					<xio-text-input
						.validator=${email()}
						@valuechange=${this.handleEmailChange}
						@enterpress=${this.sendEmail}>
							<span>your email</span>
					</xio-text-input>
					<div class=buttonbar>
						<slot name=legal>
							${this.renderLegalLink()}
						</slot>
						<xio-button
							?disabled=${!emailIsValid}
							@press=${this.sendEmail}>
								send login link
						</xio-button>
					</div>
				</div>
				${ops.isReady(this.sentLoading)
            ? html `
						<p>email sent to ${ops.value(this.sentLoading).email}</p>
						<xio-button @press=${this.resetSentLoading}>
							try another address?
						</xio-button>
					`
            : null}
			</xio-op>
		`;
        }
        render() {
            const { access: accessOp } = this.share.authModel;
            return renderOp(accessOp, access => access?.user
                ? this.renderLoggedIn(access)
                : this.renderLoggedOut());
        }
    };
    __decorate$3([
        property({ type: Boolean, reflect: true })
    ], XiomeLoginPanel.prototype, "show-logout", void 0);
    __decorate$3([
        property()
    ], XiomeLoginPanel.prototype, "sentLoading", void 0);
    __decorate$3([
        query("xio-text-input")
    ], XiomeLoginPanel.prototype, "textInput", void 0);
    __decorate$3([
        property({ type: String })
    ], XiomeLoginPanel.prototype, "emailIsValid", void 0);
    XiomeLoginPanel = __decorate$3([
        mixinStyles(styles$3)
    ], XiomeLoginPanel);

    var styles$2 = css `

* {
	ZZoutline: 1px solid #0f02;
}

:host {
	display: block;
	width: 100%;
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 0.5em;
}

.container > * {
	flex: 3 1 10em;
	display: flex;
	flex-direction: column;
}

.roles {
	flex: 1 3 10em;
}

.roles xio-button[data-hard] {
	opacity: 0.6;
}

.container > * > p {
	padding: 0 0.5em;
}

[part=plate] {
	flex: 1 1 auto;
	padding: 0.5em;
	background: #fff2;
}

[part=plate] xio-button {
	display: inline-block;
	margin: 0.2em 0.1em;
	--xio-button-disabled-opacity: 0.6;
}

[part=plate] xio-button[data-soft] {
	color: red;
}

[part=plate] xio-button[data-selected]::part(button) {
	border: 1px solid lime;
	background: yellow;
	color: black;
}

[part=plate] xio-button > div {
	display: flex;
	flex-direction: row;
}

[part=plate] xio-button .icon {
	margin-right: 0.2em;
}

[part=plate] xio-button svg {
	width: 0.8em;
	height: 0.8em;
}

.buttonbar {
	text-align: right;
	background: #0002;
}

.buttonbar [data-button=delete] {
	--xio-button-hover-color: red;
	--xio-button-hover-background: transparent;
}

.buttonbar [data-button=new] {
	--xio-button-hover-color: lime;
	--xio-button-hover-background: transparent;
}

`;

    var lockSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-lock"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;

    var wrenchSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g fill="none"><path d="M7 5a4 4 0 0 1 5.445-3.73a.5.5 0 0 1 .173.819L10.708 4L12 5.293l1.91-1.91a.5.5 0 0 1 .82.172a4 4 0 0 1-4.829 5.292L4.897 13.92a1.986 1.986 0 0 1-2.843-2.774l5.051-5.234A4.01 4.01 0 0 1 7 5zm4-3a3 3 0 0 0-2.862 3.903a.5.5 0 0 1-.117.498L2.773 11.84a.986.986 0 0 0 1.41 1.377l5.225-5.293a.5.5 0 0 1 .532-.116a3 3 0 0 0 4.046-3.088l-1.633 1.634a.5.5 0 0 1-.707 0l-2-2a.5.5 0 0 1 0-.707l1.634-1.634A3.045 3.045 0 0 0 11 2z" fill="currentColor"/></g></svg>`;

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomePermissions = class XiomePermissions extends Component3WithShare {
        constructor() {
            super(...arguments);
            this.clickRole = (role) => () => {
                this.roleSelected = role;
            };
            this.clickDeleteRole = async () => {
                const { modals, permissionsModel } = this.share;
                const role = this.roleSelected;
                const confirmed = await modals.confirm({
                    title: "Delete role?",
                    body: `Are you sure you want to permanently delete the role "${role.label}"`,
                    yes: { vibe: "negative", label: "Delete role" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await permissionsModel.deleteRole({ roleId: role.roleId });
            };
            this.clickNewRole = async () => {
                const { modals, permissionsModel } = this.share;
                const result = await modals.prompt({
                    title: "Create a new role",
                    input: {
                        label: "Role name",
                        validator: roleLabelValidator,
                    },
                    yes: { vibe: "positive", label: "Create role" }
                });
                if (result)
                    await permissionsModel.createRole({ label: result.value });
            };
            this.clickAvailablePrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.assignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
            this.clickAssignedPrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.unassignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
        }
        init() {
            this.share.permissionsModel.initialize();
        }
        getAssignedPrivileges(permissions) {
            const { roleSelected } = this;
            if (!roleSelected)
                return [];
            const assignedPrivilegeIds = permissions.rolesHavePrivileges
                .filter(({ roleId }) => roleId === roleSelected.roleId)
                .map(({ privilegeId }) => privilegeId);
            return permissions.privileges
                .filter(({ privilegeId }) => assignedPrivilegeIds.includes(privilegeId))
                .map(privilege => {
                const { active, immutable } = permissions.rolesHavePrivileges.find(rp => rp.roleId === roleSelected.roleId &&
                    rp.privilegeId === privilege.privilegeId);
                return { ...privilege, active, immutable };
            });
        }
        renderPrivilege({ privilegeId, label, hard, immutable, onPrivilegeClick, }) {
            return html `
			<xio-button
				title="${privilegeId}"
				?disabled=${immutable}
				?data-hard=${hard}
				?data-soft=${!hard}
				?data-immutable=${immutable}
				@press=${onPrivilegeClick}>
					<div>
						${immutable
            ? html `<div class=icon>${lockSvg}</div>`
            : null}
						${label}
					</div>
			</xio-button>
		`;
        }
        renderPermissions(permissions) {
            const assignedPrivileges = this.getAssignedPrivileges(permissions);
            const activePrivileges = assignedPrivileges.filter(p => p.active);
            const availablePrivileges = this.roleSelected
                ? [
                    ...permissions.privileges
                        .filter(privilege => {
                        const assigned = assignedPrivileges
                            .find(priv => priv.privilegeId === privilege.privilegeId);
                        return !assigned;
                    })
                        .map(privilege => ({ ...privilege, immutable: false })),
                    ...assignedPrivileges
                        .filter(privilege => !privilege.active)
                ]
                : [];
            return html `
			<div class=container>
				<div class=roles>
					<p>roles</p>
					<div part=plate>
						${permissions.roles.map(role => html `
							<xio-button
								title="${role.roleId}"
								?data-selected=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								?data-hard=${role.hard}
								?disabled=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								@click=${this.clickRole(role)}>
								<div>
									${role.hard
            ? html `<div class=icon>${wrenchSvg}</div>`
            : null}
									${role.label}
								</div>
							</xio-button>
						`)}
					</div>
					<div part=plate class=buttonbar>
						${this.roleSelected
            ? html `
								<xio-button
									data-button=delete
									?disabled=${this.roleSelected.hard}
									@press=${this.clickDeleteRole}>
										delete role
								</xio-button>
							`
            : null}
						<xio-button data-button=new @press=${this.clickNewRole}>
							new role
						</xio-button>
					</div>
				</div>

				<div class=assigned>
					<p>
						privileges assigned
						${this.roleSelected
            ? ` to "${this.roleSelected.label}"`
            : null}
					</p>
					<div part=plate>
						${activePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAssignedPrivilege(privilege.privilegeId)
        }))}
					</div>
				</div>

				<div class=available>
					<p>privileges available</p>
					<div part=plate>
						${availablePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAvailablePrivilege(privilege.privilegeId),
        }))}
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { permissionsModel } = this.share;
            const { getUserCanCustomizePermissions, getState } = permissionsModel;
            const state = getState();
            return getUserCanCustomizePermissions()
                ? renderOp(state.permissionsDisplay, this.renderPermissions.bind(this))
                : html `
				<p>you are not privileged to customize permissions</p>
			`;
        }
    };
    __decorate$2([
        property()
    ], XiomePermissions.prototype, "roleSelected", void 0);
    XiomePermissions = __decorate$2([
        mixinStyles(styles$2)
    ], XiomePermissions);

    var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    function mixinHappy(...onStateChanges) {
        return function (Base) {
            var _unsubscribes, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _unsubscribes.set(this, []);
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        const update = () => {
                            this.requestUpdate();
                        };
                        __classPrivateFieldSet$1(this, _unsubscribes, onStateChanges
                            .map(onStateChange => onStateChange(update)), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        for (const unsubscribe of __classPrivateFieldGet$1(this, _unsubscribes, "f"))
                            unsubscribe();
                        __classPrivateFieldSet$1(this, _unsubscribes, [], "f");
                    }
                },
                _unsubscribes = new WeakMap(),
                _a;
        };
    }

    function xiomeAuthComponents({ models, modals }) {
        const { authModel, appModel, personalModel, permissionsModel } = models;
        return {
            XiomeMyAvatar: mixinAutotrack(authModel.track)(mixinShare({
                authModel,
            })(XiomeMyAvatar)),
            XiomeLoginPanel: mixinAutotrack(authModel.track)(mixinShare({
                authModel,
            })(XiomeLoginPanel)),
            XiomeAppManager: mixinHappy(appModel.onStateChange)(mixinShare({
                modals,
                appModel,
            })(XiomeAppManager)),
            XiomeMyAccount: mixinAutotrack(authModel.track)(mixinShare({
                authModel,
                personalModel,
            })(XiomeMyAccount)),
            XiomePermissions: mixinHappy(permissionsModel.onStateChange)(mixinShare({
                modals,
                authModel,
                permissionsModel,
            })(XiomePermissions)),
        };
    }

    var styles$1 = css `

/* * {
	outline: 1px solid #f002;
} */

:host {
	display: block;
	max-width: 36em;
	--bg: var(--xiome-questions-body-background, #0006);
	--color: var(--xiome-questions-body-color, #fff6);
	--like-color: var(--xiome-questions-like-color, cyan);
	--report-color: var(--xiome-questions-report-color, #f90);
}

.questions-moderation-panel {
	padding: 1em;
	border: 1px dotted;
	margin-bottom: 1em;
}

.questions-moderation-panel .purge-button {
	--xio-button-hover-color: red;
}

slot[name="empty"] {
	display: block;
	margin-top: 1em;
}

.questionslist {
	list-style: none;
}

.questionslist > li {
	margin-top: 2em;
}

.question-expression {
	display: flex;
	flex-direction: row;
}

.question-area {
	flex: 1 1 auto;
}

.question-voting {
	padding: 0.5em;
	padding-top: 4.5em;
}

.question-voting button {
	display: block;
	border: none;
	font: inherit;
	background: transparent;
	color: inherit;
}

.question-voting [data-vote] {
	cursor: pointer;
	opacity: 0.6;
	user-select: none;
}

.question-voting [data-vote="report"] {
	opacity: 0.4;
}

.question-voting [data-vote]:hover,
.question-voting [data-vote]:focus {
	opacity: 1;
}

.question-voting [data-vote="like"][data-active] {
	color: var(--like-color);
}

.question-voting [data-vote="report"][data-active] {
	color: var(--report-color);
}

.question-voting [data-vote] > span {
	vertical-align: middle;
}

.question-voting [data-vote] > span:nth-child(2) {
	font-size: 0.9em;
}

.question-voting svg {
	width: 1.4em;
	height: 1.4em;
	position: relative;
	top: 0.1em;
}

.question-editor {
	padding: 1em;
	border: 2px dashed;
}

.editor-intro {
	font-size: 1.2em;
	font-weight: bold;
	margin-bottom: 0.5em;
}

.editor-profile {
	margin: 0.5em 0;
}

xio-profile-card {
	width: 100%;
}

.editor-buttons {
	text-align: right;
}

.question-body {
	display: flex;
	flex-direction: column;
}

.question-controls {
	opacity: 0.6;
	font-size: 0.8em;
	padding-top: 0.4em;
	text-align: right;
}

.metabar {
	position: relative;
	padding-left: 3.5em;
	text-align: right;
}

.metabar::before {
	display: block;
	z-index: 0;
	content: "";
	position: absolute;
	width: 0;
	height: 0;
	left: 0.5em;
	bottom: 0;
	border: 1em solid transparent;
	border-bottom-color: var(--bg);
	margin-right: auto;
}

.metabar p {
	opacity: 0.5;
	font-size: 0.8em;
}

.textbox p,
.textbox xio-text-input {
	display: block;
	font: inherit;
	width: 100%;
	max-width: 100%;
	border: none;
	padding: 1em;
	background: var(--bg);
	color: var(--color);
	border-radius: 0.5em;
}

.textbox p {
	min-height: 4em;
	white-space: pre;
}

.textbox xio-text-input {
	--height: 8em;
	--border: none;
}

[data-editable] .metabar {
	order: 1;
}

[data-editable] .metabar::before {
	bottom: unset;
	top: 0;
	border-bottom-color: transparent;
	border-top-color: var(--bg);
}

`;
    // export default css`
    // * {
    // 	margin: 0;
    // 	padding: 0;
    // 	box-sizing: border-box;
    // }
    // *:focus {
    // 	outline: var(--focus-outline, 2px solid cyan);
    // }
    // :host {
    // 	display: flex;
    // 	flex-direction: var(--questions-board-flex-direction, column);
    // }
    // :host([hidden]) {
    // 	display: none;
    // }
    // :host > metal-is-staff {
    // 	flex: 1 1 auto;
    // 	align-self: center;
    // 	width: 100%;
    // 	max-width: 420px;
    // 	text-align: center;
    // }
    // .questions {
    // 	list-style: none;
    // }
    // .questions > li + li {
    // 	margin-top: 1em;
    // }
    // slot[name=post],
    // slot[name=rate] {
    // 	display: block;
    // 	margin: 1.5em auto;
    // 	text-align: center;
    // }
    // .question {
    // 	display: flex;
    // 	flex-direction: row;
    // 	padding: 0.5em;
    // 	background: var(--question-background, transparent);
    // 	border-radius: var(--question-border-radius, 0.25em);
    // }
    // .question[data-mine] {
    // 	background: var(--question-base-mine-background, rgba(255,255,255, 0.1));
    // }
    // .question > * {
    // 	flex: 0 0 auto;
    // }
    // .author {
    // 	font-size: 1em;
    // 	display: flex;
    // 	flex-direction: row;
    // }
    // cobalt-avatar {
    // 	--cobalt-avatar-size: 4em;
    // }
    // .author .details {
    // 	padding: 0.5em;
    // 	padding-top: 0;
    // }
    // .author .time {
    // 	opacity: 0.5;
    // 	font-size: 0.75em;
    // }
    // .likebutton {
    // 	opacity: 0.8;
    // 	border: none;
    // 	display: flex;
    // 	align-items: center;
    // 	font: inherit;
    // 	color: inherit;
    // 	background: transparent;
    // 	cursor: pointer;
    // }
    // .likebutton:hover,
    // .likebutton:focus {
    // 	opacity: 1;
    // }
    // .likebutton > * {
    // 	flex: 1 1 auto;
    // }
    // .likebutton .like-heart {
    // 	font-size: 1.8em;
    // }
    // .likebutton .like-heart svg path {
    // 	fill: none;
    // 	stroke: currentColor;
    // 	stroke-width: 1;
    // }
    // .likebutton[data-liked] {
    // 	color: var(--question-like-color, rgba(255, 167, 183, 0.64));
    // }
    // .likebutton[data-liked] .like-heart svg path {
    // 	fill: currentColor;
    // }
    // .likebutton .like-number {
    // 	padding-left: 0.2em;
    // }
    // .body {
    // 	position: relative;
    // 	flex: 1 1 auto;
    // 	display: flex;
    // 	flex-direction: column;
    // 	justify-content: space-between;
    // 	padding: 0em;
    // 	background: var(--question-body-background, rgba(255,255,255, 0.1));
    // 	color: var(--question-body-color, inherit);
    // 	border-radius: inherit;
    // }
    // .body::before {
    // 	content: "";
    // 	display: block;
    // 	position: absolute;
    // 	top: 1em;
    // 	right: 100%;
    // 	border: 0.5em solid transparent;
    // 	border-right-color: var(--question-body-background, rgba(255,255,255, 0.1));
    // }
    // .content {
    // 	padding: 1em;
    // 	font: inherit;
    // 	color: inherit;
    // 	white-space: pre-wrap;
    // 	overflow-wrap: anywhere;
    // 	background: transparent;
    // }
    // textarea.content {
    // 	min-height: 6em;
    // 	transition: min-height 500ms ease;
    // 	border: 1px dashed var(--question-body-background, rgba(255,255,255, 0.2));
    // }
    // textarea.content[data-expand] {
    // 	min-height: 12em;
    // }
    // .controls {
    // 	display: flex;
    // 	justify-content: flex-end;
    // 	align-items: center;
    // 	padding: 0.2em;
    // }
    // .controls button {
    // 	opacity: 0.7;
    // 	border: none;
    // 	color: var(--question-button-color, inherit);
    // 	font: inherit;
    // 	font-size: 0.8em;
    // 	margin: 0 0.1em;
    // 	padding: 0.2em 0.6em;
    // 	background: var(--question-button-background, rgba(0,0,0, 0.2));
    // 	border: var(--question-button-border, 1px solid rgba(0,0,0, 0.2));
    // 	border-radius: var(--question-button-border-radius, 3px);
    // 	text-shadow: var(--question-button-text-shadow, 1px 1px 2px rgba(0,0,0, 0.5));
    // 	cursor: pointer;
    // }
    // .controls button:hover,
    // .controls button:focus {
    // 	opacity: 1;
    // }
    // .controls button[disabled] {
    // 	background: rgba(255,255,255, 0.2);
    // 	opacity: 0.4;
    // }
    // .message {
    // 	flex: 1 1 auto;
    // 	font-size: 0.8em;
    // 	padding: 0.2em 0.6em;
    // 	opacity: var(--question-message-opacity, 0.8);
    // 	color: var(--question-message-color, white);
    // 	background: var(--question-message-background, rgba(255,255,255, 0.1));
    // 	border: var(--question-message-border, 1px solid);
    // 	text-shadow: var(--question-message-text-shadow, 1px 1px 2px rgba(0,0,0, 0.5));
    // }
    // .message[data-angry] {
    // 	color: var(--question-message-color-angry, red);
    // 	background: var(--question-message-background-angry, rgba(128,32,32, 0.1));
    // 	border: var(--question-message-border-angry, 1px solid);
    // 	text-shadow: var(--question-message-text-shadow-angry, 1px 1px 2px rgba(0,0,0, 0.5));
    // }
    // .question.editor {
    // 	order: 1;
    // 	border: 1px dashed var(--question-body-background, rgba(255,255,255, 0.2));
    // }
    // .question.editor .body textarea {
    // 	border-radius: inherit;
    // }
    // .question.editor .body textarea::placeholder {
    // 	opacity: 0.3;
    // }
    // .controls .postbutton {
    // 	color: var(---question-postbutton-color, white);
    // 	background: var(--question-postbutton-background, #00bb3a);
    // }
    // @media (max-width: 800px) {
    // 	.question {
    // 		flex-direction: column;
    // 	}
    // 	.author {
    // 		width: unset;
    // 		margin-bottom: 0.5em;
    // 	}
    // 	.body::before {
    // 		border-right-color: transparent;
    // 		border-bottom-color: var(--question-body-background, rgba(255,255,255, 0.1));
    // 		top: unset;
    // 		right: unset;
    // 		bottom: 100%;
    // 		left: 1.5em;
    // 	}
    // 	.question.editor .controls {
    // 		order: unset;
    // 	}
    // }
    // `

    function sortQuestions(questions, myUserId) {
        const myQuestions = [];
        const otherQuestions = [];
        for (const question of questions) {
            const isMine = myUserId && question.authorUserId === myUserId;
            if (isMine)
                myQuestions.push(question);
            else
                otherQuestions.push(question);
        }
        const sort = (a, b) => {
            const promote = { a: -1, b: 1 };
            if (a.likes > b.likes)
                return promote.a;
            if (a.likes < b.likes)
                return promote.b;
            if (a.reports < b.reports)
                return promote.a;
            if (a.reports > b.reports)
                return promote.b;
            if (a.timePosted > b.timePosted)
                return promote.a;
            if (a.timePosted < b.timePosted)
                return promote.b;
            return 0;
        };
        return [
            ...myQuestions.sort(sort),
            ...otherQuestions.sort(sort),
        ];
    }

    function renderQuestionBody({ content, editable, timePosted, handleValueChange = () => { }, }) {
        const { date, time } = formatDate(timePosted);
        return html `
		<div class=question-body ?data-editable=${editable}>
			<div class=metabar>
				<p>
					${`${date} ${time}`}
				</p>
			</div>
			<div class=textbox>
				${editable
        ? html `
						<xio-text-input
							textarea
							.validator=${validateQuestionDraftContent}
							@valuechange=${handleValueChange}
						></xio-text-input>
					`
        : html `
						<p>${content}</p>
					`}
			</div>
		</div>
	`;
    }

    var heartSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M6.736 4C4.657 4 2.5 5.88 2.5 8.514c0 3.107 2.324 5.96 4.861 8.12a29.66 29.66 0 0 0 4.566 3.175l.073.041l.073-.04c.271-.153.661-.38 1.13-.674c.94-.588 2.19-1.441 3.436-2.502c2.537-2.16 4.861-5.013 4.861-8.12C21.5 5.88 19.343 4 17.264 4c-2.106 0-3.801 1.389-4.553 3.643a.75.75 0 0 1-1.422 0C10.537 5.389 8.841 4 6.736 4zM12 20.703l.343.667a.75.75 0 0 1-.686 0l.343-.667zM1 8.513C1 5.053 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262a31.146 31.146 0 0 1-5.233 3.576l-.025.013l-.007.003l-.002.001l-.344-.666l-.343.667l-.003-.002l-.007-.003l-.025-.013A29.308 29.308 0 0 1 10 20.408a31.147 31.147 0 0 1-3.611-2.632C3.8 15.573 1 12.332 1 8.514z" fill="currentColor"/></svg>`;

    var heartFillSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M14 20.408c-.492.308-.903.546-1.192.709c-.153.086-.308.17-.463.252h-.002a.75.75 0 0 1-.686 0a16.709 16.709 0 0 1-.465-.252a31.147 31.147 0 0 1-4.803-3.34C3.8 15.572 1 12.331 1 8.513C1 5.052 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262A31.146 31.146 0 0 1 14 20.408z" fill="currentColor"/></svg>`;

    var warningFillSvg = svg `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M8.686 2.852L2.127 14.777A1.5 1.5 0 0 0 3.441 17H16.56a1.5 1.5 0 0 0 1.314-2.223L11.314 2.852a1.5 1.5 0 0 0-2.628 0zM10 6.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4a.75.75 0 0 1 .75-.75zm.75 7a.75.75 0 1 1-1.5 0a.75.75 0 0 1 1.5 0z" fill="currentColor"/></g></svg>`;

    function renderQuestion({ author, authority, question, handleDelete, handleLike, handleReport, }) {
        const voting = {
            like: question.liked
                ? {
                    icon: heartFillSvg,
                    title: "unlike this post",
                    click: () => handleLike(false),
                }
                : {
                    icon: heartSvg,
                    title: "like this post",
                    click: () => handleLike(true),
                },
            report: question.reported
                ? {
                    icon: warningFillSvg,
                    title: "unreport this post",
                    click: () => handleReport(false),
                }
                : {
                    icon: warningSvg,
                    title: "report this post",
                    click: () => handleReport(true),
                },
        };
        return html `
		<li data-question-id="${question.questionId}">
			<div class=question-expression>
				<div class=question-voting>
					<button
						data-vote=like
						?data-active=${question.liked}
						tabindex=0
						title="${voting.like.title}"
						@click=${voting.like.click}>
							<span>${voting.like.icon}</span>
							<span>${question.likes}</span>
					</button>
					<button
						data-vote=report
						?data-active=${question.reported}
						tabindex=0
						title="${voting.report.title}"
						@click=${voting.report.click}>
							<span>${voting.report.icon}</span>
							<span>${question.reports}</span>
					</button>
				</div>
				<div class=question-area>
					<xio-profile-card .user=${author} show-details></xio-profile-card>
					${renderQuestionBody({
        editable: false,
        content: question.content,
        timePosted: question.timePosted,
    })}
				</div>
			</div>
			<div class=question-controls>
				${authority
        ? html `<xio-button @press=${handleDelete}>delete</xio-button>`
        : null}
			</div>
		</li>
	`;
    }

    function renderQuestionEditor({ content, postable, questionAuthor, handlePost, handleValueChange, }) {
        return html `
		<div class=question-editor>
			<div class=editor-intro>
				<p class=editor-heading>Post a new question</p>
			</div>
			<div class=editor-textbox>
				${renderQuestionBody({
        content,
        editable: true,
        timePosted: Date.now(),
        handleValueChange,
    })}
			</div>
			<div class=editor-profile>
				<xio-profile-card .user=${questionAuthor} show-details></xio-profile-card>
			</div>
			<div class=editor-buttons>
				<xio-button
					?disabled=${!postable}
					@press=${handlePost}
				>Post question</xio-button>
			</div>
		</div>
	`;
    }

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeQuestions_boardModel;
    let XiomeQuestions = class XiomeQuestions extends Component2WithShare {
        constructor() {
            super(...arguments);
            _XiomeQuestions_boardModel.set(this, void 0);
            this.board = "default";
            this.draftText = "";
            this.handlePost = async (event) => {
                const content = this.draftText;
                this.editorTextInput.text = "";
                await __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").postQuestion({
                    content,
                    board: __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getBoardName(),
                });
            };
            this.handleValueChange = (event) => {
                this.draftText = event.detail.value;
            };
        }
        get postable() {
            return !!this.draftText;
        }
        init() {
            __classPrivateFieldSet(this, _XiomeQuestions_boardModel, this.share.questionsModel.makeBoardModel(this.board), "f");
            __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").loadQuestions();
        }
        renderQuestionsModerationPanel() {
            const permissions = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getPermissions();
            const board = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getBoardName();
            const handlePressPurgeButton = async () => {
                const confirmed = await this.share.modals.confirm({
                    title: `Purge questions?`,
                    body: `Are you sure you want to delete all the questions on the board "${board}"? This cannot be undone.`,
                    yes: { vibe: "negative", label: "Purge all" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").archiveBoard();
            };
            return permissions["moderate questions"]
                ? html `
				<div class=questions-moderation-panel>
					<h3>moderate questions board "${this.board}"</h3>
					<xio-button
						class=purge-button
						@press=${handlePressPurgeButton}>
							Purge all questions
					</xio-button>
				</div>
			`
                : null;
        }
        renderQuestionsEditor() {
            const access = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getAccess();
            const permissions = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getPermissions();
            const questionAuthor = access?.user;
            return permissions["post questions"]
                ? renderOp(__classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getPostingOp(), () => renderQuestionEditor({
                    questionAuthor,
                    content: this.draftText,
                    postable: this.postable,
                    handlePost: this.handlePost,
                    handleValueChange: this.handleValueChange,
                }))
                : null;
        }
        renderQuestionsList() {
            const access = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getAccess();
            const myUserId = access?.user?.userId;
            const questions = sortQuestions(__classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getQuestions(), myUserId);
            const permissions = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getPermissions();
            return html `
			<ol class=questionslist>
				${questions.map(question => {
            const { questionId, authorUserId } = question;
            const author = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getUser(authorUserId);
            const isAuthor = (access && access.user)
                ? access.user.userId === author.userId
                : false;
            const authority = permissions["moderate questions"] || isAuthor;
            const handleDelete = async () => {
                const confirmed = await this.share.modals.confirm({
                    title: "Delete question?",
                    body: "Are you sure you want to delete this question? This cannot be undone.",
                    yes: { vibe: "negative", label: "Delete question" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").archiveQuestion(questionId, true);
            };
            const handleLike = (like) => {
                __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").likeQuestion(questionId, like);
            };
            const handleReport = async (report) => {
                const confirmed = report
                    ? await this.share.modals.confirm({
                        title: "Report question?",
                        body: "Are you sure you want to submit a report against this question?",
                        yes: { vibe: "negative", label: "Submit report" },
                        no: { vibe: "neutral", label: "Nevermind" },
                        focusNthElement: 2,
                    })
                    : true;
                if (confirmed)
                    await __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").reportQuestion(questionId, report);
            };
            return renderQuestion({
                author,
                authority,
                question,
                handleDelete,
                handleLike,
                handleReport,
            });
        })}
			</ol>
		`;
        }
        renderQuestionsBoard() {
            const boardOp = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getBoardOp();
            const numberOfQuestions = __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getQuestions().length;
            return renderOp(boardOp, () => html `
			${this.renderQuestionsModerationPanel()}
			${this.renderQuestionsEditor()}
			${numberOfQuestions > 0
            ? this.renderQuestionsList()
            : html `<slot name=empty><p>Be the first to post a question!</p></slot>`}
		`);
        }
        render() {
            return __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f") && __classPrivateFieldGet(this, _XiomeQuestions_boardModel, "f").getBoardOp()
                ? this.renderQuestionsBoard()
                : null;
        }
    };
    _XiomeQuestions_boardModel = new WeakMap();
    __decorate$1([
        property({ type: String, reflect: true })
    ], XiomeQuestions.prototype, "board", void 0);
    __decorate$1([
        property({ type: String })
    ], XiomeQuestions.prototype, "draftText", void 0);
    __decorate$1([
        query(".question-editor .question-body xio-text-input")
    ], XiomeQuestions.prototype, "editorTextInput", void 0);
    XiomeQuestions = __decorate$1([
        mixinStyles(styles$1)
    ], XiomeQuestions);

    function xiomeQuestionsComponents({ models, modals }) {
        const { questionsModel } = models;
        return {
            XiomeQuestions: mixinHappy(questionsModel.onStateChange)(mixinShare({
                modals,
                questionsModel,
            })(XiomeQuestions)),
        };
    }

    var styles = css `

.container {
	display: block;
	width: 100%;
	max-width: 36em;
	padding: 0.5em !important;
	border: 1px solid;
}

.results {
	margin-top: 0.5em;
}

.userlist {
	list-style: none;
}

.userlist > li {
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	background: #0002;
	padding: 0.5em;
	margin-top: 0.5em;
}

.userinfo {
	display: flex;
	flex-direction: row;
}

.userinfo xio-profile-card {
	flex: 1 1 auto;
}

.userinfo .controls {
	margin-left: 1em;
}

.userinfo .controls .edit[data-edit-mode] {
	color: lime;
	--xio-button-hover-color: lime;
}

.editwidget > div {
	margin-top: 1em;
}

.editwidget header + * {
	margin-top: 0.25em;
}

.editwidget header small {
	font-size: inherit;
	opacity: 0.6;
}

.editwidget ul {
	list-style: none;
}

.editwidget .allprivileges li {
	display: inline-block;
	font-size: 0.75em;
	padding: 0.1em 0.3em;
	margin: 0.2em 0.1em;
	border: 1px solid;
	border-radius: 1em;
}

`;

    function makeUserStates({ getUserResultsOp, rerender, }) {
        const states = new Map();
        function cleanupObsoleteStates() {
            const userIdsPendingRemovalFromState = [];
            const userResultsOp = getUserResultsOp();
            if (ops.ready(userResultsOp)) {
                const userResults = ops.value(userResultsOp);
                for (const stateUserId of states.keys()) {
                    const userIsGone = !userResults.find(({ user }) => user.userId === stateUserId);
                    if (userIsGone)
                        userIdsPendingRemovalFromState.push(stateUserId);
                }
            }
            for (const obsoleteUserId of userIdsPendingRemovalFromState)
                states.delete(obsoleteUserId);
        }
        function obtainStateForUser(userId) {
            let state = states.get(userId);
            if (!state) {
                const newState = {
                    editMode: false,
                    toggleEditMode() {
                        newState.editMode = !newState.editMode;
                        rerender();
                    },
                };
                state = newState;
                states.set(userId, state);
            }
            return state;
        }
        return {
            cleanupObsoleteStates,
            obtainStateForUser,
        };
    }

    function sortAssignableFirst(roles) {
        const assignable = roles.filter(role => role.assignable);
        const notAssignable = roles.filter(role => !role.assignable);
        return [...assignable, ...notAssignable];
    }
    function renderRoleButton(role, onClick) {
        return html `
		<xio-button
			?disabled=${!role.assignable}
			title=${role.roleId}
			data-role-id=${role.roleId}
			@press=${() => onClick(role)}>
				${role.label}
		</xio-button>
	`;
    }
    function renderPrivilegeUserHas(privilege) {
        return html `
		<li
			title="${privilege.privilegeId}"
			data-privilege-id="${privilege.privilegeId}">
				${privilege.label}
		</li>
	`;
    }
    function renderEditWidget({ permissions, administrativeModel, updateLocalUserResultsCache, userResult: { user: { userId }, roleIds }, blur, search, }) {
        const rolesAssigned = sortAssignableFirst(roleIds
            .map(id => permissions.roles.find(role => role.roleId === id))
            .filter(id => !!id));
        const rolesAvailable = sortAssignableFirst(permissions.roles
            .filter(role => !roleIds.includes(role.roleId))
            .filter(id => !!id));
        const privilegesUserHas = permissions.privileges
            .filter(privilege => {
            const rolesWithThisPrivilege = permissions.rolesHavePrivileges
                .filter(r => r.active && r.privilegeId === privilege.privilegeId);
            const rolesUserHas = rolesWithThisPrivilege
                .filter(r => roleIds.includes(r.roleId));
            return rolesUserHas.length > 0;
        });
        async function ifChangingSelfThenReauthorize() {
            if (userId === administrativeModel.getState().access?.user?.userId)
                await administrativeModel.reauthorize();
        }
        async function clickToAssign({ roleId }) {
            await administrativeModel.assignRoleToUser({
                userId,
                roleId,
                isPublic: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
            });
            updateLocalUserResultsCache.assignRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        async function clickToRevoke({ roleId }) {
            await administrativeModel.revokeRoleFromUser({
                userId,
                roleId,
            });
            updateLocalUserResultsCache.revokeRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        return html `
		<div class=editwidget>
			<div class=available>
				<header>roles available <small>(click to assign)</small></header>
				<div>
					${rolesAvailable.map(role => renderRoleButton(role, clickToAssign))}
				</div>
			</div>
			<div class=assigned>
				<header>roles assigned <small>(click to revoke)</small></header>
				<div>
					${rolesAssigned.map(role => renderRoleButton(role, clickToRevoke))}
				</div>
			</div>
			<div class=allprivileges>
				<header>user has these privileges</header>
				<ul>
					${privilegesUserHas.map(renderPrivilegeUserHas)}
				</ul>
			</div>
		</div>
	`;
    }

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeManageUsers = class XiomeManageUsers extends Component3WithShare {
        constructor() {
            super(...arguments);
            this.userResults = ops.ready([]);
            this.updateLocalUserResultsCache = {
                assignRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: [...result.roleIds, roleId] }
                        : result));
                },
                revokeRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: result.roleIds.filter(id => id !== roleId) }
                        : result));
                },
            };
            this.userStates = makeUserStates({
                getUserResultsOp: () => this.userResults,
                rerender: () => this.requestUpdate(),
            });
            this.searchText = "";
            this.debouncedSearchUsers = debounce3(1000, async (term) => term
                ? await this.share.administrativeModel.searchUsers({ term })
                : []);
            this.searchChange = async (event) => {
                this.searchText = event.detail.value ?? "";
                return this.search();
            };
        }
        init() {
            this.share.administrativeModel.initialize();
        }
        async search() {
            const { searchText } = this;
            this.userResults = ops.ready([]);
            if (searchText)
                await ops.operation({
                    promise: this.debouncedSearchUsers(searchText),
                    setOp: op => this.userResults = op,
                });
            else
                this.userResults = ops.ready([]);
            this.userStates.cleanupObsoleteStates();
        }
        render() {
            const { permissionsOp } = this.share.administrativeModel.getState();
            const allowed = this.share.administrativeModel
                .isAllowed("administrate user roles");
            const renderUser = (userResult) => {
                const { user } = userResult;
                const state = this.userStates.obtainStateForUser(user.userId);
                return html `
				<li>
					<div class=userinfo>
						<xio-profile-card
							.user=${user}
							show-details
						></xio-profile-card>
						<div class=controls>
							<xio-button
								class=edit
								?data-edit-mode=${state.editMode}
								@press=${state.toggleEditMode}>
									${wrenchSvg}
							</xio-button>
						</div>
					</div>
					${state.editMode
                ? renderOp(permissionsOp, permissions => renderEditWidget({
                    userResult,
                    permissions,
                    administrativeModel: this.share.administrativeModel,
                    updateLocalUserResultsCache: this.updateLocalUserResultsCache,
                    blur: () => {
                        const activeElement = document.activeElement;
                        if (activeElement)
                            activeElement.blur();
                    },
                    search: () => this.search(),
                }))
                : null}
				</li>
			`;
            };
            return html `
			<div class=container>

				${allowed ? html `
					<xio-text-input
						.text=${this.searchText}
						placeholder="search for users"
						.validator=${validateUserSearchTerm}
						@valuechange=${this.searchChange}
					></xio-text-input>

					<div class=results>
						${renderOp(this.userResults, results => results.length > 0
            ? html `
								<ol class=userlist>
									${results.map(renderUser)}
								</ol>
							`
            : html `
								<div class=noresults>
									no results
								</div>
							`)}
					</div>
				` : html `
					<p>you are not permitted to administrate user roles</p>
				`}

			</div>
		`;
        }
    };
    __decorate([
        property()
    ], XiomeManageUsers.prototype, "userResults", void 0);
    __decorate([
        property({ type: String })
    ], XiomeManageUsers.prototype, "searchText", void 0);
    XiomeManageUsers = __decorate([
        mixinStyles(styles)
    ], XiomeManageUsers);

    function xiomeAdministrativeComponents({ models, modals }) {
        const { administrativeModel } = models;
        return {
            XiomeManageUsers: mixinHappy(administrativeModel.onStateChange)(mixinShare({
                modals,
                administrativeModel,
            })(XiomeManageUsers)),
        };
    }

    function getComponents(options) {
        return themeComponents(theme, {
            ...xioComponents(),
            ...xiomeAuthComponents(options),
            // // TODO reactivate store
            // ...xiomeStoreComponents(options),
            ...xiomeQuestionsComponents(options),
            ...xiomeAdministrativeComponents(options),
        });
    }

    function trapFocus(element, focusNth) {
        const blueprint = `
		[focusable]:not([disabled])
		[tabindex]:not([disabled])
		a[href]:not([disabled])
		button:not([disabled])
		textarea:not([disabled])
		input[type="text"]:not([disabled])
		input[type="radio"]:not([disabled])
		input[type="checkbox"]:not([disabled])
		select:not([disabled])
	`;
        const selector = blueprint
            .split("\n")
            .map(l => l.trim())
            .filter(l => l.length)
            .join(", ");
        const focusable = Array.from(element.querySelectorAll(selector));
        if (focusable.length === 0)
            throw new Error("cannot trap focus: no focusable element");
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        const nthFocusable = focusable[focusNth - 1];
        setTimeout(() => nthFocusable.focus(), 0);
        element.onkeydown = event => {
            if (event.key === "Tab") {
                if (event.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        event.preventDefault();
                    }
                }
                else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        event.preventDefault();
                    }
                }
            }
        };
    }

    function preparePrompt(popup) {
        return async ({ title, input, body = null, yes = { label: "okay", vibe: "positive" }, no = { label: "nevermind", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansCancel = true, }) => new Promise(resolve => {
            const xioTextInput = document.createElement("xio-text-input");
            xioTextInput.textarea = input.textarea ?? false;
            xioTextInput.parser = input.parser;
            xioTextInput.validator = input.validator;
            xioTextInput.textContent = input.label;
            function hasProblems() {
                void xioTextInput.value;
                return xioTextInput.problems.length !== 0;
            }
            function getCurrentValue() {
                return hasProblems()
                    ? undefined
                    : { value: xioTextInput.value };
            }
            function prepareFinishingMoves(controls) {
                return {
                    yes: () => {
                        const currentValue = getCurrentValue();
                        if (!hasProblems()) {
                            controls.close();
                            resolve(currentValue);
                        }
                    },
                    no: () => {
                        controls.close();
                        resolve(undefined);
                    },
                };
            }
            const { controls, modal } = popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansCancel
                    ? controls => {
                        controls.close();
                        resolve(undefined);
                    }
                    : () => { },
                renderContent: controls => {
                    const finish = prepareFinishingMoves(controls);
                    return html `
					<div data-confirm>
						${typeof title == "string" ? html `<h2>${title}</h2>` : title}
						${typeof body == "string" ? html `<p>${body}</p>` : body}
						${xioTextInput}
						<div data-buttons>
							<xio-button
								data-button=yes
								data-vibe=${yes.vibe}
								?disabled=${hasProblems()}
								@press=${finish.yes}>
									${yes.label}
							</xio-button>
							<xio-button
								data-button=no
								data-vibe=${no.vibe}
								@press=${finish.no}>
									${no.label}
							</xio-button>
						</div>
					</div>
				`;
                },
            });
            const finish = prepareFinishingMoves(controls);
            xioTextInput.onvaluechange = () => controls.rerender();
            xioTextInput.onenterpress = () => finish.yes();
            modal.addEventListener("keyup", ({ key }) => {
                if (key === "Escape")
                    finish.no();
            });
        });
    }

    function prepareConfirm(popup) {
        return async ({ title, body = null, yes = { label: "yes", vibe: "positive" }, no = { label: "no", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => new Promise(resolve => {
            popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansNo
                    ? controls => {
                        controls.close();
                        resolve(false);
                    }
                    : () => { },
                renderContent: controls => {
                    const onYes = () => {
                        controls.close();
                        resolve(true);
                    };
                    const onNo = () => {
                        controls.close();
                        resolve(false);
                    };
                    return html `
					<div data-confirm>
						${typeof title == "string" ? html `<h2>${title}</h2>` : title}
						${typeof body == "string" ? html `<p>${body}</p>` : body}
						<div data-buttons>
							<xio-button
								data-button=yes
								data-vibe="${yes.vibe}"
								@press=${onYes}>
									${yes.label}
							</xio-button>
							<xio-button
								data-button=no
								data-vibe="${no.vibe}"
								@press=${onNo}>
									${no.label}
							</xio-button>
						</div>
					</div>
				`;
                },
            });
        });
    }

    var modalSystemStyles = css `

*:focus {
	outline: var(--focus-outline);
}

[data-modal-system] {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	display: block;
}

[data-modal-system] [data-blanket] {
	z-index: 101;
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	display: block;
	background: #0008;
	backdrop-filter: blur(10px);
}

[data-modal-system] [data-plate] {
	z-index: 102;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;

	width: 96%;
	max-width: 32em;
	min-height: 1em;
	margin: 2em auto;

	background: linear-gradient(to bottom right, #fff, #ccc);
	color: #444;
}

[data-modal-system] [data-content]:focus {
	outline: unset;
}

[data-modal-system] [data-confirm] {
	padding: 1em;
}

[data-modal-system] [data-buttons] {
	margin-top: 1em;
	text-align: right;
}

[data-modal-system] [data-button] {
	--xio-button-hover-color: white;
	--xio-button-hover-background: #666;
}

[data-modal-system] [data-vibe=positive] {
	color: green;
	--xio-button-hover-color: white;
	--xio-button-hover-background: green;
}

[data-modal-system] [data-vibe=negative] {
	color: #a00;
	--xio-button-hover-color: white;
	--xio-button-hover-background: #a00;
}

`;

    function prepareModalSystemRendering(listModals) {
        const style = document.createElement("style");
        render$1(modalSystemStyles, style);
        const element = document.createElement("div");
        element.setAttribute("data-modal-system", "");
        function rerender() {
            render$1(html `
			${style}
			${listModals().map(modal => modal.render())}
		`, element);
        }
        return { element, rerender };
    }

    function setupModalSystem() {
        let count = 0;
        const modals = new Map();
        const listModals = () => Array.from(modals.values());
        const { rerender, element } = prepareModalSystemRendering(listModals);
        function popup({ focusNthElement, renderContent, onBlanketClick }) {
            const id = count++;
            const controls = {
                rerender,
                close: () => {
                    modals.delete(id);
                    rerender();
                },
            };
            const top = window.pageYOffset
                ?? document.documentElement.scrollTop
                ?? document.body.scrollTop
                ?? 0;
            const handleBlanketClick = () => onBlanketClick(controls);
            modals.set(id, {
                render() {
                    return html `
					<div data-modal="${id}">
						<div data-blanket @click=${handleBlanketClick}></div>
						<div data-plate style="top: ${top}px">
							${renderContent(controls)}
						</div>
					</div>
				`;
                },
            });
            rerender();
            const modal = element.querySelector(`[data-modal="${id}"]`);
            trapFocus(modal, focusNthElement);
            return { controls, modal };
        }
        return {
            modalsElement: element,
            modals: {
                popup,
                confirm: prepareConfirm(popup),
                prompt: preparePrompt(popup),
            },
        };
    }

    async function loginWithLinkTokenOrUseExistingLogin({ link, authModel }) {
        const { searchParams } = new URL(link);
        const loginToken = searchParams.get("login");
        if (loginToken)
            await authModel.login(loginToken);
        else
            await authModel.useExistingLogin();
    }

    async function assembleAndInitializeFrontend({ appId, popups, authMediator, remote, }) {
        const storage = simpleFlexStorage(window.localStorage);
        const { modals, modalsElement } = setupModalSystem();
        const models = await assembleModels({
            appId,
            remote,
            popups,
            storage,
            authMediator,
        });
        const components = getComponents({ models, modals });
        await loginWithLinkTokenOrUseExistingLogin({
            authModel: models.authModel,
            link: window.location.toString(),
        });
        return { components, models, modals, modalsElement };
    }

    async function demos() {
        const connection = await mockConnectApp({
            appWindowLink: window.location.href,
            origins: [window.location.origin],
            storage: memoryFlexStorage(),
            latency: false,
        });
        const frontend = await assembleAndInitializeFrontend(connection);
        applyMockHacks({ connection, frontend });
        const xiome = { ...connection, ...frontend };
        document.body.prepend(xiome.modalsElement);
        await xiome.models.authModel.sendLoginLink("creative@xiome.io");
        const demoComponents = {};
        for (const [key, value] of Object.entries(xiome.components))
            demoComponents[`Demo${key}`] = value;
        registerComponents(demoComponents);
    }

    function capitalizedHeaders(headers) {
        const headers2 = {};
        for (const [key, value] of Object.entries(headers)) {
            const parts = key.split("-");
            const parts2 = parts.map(part => {
                const [first, ...rest] = part;
                return [first.toUpperCase(), ...rest].join("");
            });
            const key2 = parts2.join("-");
            headers2[key2] = value;
        }
        return headers2;
    }

    function makeJsonRequester({ fetch, headers }) {
        return async function requester({ link, args, meta, specifier }) {
            const request = jsonHttpRequest({
                link,
                args,
                meta,
                headers,
                specifier,
            });
            const fetchRequest = new window.Request(link, {
                body: request.body,
                method: request.method,
                headers: capitalizedHeaders(request.headers),
            });
            const fetchResponse = await fetch(fetchRequest);
            const collectHeaders = {};
            fetchResponse.headers.forEach((value, key) => collectHeaders[key] = value);
            const responseHeaders = collectHeaders;
            const result = parseJsonResponse({
                headers: responseHeaders,
                status: fetchResponse.status,
                body: await fetchResponse.text(),
            });
            return result;
        };
    }

    function makeRemote({ appId, apiLink, storage, }) {
        const { shape, installAuthMediator } = prepareApiShape({
            appId,
            storage,
        });
        const remote = generateRemote({
            link: apiLink,
            shape: shape,
            requester: makeJsonRequester({
                fetch: window.fetch,
                headers: {},
            }),
        });
        const authMediator = installAuthMediator({
            greenService: remote.auth.greenService,
        });
        return { remote, authMediator };
    }

    var PopupFlag;
    (function (PopupFlag) {
        // popup says "hey, i'm done loading"
        PopupFlag[PopupFlag["ReadyResponse"] = 0] = "ReadyResponse";
        // host page says "ok popup, now get to work"
        PopupFlag[PopupFlag["GoRequest"] = 1] = "GoRequest";
        // popup says "here's the result"
        PopupFlag[PopupFlag["PayloadResponse"] = 2] = "PayloadResponse";
        // popup says "this terrible error occurred"
        PopupFlag[PopupFlag["ErrorResponse"] = 3] = "ErrorResponse";
    })(PopupFlag || (PopupFlag = {}));

    function centeredPopupFeatures(width = 260, height = 260) {
        const { outerWidth, outerHeight, screenY, screenX } = window.top;
        const top = ((outerHeight / 2) + screenY - (height / 2)) / 2;
        const left = (outerWidth / 2) + screenX - (width / 2);
        return `
		width=${width},
		height=${height},
		top=${top},
		left=${left},
		toolbar=no,
		location=no,
		status=no,
		menubar=no,
		scrollbars=yes,
		resizable=yes
	`;
    }

    function validateResponse({ event, namespace, popupOrigin, }) {
        const relevant = !!event.data
            && event.data.namespace === namespace;
        const originsMatch = event.origin.toLowerCase() === popupOrigin.toLowerCase();
        if (relevant) {
            if (originsMatch)
                return true;
            else
                console.warn(`message denied from origin "${event.origin}"`, event);
        }
        return false;
    }

    function openPopup({ popupLink, namespace, parameters, }) {
        const popupOrigin = new URL(popupLink).origin;
        // scope these variables high up, so we can return closePopup
        let popup;
        let messageListener;
        function closePopup() {
            window.removeEventListener("message", messageListener);
            popup.close();
        }
        const promisedPayload = new Promise((resolve, reject) => {
            messageListener = (event) => {
                const message = event.data;
                if (validateResponse({ event, popupOrigin, namespace })) {
                    try {
                        if (message.flag === PopupFlag.ReadyResponse) {
                            popup.postMessage({
                                namespace,
                                parameters,
                                flag: PopupFlag.GoRequest,
                            }, popupOrigin);
                        }
                        else if (message.flag === PopupFlag.PayloadResponse) {
                            const { payload } = message;
                            closePopup();
                            resolve(payload);
                        }
                        else if (message.flag === PopupFlag.ErrorResponse) {
                            const { error } = message;
                            closePopup();
                            reject(error);
                        }
                        else {
                            closePopup();
                            throw new Error("unknown popup message flag");
                        }
                    }
                    catch (error) {
                        closePopup();
                        reject(error);
                    }
                }
            };
        });
        window.addEventListener("message", messageListener);
        popup = window.open(popupLink, namespace, centeredPopupFeatures());
        popup.focus();
        return { closePopup, promisedPayload };
    }

    const bankPopupNamespace = "xiome-bank-popup";

    function openBankPopup({ popupLink, stripeAccountId, stripeAccountSetupLink, }) {
        return openPopup({
            popupLink,
            namespace: bankPopupNamespace,
            parameters: { stripeAccountId, stripeAccountSetupLink },
        });
    }

    function systemPopups({ popupsBase }) {
        return {
            triggerBankPopup: (async ({ stripeAccountId, stripeAccountSetupLink }) => {
                const result = openBankPopup({
                    popupLink: `${popupsBase}/bank`,
                    stripeAccountId,
                    stripeAccountSetupLink,
                });
                return result.promisedPayload;
            }),
        };
    }

    async function connect({ appId, apiOrigin = "https://api.xiome.io", platformOrigin = "https://xiome.io" }) {
        const { remote, authMediator } = makeRemote({
            appId,
            apiLink: `${apiOrigin}/`,
            storage: simpleFlexStorage(window.localStorage),
        });
        wireMediatorBroadcastChannel(authMediator);
        const popups = systemPopups({ popupsBase: `${platformOrigin}/popups` });
        return { appId, remote, authMediator, popups };
    }

    async function mockConnectPlatform({ platformHome, storage, }) {
        const backend = await configureApiForBrowser(mockConfig({
            platformHome,
            platformOrigins: [new URL(platformHome).origin],
        }));
        const apiLink = apiOrigin + "/";
        const appId = backend.platformAppId;
        const { remote, authMediator } = await mockWiredRemote({
            appId,
            apiLink,
            backend,
            storage,
            appWindowLink: platformHome,
            latency: { min: 200, max: 800 },
        });
        const popups = mockPopups({
            mockStripeOperations: backend.mockStripeOperations,
        });
        return { appId, remote, authMediator, backend, popups };
    }

    async function mockConnect(config) {
        const options = {
            origins: [window.location.origin],
            storage: simpleFlexStorage(window.localStorage),
            platformHome: window.location.href,
            appWindowLink: window.location.href,
            latency: { min: 200, max: 800 },
        };
        return config.mock === "platform"
            ? await mockConnectPlatform(options)
            : await mockConnectApp(options);
    }

    async function assembleXiome(config) {
        const isMock = config.mock;
        const connection = isMock
            ? await mockConnect(config)
            : await connect(config);
        const frontend = await assembleAndInitializeFrontend(connection);
        if (isMock)
            applyMockHacks({
                connection: connection,
                frontend,
            });
        return { ...connection, ...frontend };
    }

    function readXiomeConfigElement() {
        const xiomeConfig = document.querySelector("xiome-config");
        if (!xiomeConfig)
            throw new Error(`<xiome-config> is required`);
        const attribute = (attr) => xiomeConfig.getAttribute(attr) ?? undefined;
        const fresh = {
            mock: attribute("mock"),
            appId: attribute("app"),
            apiOrigin: attribute("api"),
            platformOrigin: attribute("platform"),
        };
        const mock = fresh.mock === undefined
            ? undefined
            : fresh.mock === "platform"
                ? "platform"
                : "app";
        return mock
            ? { mock }
            : {
                appId: fresh.appId,
                apiOrigin: fresh.apiOrigin,
                platformOrigin: fresh.platformOrigin,
            };
    }

    void async function xiome() {
        const xiome = await assembleXiome(readXiomeConfigElement());
        document.body.prepend(xiome.modalsElement);
        registerComponents(xiome.components);
        window.xiome = xiome;
        if (/^((stage\.|)xiome\.io|localhost)$/.test(window.location.hostname))
            await demos();
    }();

}());
//# sourceMappingURL=xiome.bundle.js.map
