export { and, or, find } from "./dbby-helpers.js";
export async function dbbyX(flexStorage, tableName) {
    const storageKey = `dbby-${tableName}`;
    let table = [];
    async function load() {
        table = await flexStorage.read(storageKey) || [];
    }
    await load();
    async function save() {
        if (flexStorage)
            await flexStorage.write(storageKey, table);
    }
    function select(conditional) {
        return table.filter(row => rowVersusConditional(row, conditional));
    }
    function selectOne(conditional) {
        return table.find(row => rowVersusConditional(row, conditional));
    }
    function updateRow(rows, update) {
        for (const row of rows) {
            for (const [key, value] of Object.entries(update)) {
                ;
                row[key] = value;
            }
        }
    }
    function insertCopy(row) {
        table.push(copy(row));
    }
    function eliminateRow(conditional) {
        const flippedFilterRow = (row) => !rowVersusConditional(row, conditional);
        table = table.filter(flippedFilterRow);
    }
    return {
        async create(...rows) {
            await load();
            for (const row of rows)
                insertCopy(row);
            await save();
        },
        async read({ order, offset = 0, limit = 1000, ...conditional }) {
            await load();
            const rows = copy(select(conditional));
            if (order) {
                for (const [key, value] of Object.entries(order)) {
                    rows.sort((a, b) => value === "ascend"
                        ? a[key] > b[key] ? 1 : -1
                        : a[key] > b[key] ? -1 : 1);
                }
            }
            return rows.slice(offset, offset + limit);
        },
        async one(conditional) {
            await load();
            return copy(selectOne(conditional));
        },
        async assert({ make, ...conditional }) {
            await load();
            let row = copy(selectOne(conditional));
            if (!row) {
                const made = await make();
                insertCopy(made);
                row = copy(made);
                await save();
            }
            return row;
        },
        async update({ write, whole, upsert, ...conditional }) {
            await load();
            const rows = select(conditional);
            if (write && rows.length) {
                updateRow(rows, write);
            }
            else if (upsert) {
                if (rows.length)
                    updateRow(rows, upsert);
                else
                    insertCopy(upsert);
            }
            else if (whole) {
                eliminateRow(conditional);
                insertCopy(whole);
            }
            else
                throw new Error("invalid update");
            await save();
        },
        async delete(conditional) {
            await load();
            eliminateRow(conditional);
            await save();
        },
        async count(conditional) {
            await load();
            return select(conditional).length;
        },
    };
}
function copy(x) {
    if (x === undefined)
        return undefined;
    return JSON.parse(JSON.stringify(x));
}
function compare(row, conditional, evaluator) {
    let failures = 0;
    for (const [key, value] of Object.entries(conditional)) {
        if (!evaluator(row[key], value))
            failures += 1;
    }
    return !failures;
}
function rowVersusConditional(row, conditional) {
    function crawl(conditions) {
        if (conditions === false)
            return true;
        const [operation, ...rawconds] = conditions;
        const conds = rawconds.filter(c => !!c);
        if (conds.length === 0)
            throw new Error("empty and/or conditions are not allowed");
        const and = operation === "and";
        let valid = and;
        const applyResult = (result) => valid = and
            ? valid && result
            : valid || result;
        for (const condition of conds) {
            if (condition === false || Array.isArray(condition)) {
                applyResult(crawl(condition));
            }
            else {
                const result = rowVersusCondition(row, condition);
                applyResult(result);
            }
        }
        return valid;
    }
    return crawl(conditional.conditions);
}
function rowVersusCondition(row, condition) {
    if (!Object.keys(condition).length)
        return true;
    let failures = 0;
    const check = (conditions, evaluator) => {
        if (conditions && !compare(row, conditions, evaluator))
            failures += 1;
    };
    const checks = {
        set: a => a !== undefined && a !== null,
        equal: (a, b) => a === b,
        greater: (a, b) => a > b,
        greatery: (a, b) => a >= b,
        less: (a, b) => a < b,
        lessy: (a, b) => a <= b,
        listed: (a, b) => a.includes(b),
        search: (a, b) => typeof b === "string" ? a.includes(b) : b.test(a),
    };
    function not(evaluator) {
        return (a, b) => !evaluator(a, b);
    }
    check(condition.set, checks.set);
    check(condition.equal, checks.equal);
    check(condition.greater, checks.greater);
    check(condition.greatery, checks.greatery);
    check(condition.less, checks.less);
    check(condition.lessy, checks.lessy);
    check(condition.listed, checks.listed);
    check(condition.search, checks.search);
    check(condition.notSet, not(checks.set));
    check(condition.notEqual, not(checks.equal));
    check(condition.notGreater, not(checks.greater));
    check(condition.notGreatery, not(checks.greatery));
    check(condition.notLess, not(checks.less));
    check(condition.notLessy, not(checks.lessy));
    check(condition.notListed, not(checks.listed));
    check(condition.notSearch, not(checks.search));
    return !failures;
}
//# sourceMappingURL=dbby-x.js.map