import { objectMap } from "../object-map.js";
import { escapeRegex } from "../escape-regex.js";
export { and, or, find } from "./dbby-helpers.js";
function skimMongoId(row) {
    if (row) {
        const { _id: noop, ...skimmed } = row;
        return skimmed;
    }
    return undefined;
}
export function dbbyMongo({ collection }) {
    return {
        async create(...rows) {
            await collection.insertMany(rows);
        },
        async read({ order, offset = 0, limit = 10000, ...conditional }) {
            const query = prepareQuery(conditional);
            let cursor = collection.find(query, undefined);
            if (offset)
                cursor = cursor.skip(offset);
            if (order)
                cursor = cursor.sort(orderToSort(order));
            if (limit)
                cursor = cursor.limit(limit);
            const rows = await cursor.toArray();
            return rows.map(skimMongoId);
        },
        async one(conditional) {
            const query = prepareQuery(conditional);
            const row = await collection.findOne(query);
            return skimMongoId(row);
        },
        async assert({ make, ...conditional }) {
            const query = prepareQuery(conditional);
            let row = await collection.findOne(query);
            if (!row) {
                row = await make();
                await collection.insertOne(row);
            }
            return skimMongoId(row);
        },
        async update({ write, whole, upsert, ...conditional }) {
            const query = prepareQuery(conditional);
            if (write) {
                await collection.updateMany(query, { $set: write }, { upsert: false });
            }
            else if (upsert) {
                await collection.updateOne(query, { $set: upsert }, { upsert: true });
            }
            else if (whole) {
                await collection.deleteMany(query);
                await collection.insertOne(whole);
            }
            else
                throw new Error("invalid update");
        },
        async delete(conditional) {
            const query = prepareQuery(conditional);
            await collection.deleteMany(query);
        },
        async count(conditional) {
            const query = prepareQuery(conditional);
            return collection.count(query);
        },
    };
}
function prepareQuery({ conditions }) {
    if (!conditions)
        return {};
    function recurse(tree) {
        const [operator, ...conds] = tree;
        const query = conds
            .map(cond => Array.isArray(cond)
            ? recurse(cond)
            : conditionsToMongoQuery(cond))
            .filter(cond => !!cond);
        return operator === "and"
            ? { $and: query }
            : { $or: query };
    }
    return recurse(conditions);
}
function orderToSort(order) {
    return objectMap(order, value => !!value
        ? value === "ascend"
            ? 1
            : -1
        : 0);
}
function isSet(a) {
    return a !== undefined && a !== null;
}
function mapwise(x, y) {
    return x && objectMap(x, y);
}
function notwise(x, y) {
    const cond = mapwise(x, y);
    return cond && { $nor: [cond] };
}
const mongoloids = {
    set: value => ({ $exists: value }),
    equal: value => ({ $eq: value }),
    greater: value => ({ $gt: value }),
    greatery: value => ({ $gte: value }),
    less: value => ({ $lt: value }),
    lessy: value => ({ $lte: value }),
    listed: value => ({ $in: [value] }),
    search: value => ({
        $regex: typeof value === "string"
            ? escapeRegex(value)
            : value
    }),
};
function conditionsToMongoQuery(conditions) {
    return conditions
        ? {
            $and: [
                mapwise(conditions.set, mongoloids.set),
                mapwise(conditions.equal, mongoloids.equal),
                mapwise(conditions.greater, mongoloids.greater),
                mapwise(conditions.greatery, mongoloids.greatery),
                mapwise(conditions.less, mongoloids.less),
                mapwise(conditions.lessy, mongoloids.lessy),
                mapwise(conditions.listed, mongoloids.listed),
                mapwise(conditions.search, mongoloids.search),
                notwise(conditions.notSet, mongoloids.set),
                notwise(conditions.notEqual, mongoloids.equal),
                notwise(conditions.notGreater, mongoloids.greater),
                notwise(conditions.notGreatery, mongoloids.greatery),
                notwise(conditions.notLess, mongoloids.less),
                notwise(conditions.notLessy, mongoloids.lessy),
                notwise(conditions.notListed, mongoloids.listed),
                notwise(conditions.notSearch, mongoloids.search),
            ].filter(isSet)
        }
        : {};
}
//# sourceMappingURL=dbby-mongo.js.map